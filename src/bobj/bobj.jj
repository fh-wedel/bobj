/****************************************************
*           The Parser for BOBJ
 ****************************************************/

options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(BOBJ)

package bobj;

import java.util.*;
import java.io.*;

public class BOBJ {

    final public static int KEYBOARD_INPUT = 0;
    final public static int FILE_INPUT = 1;

    public static BOBJ client;

    private String logo =
            "                     \\|||||||||||||||||/\n"+
            "                   --- Welcome to BOBJ ---\n"+
            "                     /|||||||||||||||||\\\n"+
            "      BOBJ version 0.9.78 built: Tue Sep 18 16:15:05 PDT 2001\n"+
            "               University of California, San Diego\n"+
            "                  "+new java.util.Date()+"\n";

    private String prompt = "BOBJ> ";
    private String pwd;                   // current working directory
    private int mode = KEYBOARD_INPUT;    // wait for input from keyboard
                                          // output is different if using
	                                  // FILE_INPUT

    private Module currentModule;         // the lastest defined module 
    private Module dynmaicModule;         // an opening module
    private Cobasis currentCobasis;       // the latest defined cobasis
    private CaseModule localCase;
    private BOBJ root;
    private Term currentTerm;             
    private Stack termStack = new Stack();

    private Date time = new Date();
    private boolean timeChecked = false;

    protected Hashtable modPool = new Hashtable();     // all defined modules
    private Module lastModule; 
    private Hashtable viewPool = new Hashtable();    // all defined view
    private Hashtable paraPool;
    private Hashtable cobasisPool = new Hashtable(); // add defined cobasis
    private Hashtable casesPool = new Hashtable();
    private RewriteEngine engine;

    private boolean cobasisUpdated = true;
    private boolean trace = false;
    private boolean boolInclude = true;
    private boolean detail = false;
    private boolean lookForParameter = false;

    private Writer writer = new PrintWriter(System.out); 

    public String getLogo() {
        return logo;
    }


    public String getPrompt() {
        return prompt;
    }


    public String getPwd() {
        if (pwd == null) {
	    pwd = System.getProperty("user.dir");
        }
        return pwd;    
    }


    private void setPwd(String pwd) {
        this.pwd = pwd;
    }


    public Module getCurrentModule() {
        return currentModule;
    }


    public Map getEnv() {

	Map map = new HashMap();

	Enumeration enum_ = modPool.keys();
	while (enum_.hasMoreElements()) {
	    ModuleName modName = (ModuleName)enum_.nextElement();
	    Module module = (Module)modPool.get(modName);
	    map.put(modName, new Integer(module.type));
	}

	return map;

    }


    public static void parseFile(String fileName) throws ParseException {
        try {
            BOBJ parser = new BOBJ(new FileInputStream(fileName));
            parser.Command(); 
        } catch (FileNotFoundException e) {
            throw new ParseException("File " +fileName+" not found");  
        } catch (java.io.IOException e) {
            throw new ParseException("io exception during parse "+fileName);
        }
    }


    protected static String format(String txt, int prefix) {

       String result = "";

       int size = prefix;
       StringTokenizer ster = new StringTokenizer(txt, " \n");
       while (ster.hasMoreTokens()) {
	  String  tmp = ster.nextToken();
	  if (size + tmp .length()< 70) {
	     result += tmp+" ";
             size += tmp.length()+1;
	  } else {
             result += "\n    "+tmp+" ";
	     size = 5+tmp.length();
	  }
       }    
   
       return result;
    }


    public void setWriter(Writer writer) {
        this.writer = writer;
    }


    private void saveModule(Module module) {
	Enumeration enum_ = modPool.keys();
	while (enum_.hasMoreElements()) {
	    ModuleName modName = (ModuleName)enum_.nextElement();
	    if (modName.equals(module.getModuleName())) {
	        modPool.remove(modName);
	    }
	}
	modPool.put(module.getModuleName(), module);
        lastModule = module;
    }


    private boolean containsModule(ModuleName modName) {
	Enumeration enum_ = modPool.keys();
	while (enum_.hasMoreElements()) {
	    ModuleName tmp = (ModuleName)enum_.nextElement();
	    if (modName.equals(tmp)) {
		return true;
	    }
        }
        return false;
    }


    private Module getModule(String name) {

        Module module = null;

        if (paraPool != null) {
	     // find a module from parameter 
             module = (Module)paraPool.get(name);
	} 

        if (module == null) {

	     // find module from previously defined modules
             ModuleName modName = new ModuleName(name);

	     module = null;
             Enumeration enum_ = modPool.keys();
             while (enum_.hasMoreElements()) {
	         ModuleName tmp = (ModuleName)enum_.nextElement();
                 if (tmp.equals(modName)) {
                     module = (Module)modPool.get(tmp);
	             module = (Module)module.clone();
	             break;
                 }
             }

        } else {
             module = (Module)module.clone();
	     module.setProperty("parameter", name);
        }

        if (module == null) {

             // find module from system default modules
             module = ModuleFactory.getDefaultModule(name);
        }

	return module;

   }




    public static void main(String args[]) {

	//BOBJ client = new BOBJ(System.in);
	client = new BOBJ(System.in);

        try {

           client.getPwd();
           client.writer.write(client.getLogo());
           client.writer.flush();
           while (true) {
             try {
                client.writer.write(client.getPrompt());
	        client.writer.flush();

                client.Command();

		int max = client.jj_input_stream.maxNextCharInd;
                int next = client.jj_input_stream.nextCharInd;

		boolean more = false;
	        for (int i=next; i<max; i++){
		  if (client.jj_input_stream.nextCharBuf[i] != ' ' &&
		      client.jj_input_stream.nextCharBuf[i] != '\n' &&
		      client.jj_input_stream.nextCharBuf[i] != '\t' &&
                      client.jj_input_stream.nextCharBuf[i] != '\r') {

		      more = true;
		  }
	        }
	

	        while (more) {
	           client.Command();

		   max = client.jj_input_stream.maxNextCharInd;
                   next = client.jj_input_stream.nextCharInd;

		   more = false;
	           for (int i=next; i<max; i++){
		      if (client.jj_input_stream.nextCharBuf[i] != ' ' &&
		          client.jj_input_stream.nextCharBuf[i] != '\n' &&
		          client.jj_input_stream.nextCharBuf[i] != '\t' &&
                          client.jj_input_stream.nextCharBuf[i] != '\r' ) {
		        more = true;

		      }
	           }
                }

                client.ReInit(System.in);

	     } catch (Throwable e) {

                // display error message
                String msg = e.getMessage();
		if (msg != null && msg.trim().length() > 0) {
                   client.writer.write(e.getMessage());
	           client.writer.write("\n");
	           client.writer.flush();
                }

	        if (client.mode != FILE_INPUT &&
		    msg.indexOf("Encountered \"<EOF>\"") != -1) {
	            System.exit(0);
                }

	        // restart the parser
	        client.ReInit(System.in);

	     } 
           }
       } catch (Exception ex) {

          String msg = ex.getMessage();
	  if (msg != null && msg.length() > 0) {
	      System.err.println(msg);
	  }

       } 

    }

}





PARSER_END(BOBJ)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
| "***(" :  MULTIPLE_LINE_COMMENT
}


<MULTIPLE_LINE_COMMENT> SKIP:
{
   ")***" : DEFAULT
}

<MULTIPLE_LINE_COMMENT> MORE:
{
    < ~[] >
}

/* COMMENTS */
MORE :
{
  "***" : IN_SINGLE_LINE_COMMENT
}


<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}


<IN_SINGLE_LINE_COMMENT> MORE :
{
  < ~[] >
}


TOKEN :
{
  < OBJ: "obj" >
| < TH: "th" >
| < BTH: "bth">
| < DTH: "dth">
| < ENDO: "endo" >
| < ENDTH: "endth" >
| < ENDB: "endb">
| < ENDD: "endd">
| < END: "end">
| < PR: "pr">
| < PROTECTING: "protecting">
| < EX: "ex">
| < EXTENDING: "extending">
| < US: "us">
| < USE: "use">
| < USING: "using">
| < INC: "inc">
| < INCLUDING: "including">
| < IS: "is" >
| < SORT: "sort" >
| < SORTS: "sorts" >
| < BSORT: "dsort" >
| < BSORTS: "dsorts">
| < PSORT: "psort">
| < SUBSORT: "subsort">
| < SUBSORTS: "subsorts">
| < VAR: "var" >
| < VARS: "vars">
| < OP: "op" >
| < OPS: "ops" >
| < OPAS: "op-as">
| < EQ: "eq">
| < CQ: "cq">
| < CEQ: "ceq">
| < ASSOC: "assoc">
| < COMM: "comm">
| < IDEM: "idem">
| < PREC: "prec">
| < IDR: "idr:">
| < ID: "id:">
| < NONCONG: "ncong">
| < MEMO: "memo">
| < LESS: "<">
| < ARROW: "->" >
| < DOT: "." >
| < VARSOF: "vars-of">
| < COLON: ":">
| < DOUBLECOLON: "::">
| < ADD: "+">
| < SUM: "||">
| < TO: "to">
| < STAR: "*">
| < LB: "[">
| < RB: "]">
| < DFN: "dfn">
| < RED: "red">
| < BRED: "cred">
| < SOLVE: "solve">
| < OPEN: "open">
| < OPENR: "openr">
| < CLOSE: "close">
| < VIEW: "view" >
| < ENDV: "endv" >
| < FROM: "from" >
| < LOAD: "load" >
| < APPLY: "apply">
| < START: "start">
| < AT: "at">
| < WITH: "with">
| < WITHIN: "within">
| < PRINT: "print">
| < PARENS: "parens">
| < OF: "of">
| < QUIT: "q">
| < PWD: "pwd">
| < CD: "cd">
| < LS: "ls">
| < IN: "in">
| < SHOW: "show">
| < MAKE: "make">
| < ENDM: "endm">
| < LET: "let" >
| < COMMENT: "***>">
| < COBASIS: "cobasis">
| < COB: "cob">
| < COV: "cov">
| < STOP: "eof">
| < SELECT: "select">
| < SET: "set">
| < TRACE: "trace" >
| < ON: "on" >
| < OFF: "off" >
| < FULL: "full">
| < PARSE: "parse">
| < INCLUDE: "include">
| < REDUCTION: "reduction">
| < REDUCE: "reduce">
| < TIME: "time">
| < RULES: "rules">
| < JBO: "jbo" >
| < ASSOCIATIVE: "associative">
| < COMMUTATIVE: "commutative">
| < HT: "ht">
| < WEIV: "weiv">
| < ENDVIEW: "endview">
| < GATHERING: "gathering">
| < PRECEDENCE: "precedence">
| < THEORY: "theory">
| < SH: "sh">
| < LONGQUIT: "quit">
| < IDEMPOTENT: "idempotent">
| < OBJECT: "object" >
| < IDENTITY: "identity">
| < DEFINE: "define">
| < INPUT: "input">
| < CONTEXT: "context">
| < CASE: "case">
| < FOR: "for" >
| < MORPH: "morph">
| < MB: "mb" >
}



TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}


TOKEN :
{
   < IDENTIFIER: (
                      <LETTER>
                    | <DIGIT>
                    | <SYMBOL>
                    | ":" ~[" ", "\n", "\t", "\r", "("]
                    | "." ~[" ", "\n", "\t", "\r", "("]
                    | ~[" ", "\n", "\t", "\r", "(", ")"] ":"

                  )+ 
    >
|
  < SYMBOL:      (
                      "-" 
                    | "'"
                    | "+"
                    | "*"
                    | "<"
                    | ">"
                    | "?"
                    | "|"
                    | "="
                    | "&"
                    | "/"
                    | "^"
                    | "%"
                    | "#"
                    | "!"
                    | "@"
                    | "~"
                    | ";"
		    | "{"
		    | "}"
                    | "\\"
                    | "$"
                    | "\""
                 )
  >
|
  < LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >

}




/*****************************************
 * THE BOBJ LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/



void Command() throws IOException :
{
    Token token = null;
    Module module = null;
    View view = null;
}
{

 (

   "q" 
      {
	 writer.write("Bye.\n");
         writer.flush();
         System.exit(0);
      }
 |
   "quit"
      {
	 writer.write("Bye.\n");
         writer.flush();
         System.exit(0);
      }      
 |
   "pwd" 
      {
    	 writer.write(getPwd()+"\n");
	 writer.flush();
      }
 |

   "cd"
    (
       token=MetaToken()
       |
       token=<IDENTIFIER>
       |
       token=<INTEGER_LITERAL>
    )
      {
	 String dir = token.image;
         File file;
	 if (dir.startsWith(File.separator)) {
	     file = new File(dir);
         } else {
             file = new File(pwd+File.separator+dir);
         }

         if (file.exists() && file.isDirectory() && file.canRead()) {

	     pwd = file.getAbsolutePath(); 
	     StringTokenizer st = new StringTokenizer(pwd, File.separator);
	     ArrayList list = new ArrayList();
	     while (st.hasMoreTokens()) {
		list.add(st.nextToken());
	     }

	     pwd = "";
	     int count = 0;
	     for (int i=list.size()-1; i>-1; i--) {
		String tmp = (String)list.get(i);
		if (tmp.equals(".")) {
		    continue;
	        } else if (tmp.equals("..")) {
		    count++;
		} else if (count > 0) {
		    count--;
	        } else {
		    pwd = tmp+File.separator+pwd;
		}
	     }
             pwd = File.separator+pwd;

	   } else {
	        writer.write(dir+": No such file or directory\n");
	        writer.flush();
	   }
       
      }
    
   |
     "ls"  
      {

         String[] files = (new File(getPwd())).list();
 
         int maxLength = -1;
         for (int i=0; i<files.length; i++) {
            maxLength = Math.max(files[i].length(), maxLength);
         }

	 int column = 70/(maxLength+8);
         column++;
 	 int width = 70/column;

         String line = "";
         int colIndex = 0;
         for (int i=0; i<files.length; i++) {
         if (colIndex < column ) {
	    line += files[i];
            for (int j=0; j<(width-files[i].length()); j++)
	       line += " ";
            colIndex ++;
         } else {
            writer.write(line+"\n");
            line = files[i];
            for (int j=0; j<(width-files[i].length()); j++)
	       line += " ";
               colIndex = 1;
            }
         }
         writer.write(line+"\n");
	 writer.flush();

      }
  |
    ( "in" | "input" )
    (
      token=<IDENTIFIER>
      |
      token=MetaToken()
      |
      token=<INTEGER_LITERAL>
    )
      {

          String filename = token.image;
          if (filename.startsWith(File.separator)) {
            // do nothing
	  } else {
	     String pwd = getPwd();
	     if (pwd.endsWith(File.separator)) {
                filename = getPwd() + filename;
	     } else {
	        filename = getPwd() + File.separator + filename;
             }
	  }

          file = new File(filename);
          if (!file.exists() || !file.isFile()) {

            file = new File(filename+".bob");
            if (file.exists() && file.isFile()) {

	       filename = filename+".bob";

	    } else {

	       file = new File(filename+".obj");
               if (file.exists() && file.isFile()) {
	          filename = filename+".obj";
	       } else {
		  throw new ParseException("can not find "+token.image+
				           " in "+pwd);
	       }
	    }
	  }

	  if (mode == FILE_INPUT ) {
	      writer.write("==========================================\n");
              writer.write("in "+token.image+"\n");
	      writer.flush();
	  }
          
          RewriteEngine.cleanCache();

	  FileInputStream fis =  new FileInputStream(filename);
	  
          String newline = "\n";
	  ByteArrayInputStream bais =
	      new ByteArrayInputStream(newline.getBytes());

	  SequenceInputStream sis = new SequenceInputStream(fis, bais);

          BOBJ bobj = new BOBJ(sis);
          bobj.mode = FILE_INPUT;

          // give the current environment to new parser
          bobj.root = this;
          bobj.modPool = (Hashtable)modPool.clone();
          bobj.viewPool = (Hashtable)viewPool.clone();
          bobj.currentModule = this.currentModule;
          bobj.dynmaicModule = this.dynmaicModule;
          bobj.lastModule = this.lastModule;
          bobj.cobasisPool = this.cobasisPool;
          bobj.casesPool = this.casesPool;
          bobj.trace = this.trace;
          bobj.boolInclude = this.boolInclude;
          bobj.detail = this.detail;
          bobj.pwd = this.pwd;
	  bobj.currentTerm = this.currentTerm;
	  bobj.termStack = this.termStack;
	  bobj.time = this.time;
	  bobj.timeChecked = this.timeChecked;

	  client = bobj;

          try {

               bobj.BatchCommand();

	       if (this.root != null) {
                  writer.write("==========================================\n");
	          writer.write("exiting "+filename+"\n");
                  writer.flush();
	       }

          } catch (Exception e) {

	       //e.printStackTrace();

	       writer.write("==========================================\n");
               String msg = e.getMessage();
               if (msg != null &&
                   msg.startsWith("multiple parsing results:")) {
	           writer.write(msg+"\n");
               } else if (msg != null &&
                   msg.startsWith("format:")) {
	           writer.write(msg.substring(7)+"\n");		
	       } else if (msg != null && msg.length() > 0) {
		   if (msg.length() < 500 || 
		       msg.indexOf("Was expecting one of:") == -1) {
	              writer.write(format(msg,0)+"\n");
                   } else {
                      writer.write(format(msg.substring(0, 500)+" ...... ",
				          0)+
                                   "\n");
	           }
               } else {
		   writer.write("BOBJ system error\n");
                   e.printStackTrace();
	       }
               writer.flush();

          } catch (Throwable e) {

        	writer.write("==========================================\n");
                String msg = e.getMessage();
	        if (msg != null &&
                    msg.endsWith("Encountered: <EOF> after : \"\"")) {
	            writer.write(msg+"\n");
	        } else if (msg != null && msg.length() > 0){
	            writer.write(format(msg,0)+".\n");
                } else if (e instanceof StackOverflowError) {
	           writer.write("stack overflow, there might have "+
			        "an infinite reduction.\n");
                } else {
                    writer.write("BOBJ system error\n");
                    //e.printStackTrace();
	        }
                writer.flush();

          }

          // copy environment from the new parser
          Enumeration enum_ = bobj.modPool.keys();
          while (enum_.hasMoreElements()) {
              ModuleName modName = (ModuleName)enum_.nextElement();
              module = (Module)bobj.modPool.get(modName);
              //modPool.put(modName, module);
	      saveModule(module);
          }

          enum_ = bobj.viewPool.keys();
	  while (enum_.hasMoreElements()) {
              String key = (String)enum_.nextElement();
              view = (View)bobj.viewPool.get(key);
              viewPool.put(key, view);
          }

          currentModule = bobj.currentModule;
          dynmaicModule = bobj.dynmaicModule;
          currentCobasis = bobj.currentCobasis;
          lastModule = bobj.lastModule;
          trace = bobj.trace;
          boolInclude = bobj.boolInclude;
          detail = bobj.detail;
	  currentTerm = bobj.currentTerm;
	  termStack = bobj.termStack;
	  time = bobj.time;
	  timeChecked = bobj.timeChecked;

	  pwd = bobj.pwd;

	  if (engine != null) {
              engine.cleanCache();
          }
	  cobasisUpdated = true;

	  client = this;

      }

   |
     LOOKAHEAD(("show" | "sh" ) "view" <IDENTIFIER> "." )
     ("show" | "sh" )
     "view"
     (token=<IDENTIFIER>)
     "."
	 {
               writer.write("==========================================\n");

               view = (View)viewPool.get(token.image);

	       if (view == null) {
		   writer.write("No view with the name "+
	                        token.image+" is found\n");
		   writer.flush();	
	       } else {
 	           writer.write("\n"+view+"\n");
                   writer.flush();	
	       }
	 }

   |
     LOOKAHEAD (("show" | "sh" )"time")
     ("show" | "sh" )"time"  [ "." ]
          {
              Date now = new Date();
              writer.write("==========================================\n");
	      if (timeChecked) {
	         writer.write("elapsed time since the last time check : "+
			      (now.getTime()-time.getTime())+"ms\n"); 
              } else {
                 writer.write("elapsed time from the beginning : "+
			      (now.getTime()-time.getTime())+"ms\n");
		 timeChecked = true;
	      }
	      writer.flush();
	  }
   |
      LOOKAHEAD (("show" | "sh" ) [<IDENTIFIER>] "rules"  )
      {
           boolean all = false;
      }
      ("show" | "sh" )
      [
           token=<IDENTIFIER>
              {
                   if (token.image.equals("all")) {
		       all = true;
                   }
	      }
      ]
      "rules" [ "." ]
         {

	      writer.write("==========================================\n");
	      if (dynmaicModule == null) {
                    if (currentModule == null) {
	                writer.write("Warning: no module can be shown\n");
                    } else {
			writer.write("rules in "+
				     currentModule.getModuleName()+":\n");
	                writer.write("\n"+currentModule.showRules(all)+"\n");
                    }
	       } else {
		    writer.write("rules in the current module:\n");
	            writer.write("\n"+dynmaicModule.showRules(all)+"\n");
	       }
               writer.flush();

	 }
   |
     LOOKAHEAD(("show" | "sh") "psort")
     (("show" | "sh") "psort") "."
         {
	      writer.write("==========================================\n");
	      if (dynmaicModule == null) {
                    if (currentModule == null) {
	                writer.write("Warning: no module is open\n");
                    } else {
			writer.write("principal sort in "+
				     currentModule.getModuleName()+": ");
	                writer.write(currentModule.toString(currentModule.getPrincipalSort())+
				     "\n");
                    }
	       } else {
		    writer.write("principal sort in "+
				 dynmaicModule.getModuleName()+": ");
	            writer.write(dynmaicModule.toString(dynmaicModule.getPrincipalSort())+
				 "\n");
	       }
               writer.flush();	     
	 }
   |
     LOOKAHEAD(("show" | "sh" )ModExpr(null))
     ("show" | "sh" )
     (module=ModExpr(null))
     "." 
          {
               writer.write("==========================================\n");
 	       writer.write("\n"+module+"\n");
               writer.flush();
          }
   |
     LOOKAHEAD( ( "show" | "sh" ) ".")
     ("show" | "sh" ) "."
          {

	       writer.write("==========================================\n");
               if (dynmaicModule == null) {
                    if (currentModule == null) {
	                writer.write("Warning: no module can be shown\n");
                    } else {
	                writer.write("\n"+currentModule+"\n");
                    }
	       } else {
	            writer.write("\n"+dynmaicModule+"\n");
	       }
               writer.flush();

	      
           }
   |
     ("obj" | "object")
           {
	       if (engine != null) {
                  engine.cleanCache();
               }

	       dynmaicModule = null;
	       paraPool = new Hashtable();
           } 
     (module=Module(Module.INITIAL)) 
     ("endo" | "end" | "jbo")
           {                
                if (mode == FILE_INPUT) {
                    writer.write("======================"+
                                 "====================\n");
                    writer.write("obj "+module.getModuleName()+"\n");
                }
         
                if (containsModule(module.getModuleName())) {
                    writer.write("Warning: redefining module "+
			         module.getModuleName()+"\n");
                }
                writer.flush();

                //modPool.put(module.getModuleName(), module);
                saveModule(module);
	        currentModule = module;
	        cobasisUpdated = true;
	        paraPool = new Hashtable();
           }
   |
     "dth"
           {
 	        if (engine != null) {
                    engine.cleanCache();
                }

	        dynmaicModule = null;
	        paraPool = new Hashtable();	
           } 
     (module=Module(Module.INITIAL)) 
     ( "end" )
           {

                if (mode == FILE_INPUT) {
                    writer.write("===================="+
                                 "======================\n");
                    writer.write("dth "+module.getModuleName()+"\n");
                }
         
                if (containsModule(module.getModuleName())) {
                    writer.write("Warning: redefining module "+
		                 module.getModuleName()+"\n");
        	}
                writer.flush();

                //modPool.put(module.getModuleName(), module);
                saveModule(module);
                currentModule = module;
	        cobasisUpdated = true;
	        paraPool = new Hashtable();
           }
   |
     ( "th" | "theory") 
           {
  	         if (engine != null) {
                    engine.cleanCache();
                 }

	         dynmaicModule = null;
	         paraPool = new Hashtable();
           }
      module=Module(Module.LOOSE) 
      ("endth" | "end" | "ht")
           {
                 if (mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
                     writer.write("th "+module.getModuleName()+"\n");
	             writer.flush();
                 }

                 if (containsModule(module.getModuleName())) {
                     writer.write("Warning: redefining module "+
                                  module.getModuleName()+"\n");
	             writer.flush();
                 }
                 writer.flush();

                 //modPool.put(module.getModuleName(), module);
                 saveModule(module);
                 currentModule = module;
		 cobasisUpdated = true;
	         paraPool = new Hashtable();
            }
   |
     "bth" 
            { 
  	         if (engine != null) {
                    engine.cleanCache();
                 }

	         dynmaicModule = null;
	         paraPool = new Hashtable();
            }
      module=Module(Module.BEHAVORIAL) 
      ( "endb" | "end")
            {
        
                 if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\n");
                     writer.write("bth "+module.getModuleName()+"\n");
	             writer.flush();
                 }

                 if (modPool.containsKey(module.getModuleName())) {
                      writer.write("Warning: redefining module "+
                                   module.getModuleName()+"\n");
	              writer.flush();
                 }

                 //modPool.put(module.getModuleName(), module);
                 saveModule(module);
                 currentModule = module;
	         cobasisUpdated = true;
	         paraPool = new Hashtable();
            }
   |
      LOOKAHEAD({ getToken(1).image.equals("cases") })
      <IDENTIFIER>                 // cases
      token=<IDENTIFIER>           // case name
      (
         (
         "for"
          module=ModExpr(null)
	     {
                 ModuleName modName = new ModuleName(token.image);
	         CaseModule cm = new CaseModule(modName, module);
	     }
         "is"
          (
	    ContextDecl(cm)
            |
            VarDecl(cm)
            |
            CaseDecl(cm)
          )+
          "end"
             {
	         if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\n");
                     writer.write("cases "+cm.getModuleName()+"\n");
	             writer.flush();
                 }

                 if (casesPool.containsKey(token.image)) {
                      writer.write("Warning: redefining module "+
                                   token.image+"\n");
	              writer.flush();
                 }

                 casesPool.put(token.image, cm);

	     }
          )
          |
          (
	     "is"
                  {
		     ArrayList cmlist = new ArrayList();
                     modName = new ModuleName(token.image);
		  }
             token=<IDENTIFIER>
	          {
                      CaseModule tmp = (CaseModule)casesPool.get(token.image);
		      if (tmp == null) {
	                  String msg = "no cases with the name "+
                                       token.image+" at "+
			               "line "+token.beginLine+", column "+
			               token.beginColumn;
	                  throw new ParseException(msg);
		      }
                      cmlist.add(tmp);
	          }
             (
               "*"
               token=<IDENTIFIER>
                  {
                      tmp = (CaseModule)casesPool.get(token.image);
		      if (tmp == null) {
	                  String msg = "no cases with the name "+
                                       token.image+" at "+
			               "line "+token.beginLine+", column "+
			               token.beginColumn;
	                  throw new ParseException(msg);
		      }
                      cmlist.add(tmp);
		  }
             )+
                  {
                      try {
	                  cm = new CaseModule(modName, cmlist);
                      } catch (CaseModuleException e) {
                          String msg =  e.getMessage()+" at line "+
			                token.beginLine+", column "+
			                token.beginColumn;
	                  throw new ParseException(msg);
		      }
                  }
             [
                 token=<IDENTIFIER>
                     {
                        if (!token.image.equals("exclude")) {
	                   String msg = "expect \"exclude\" at line "+
			                token.beginLine+", column "+
			                token.beginColumn;
	                   throw new ParseException(msg);
		        }

			Token btoken = token;

                     }
                  (
                     {
			String label = "";
	             }

                     "("
                     token=<INTEGER_LITERAL>
                         {
			    label += token.image;
		         }
                     (
                       ","
                       token=<INTEGER_LITERAL>
                          {
                             label += ","+token.image;
			  }
                     )+
                     ")"
                          {
			      // change case
			      try {
			         cm.remove(label);
                              } catch (Exception e) {
				 String msg = e.getMessage()+" at line "+
			                btoken.beginLine+", column "+
			                btoken.beginColumn;
	                         throw new ParseException(msg);
			      }
			  }
                  )+
             ]
             "end"
                {
	           if (mode == FILE_INPUT) {
                      writer.write("======================"+
                                  "====================\n");
                      writer.write("cases "+cm.getModuleName()+"\n");
	              writer.flush();
                   }

                   if (casesPool.containsKey(cm.getModuleName().toString())) {
                       writer.write("Warning: redefining module "+
                                    cm.getModuleName()+"\n");
	               writer.flush();
                   }

                   casesPool.put(cm.getModuleName().toString(), cm);
	         }
          )
      )
   |
      "view" 
	    {
	        dynmaicModule = null;
                token = getToken(0);
                paraPool = new Hashtable();
	    }
      (view=ViewDecl())
      ( "endv" | "end" | "weiv" | "endview" )
            {
                paraPool = new Hashtable();
                try {
                     view.validate();
                } catch (ViewException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+", column "+
		                  token.beginColumn;

	             if (detail) {
	                  msg = "format:"+format(msg, 0)+"\n"+
		                "the failed view is\n"+e.getView();
                     }

                     throw new ParseException(msg);
                }
                   
                writer.write("==========================================\n");
	       
	        if (viewPool.containsKey(view.getName())) {
		    writer.write("Warning: redefining view "+view.getName()+"\n");
                } else {
		    writer.write("view "+view.getName()+"\n");
                }

	        writer.flush();

                viewPool.put(view.getName(), view);
            }
   |
      "morph" 
	    {
	        dynmaicModule = null;
                token = getToken(0);
                paraPool = new Hashtable();
	    }
      (view=MorphismDecl())
      "end" 
            {
                paraPool = new Hashtable();
                try {
                     view.validate();
                } catch (ViewException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+", column "+
		                  token.beginColumn;

	             if (detail) {
	                  msg = "format:"+format(msg, 0)+"\n"+
		                "the failed view is\n"+e.getView();
                     }

                     throw new ParseException(msg);
                }
                   
                writer.write("==========================================\n");
	        //writer.write("morph "+view.getName()+"\n");

                if (viewPool.containsKey(view.getName())) {
                    writer.write("Warning: redefining morph "+view.getName()+"\n");
                } else {
                    writer.write("morph "+view.getName()+"\n");
                }

	        writer.flush();


                viewPool.put(view.getName(), view);
            }   
   |
       ("cobasis" | "cob")
            {
                Sort[] csorts;
                Operation cop;
	        Cobasis cob;
	    }
       token=<IDENTIFIER>
            {
		cob = new Cobasis(token.image);
	    }
       [
          "from" module=ModExpr(null)
	      {
	         cob.setModule(module);
	      }          
       ]
       "is"
           {
		if (module == null) {
		    writer.write("======================="+
			         "===================\n");
                    writer.write("No module is specified for "+
			         "cobasis declaration at line "+
				  token.beginLine+"\n");
		    writer.write("use the last module instead.\n");
	            if (lastModule != null) {
		        module = lastModule;
	            }
		}
	   }
       (
           csorts=CobSortsDecl(module)
	       {
	           for (int i=0; i<csorts.length; i++) {
	           	try { 
		       	   cob.add(csorts[i]);
	                } catch (CobasisException ex) {
		           Token xt = getToken(0);
                           String msg = ex.getMessage()+" at line "+
                                    xt.beginLine+", column "+xt.endColumn+".";
                           throw new ParseException(msg);
	                }
	            }
	        }
           |
	   cop=CobOpDecl(module)
	  	{
	     	    try {
	       		 cob.add(cop);
	    	    } catch (CobasisException ex) {
		       	Token xt = getToken(0);
                        String msg = ex.getMessage()+" at line "+
                                     xt.beginLine+", column "+xt.endColumn+".";
                        throw new ParseException(msg);
	             }
	         }
       )+
       "end"
           {
	      cobasisPool.put(token.image, cob);
       	   }
   |

     "make"
        {
	       if (engine != null) {
                  engine.cleanCache();
               }

	       dynmaicModule = null;
	       paraPool = new Hashtable();
      	}

     (token=<IDENTIFIER>)
     "is"
     (module=ModExpr(null))
     ( "endm" | "end")

        {
	      if (mode == FILE_INPUT) {
                  writer.write("==========================================\n");
                  writer.write("make "+token.image+"\n");
                  writer.flush();
              }

	      ModuleName mn = new ModuleName(token.image);
	      Module result = new Module(module.getType(), mn);
	      try {
	          result.importModule(module);
                  result.protectImportList.addAll(module.protectImportList);
                  result.extendImportList.addAll(module.extendImportList);
                  result.useImportList.addAll(module.useImportList); 

		  result.paraNames = (ArrayList)module.paraNames.clone();
		  result.paraModules = (ArrayList)module.paraModules.clone();
		  if (module.bindings != null) {
		      result.bindings = (Hashtable)module.bindings.clone();
		  }
		  result.levels = module.levels;

    	      } catch (SignatureException e) {}

              //modPool.put(mn, module);
	      
	      saveModule(result);
              currentModule = result;

              cobasisUpdated = true;
              dynmaicModule = null;
         }
      
   |

     LOOKAHEAD( "open" ModExpr() )
     "open" 
          {
               RewriteEngine.cleanCache();   
          }
     (module=ModExpr(null))  
     "."
          {
             
	      if (mode == FILE_INPUT) {
	          writer.write("==========================================\n");
	      }

	      if (dynmaicModule != null) {


		  if (mode != FILE_INPUT) {
	               writer.write("====================="+
	                	    "=====================\n");
	          }

		  if (dynmaicModule.modName.equals(module.modName)) {
		       
                       dynmaicModule = (Module)module.clone();
		       writer.write("Warning: module "+module.modName+
				    " is closed\n");
                       writer.write("reopen "+module.getModuleName()+"\n");
	               writer.flush();

		  } else {
		       writer.write("Warning: module "+
				    dynmaicModule.modName+" is closed\n");

                       dynmaicModule = (Module)module.clone();
                       writer.write("open "+module.getModuleName()+"\n");
	               writer.flush();
	          }

	      } else {

                  dynmaicModule = (Module)module.clone();
              
                  if (mode == FILE_INPUT) {
                      writer.write("open "+module.getModuleName()+"\n");
	              writer.flush();
                  }
              }
          }
   |
     LOOKAHEAD( "openr" ModExpr() )
     "openr" 
          {
	      if (engine != null) {
                  engine.cleanCache();
	      }
          }
     (module=ModExpr(null))  
     "."
          {
              dynmaicModule = module;
	      dynmaicModule.setProperty("save", "");

	      if (mode == FILE_INPUT) {
	          writer.write("==========================================\n");
	          writer.write("openr "+module.getModuleName()+"\n");
	          writer.flush();
              }

          }
   |
     LOOKAHEAD("use")
         {
	    CaseModule cm;
         }
      cm=CaseExp()
         {
	     if (dynmaicModule == null) {
	        writer.write("==========================================\n");
	        writer.write("Warning: use command only can"+
			     " be used in an open command\n");
                writer.write("use command at line "+getToken(0).beginLine+
			     " is ignored\n");		
	        writer.flush();
	     } else {
                localCase = cm;
	     }
	 }
   |
     LOOKAHEAD( "select" ModExpr() )
     token="select" 
          {
	      if (engine != null) {
                  engine.cleanCache();
	      }
              cobasisUpdated = true;
              
          }
     (module=ModExpr(null))  
     "."
          {

               if (mode == FILE_INPUT) {
	             writer.write("====================="+
                                  "=====================\n");
	       }
 
               if (dynmaicModule != null) {


		   if (mode != FILE_INPUT) {
	                writer.write("====================="+
			             "=====================\n");
	           }

		   if (dynmaicModule.modName.equals(module.modName)) {
			writer.write("Warning: select open module "+
			             module.modName+" at "+
			             "line "+token.beginLine+"\n"); 
		        writer.write("select command is ignored\n");
		        writer.flush();
	           }  else {
			writer.write("Warning: select module "+module.modName+
				     " when module "+dynmaicModule.modName+
				     " is open at line "+
				      token.beginLine+"\n");
		        writer.write("module "+dynmaicModule.modName+
				     " is closed\n"); 
			dynmaicModule = null;
          	        currentModule = module;
	                writer.write("select "+module.getModuleName()+"\n");
	                writer.flush();
	           }
	       } else {
	           currentModule = module;

		   if (mode == FILE_INPUT) {
	               writer.write("select "+module.getModuleName()+"\n");
	               writer.flush();
	           }
               }
          }
   |
     LOOKAHEAD(5)
     "open" "."
          {
	       if (engine != null) {
                   engine.cleanCache();
               }
         
               if (currentModule == null) {
	            writer.write("Error: no last module\n");
	            writer.flush();
	       } else {	  
	            dynmaicModule = (Module)currentModule.clone();
               }

               if (mode == FILE_INPUT) { 
	            writer.write("======================="+
                                 "===================\n");
	            writer.write("open\n");
	            writer.flush();
               }
	  }
   |
     LOOKAHEAD(5)
     "openr" "."
          {
	       if (engine != null) {
                   engine.cleanCache();
               }
         
               if (currentModule == null) {
	            writer.write("Error: no last module\n");
	            writer.flush();
	       } else {	  
	            dynmaicModule = currentModule;
	            dynmaicModule.setProperty("save", "");
               }

               if (mode == FILE_INPUT) { 
	            writer.write("======================="+
                                 "===================\n");
	            writer.write("openr\n");
	            writer.flush();
               }
	  }

   |
     "close"
          {
               if (dynmaicModule != null) {

		    dynmaicModule.umaskAll();

		    if (dynmaicModule.getProperty("save") != null &&
			dynmaicModule.modName.op == ModuleName.ATOM) {
		        
                        saveModule(dynmaicModule);
                        dynmaicModule.removeProperty("save");
			currentModule = dynmaicModule; 
			
                    }

                    dynmaicModule = null;
                    localCase = null;

                    if (mode == FILE_INPUT) {
  	                 writer.write("======================="+
                                      "===================\n");
	                 writer.write("close\n");
	                 writer.flush();
	            }

                } else {
	            writer.write("Warning: all modules are closed\n");
	            writer.flush();
	        }

	        cobasisUpdated = true;

            }

   | 
     "parse"
            {

	        if (dynmaicModule != null) {
	             module = dynmaicModule;
	        } else {
	             module = currentModule;
	        }

                if (module == null) {
	            writer.write("Warning: no module input yet,"+
                                 " use BOOL instead\n");
	            writer.flush();
	            module = ModuleFactory.createBool();
	        }

                String string;

	    }
     string=Term(module)
     "."
            {

                 if (mode == FILE_INPUT) {
	             writer.write("======================"+
                                  "====================\n");
	             writer.write("parse: "+format(string, 13)+"\n");
                 }

                 try {

                     long beginTime = new Date().getTime();	
                     Term term = Term.parse(module, string);
                     long parseTime = new Date().getTime() - beginTime;

                     writer.write("time: "+parseTime+"ms\n");
                     writer.write("result:\n");
                     writer.write(term.showStructure(module)+"\n");
	             writer.flush();


                 } catch (TermException e) {
		     token = getToken(0);
                     writer.write("====================="+
				  "=====================\n");
		     if (e.getCount() > 0) {
	                 writer.write(e.getMessage()+"\nat line "+
				      token.beginLine+".\n");
	             } else {
                         writer.write(e.getMessage()+"at line "+
				      token.beginLine+".\n");
	             }	
	             writer.flush();
                 }             
	    }
   |
      LOOKAHEAD({ getToken(1).image.equals("restore") } )
      <IDENTIFIER> "."
           {
              currentModule = null; 
              dynmaicModule = null;
              currentCobasis = null;
              currentTerm = null;             
              termStack = new Stack();
              modPool = new Hashtable(); 
              lastModule = null; 
              viewPool = new Hashtable(); 
              paraPool = null;
              cobasisPool = new Hashtable();
              casesPool = new Hashtable();
              cobasisUpdated = false;
              trace = false;
              boolInclude = true;
	      detail = false;
	   }
   |  
      LOOKAHEAD({ getToken(1).image.equals("mask") } )
      <IDENTIFIER>
      ( LOOKAHEAD(10)
        token=<IDENTIFIER>
	    {

		String eqName = token.image;

		if (eqName.startsWith(".")) {
		   eqName = eqName.substring(1);

		   if (dynmaicModule == null) {
		       String msg= "no module is open when mask "+
				   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       throw new ParseException(msg);
	           }

	           Equation eq = dynmaicModule.getEquation(eqName);
		   if (eq == null) {
		       try {
			   int pos = Integer.parseInt(eqName);
                           eq = dynmaicModule.getRule(pos);
                       } catch (Exception e){
                       }

		       if (eq == null) {
                           String msg= "no equation with name "+eqName+
                                " at line "+token.beginLine+
                                ", column "+token.endColumn+".";
                           throw new ParseException(msg);
		        }
		   }

		   dynmaicModule.mask(eq);

	        } else if (eqName.equals("all")) {

		   if (dynmaicModule == null) {
		       String msg= "no module is open when mask "+
				   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       throw new ParseException(msg);
	           }

		   dynmaicModule.maskAll();
                } else {
		   throw new ParseException("expect an identifier starting "+
					    "with \".\" at line "+
					    token.beginLine+" column "+
					    token.beginColumn);
	        }
	    }
      )+
      "."
   |  
      LOOKAHEAD({ getToken(1).image.equals("umask") } )
      <IDENTIFIER>
      ( LOOKAHEAD(10)
        token=<IDENTIFIER>
	    {

		String eqName = token.image;

		if (eqName.startsWith(".")) {
		   eqName = eqName.substring(1);

		   if (dynmaicModule == null) {
		       String msg= "no module is open when mask "+
				   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       throw new ParseException(msg);
	           }

	           Equation eq = dynmaicModule.getEquation(eqName);
		   if (eq == null) {
		       try {
			   int pos = Integer.parseInt(eqName);
                           eq = dynmaicModule.getRule(pos);
                       } catch (Exception e){
                       }

		       if (eq == null) {
                           String msg= "no equation with name "+eqName+
                                " at line "+token.beginLine+
                                ", column "+token.endColumn+".";
                           throw new ParseException(msg);
		        }
		   }

		   dynmaicModule.umask(eq);

	        } else if (eqName.equals("all")) {

		   if (dynmaicModule == null) {
		       String msg= "no module is open when mask "+
				   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       throw new ParseException(msg);
	           }

		   dynmaicModule.umaskAll();
                } else {
		   throw new ParseException("expect an identifier starting "+
					    "with \".\" at line "+
					    token.beginLine+" column "+
					    token.beginColumn);
	        }
	    }
      )+
      "."
   |
       LOOKAHEAD({ getToken(1).image.equals("do")  &&
		    getToken(2).image.equals("restore")  &&
                    getToken(3).image.equals("init") 
                  })
        <IDENTIFIER>  <IDENTIFIER> <IDENTIFIER> "."
           {
              currentModule = null; 
              dynmaicModule = null;
              currentCobasis = null;
              currentTerm = null;             
              termStack = new Stack();
              modPool = new Hashtable(); 
              lastModule = null; 
              viewPool = new Hashtable(); 
              paraPool = null;
              cobasisPool = new Hashtable();
              casesPool = new Hashtable();
              cobasisUpdated = false;
              trace = false;
              boolInclude = true;
	      detail = false;
	   }
   |
      LOOKAHEAD({ getToken(1).image.equals("call-that") })
      <IDENTIFIER> 
       (
           token=<IDENTIFIER>
           |
	   token=<INTEGER_LITERAL>
           |
	   token=MetaToken()
       )
       "."
           {
		if (currentTerm != null) {

		   if (dynmaicModule != null) {
		      try {
		         Operation op = new Operation(token.image, 
						      currentTerm.sort);       
	                 Equation eq = new Equation(new Term(op, new Term[]{}),
						    currentTerm);
			 dynmaicModule.addOperation(op);
			 dynmaicModule.addEquation(eq);
                      } catch (Exception e) {
		         String msg = e.getMessage()+
				      " at line "+token.beginLine+", column "+
				      token.beginColumn;
		         throw new ParseException(msg);	
	              }
		   } else {
		      String msg = "no module is open for \"call-that\""+
				   " at line "+
		                   token.beginLine+", column "+
				   token.beginColumn;
		      throw new ParseException(msg);	
		   }
	        } else {
		   String msg = "no term is define for \"call-that\" at line "+
		                token.beginLine+", column "+
				token.beginColumn;
		   throw new ParseException(msg);
	        }
	   }
   |
     ("red" | "reduce")
           {
	       module = null;
	       if (engine != null) {
                   engine.cleanCache();
               }

	   }
     [
       LOOKAHEAD( "in" [ <IDENTIFIER> "is" ] ModExpr() ":" )
       "in"
           {
	      Token modToken = null;
	   }
       [ LOOKAHEAD(<IDENTIFIER> "is") modToken=<IDENTIFIER> "is" ]
       module=ModExpr(null)
           {

	       if (modToken != null) {
		   ModuleName modName = new ModuleName(modToken.image);
		   Module tmpMod = (Module)module.clone();
                   tmpMod.modName = modName;

	           saveModule(tmpMod);
	       }

	       if (engine != null) {
                   engine.cleanCache();
               }

	       dynmaicModule = module;
	   }
       ":"
     ]
    
            {
		 if (module == null) {
	      	      module = (dynmaicModule != null) ?
                               dynmaicModule : currentModule;
	         }

                 if (module == null) {
	             writer.write("Warning: no module input yet, "+
			          "use BOOL instead\n");
	             writer.flush();
	             module = ModuleFactory.createBool();
	         }

	     }
     string=Term(module)
     "."
        {

             try {

                 long beginTime = new Date().getTime();
                 Term term = Term.parse(module, string);

                 //term = module.setPerference(term);
	         //System.out.println(term.showStructure());

		 currentTerm = term;
                 long parseTime = new Date().getTime() - beginTime;

                 writer.write("==========================================\n");
	         String modName = module.getModuleName().toString();
                 writer.write("reduce in "+modName+" : "+
			      format(term.toString(), 9+modName.length())+
			      "\n");
                 writer.flush();

                 beginTime = new Date().getTime();
                 try {
		      engine = new RewriteEngine(module);
		      RewriteEngine.nontermination = false;
                      term = engine.reduce(term);
                 } catch (OutOfMemoryError error) {
                      Token xt = getToken(0);
	              writer.write("error: out of memory at line "+
                                   xt.beginLine+".\n");
                      writer.flush();
                      return;
                 }

	         String sortName = term.getSort().getName();

	         int index = sortName.indexOf(".");
	         if (index != -1) {
	             sortName = sortName.substring(0, index);
	         }

                 writer.write("result "+sortName+": "+
		              format(term.toFullString(),
                                     9+term.getSort().getName().length())+
                              "\n");
	      
                 writer.write("rewrite time: "+
                               (new Date().getTime() - beginTime)+"ms");
                 writer.write("       parse time: "+parseTime+"ms\n");
		
		 if (engine.nontermination) {
                     writer.write("Warning: non-termination corrected\n");
		     engine.nontermination = false;
	         }

                 writer.flush();

             } catch (TermException e) {
		  token = getToken(0);
                  writer.write("==========================================\n");
		  if (e.getCount() > 0) {
	              writer.write(e.getMessage()+"\nat line "+token.beginLine+
                                   ".\n");
	          } else {
                      writer.write(e.getMessage()+"at line "+token.beginLine+
                                   ".\n");
	          }	
	          writer.flush();

             } 
        }
   |
     "cred"
        {
	   CaseModule cm = null;
	}
     [
       LOOKAHEAD("with")
       "with"  
        token=<IDENTIFIER>
            {
	   	cm = (CaseModule)casesPool.get(token.image);
                if (cm == null) {
	            String msg = "no cases with the name "+token.image+" at "+
			         "line "+token.beginLine+", column "+
			         token.beginColumn;
		    throw new ParseException(msg);
                }

		ArrayList cmlist = new ArrayList();
                cmlist.add(cm);
	    }
        (
	   LOOKAHEAD({ getToken(1).image.equals("*") &&
                       casesPool.get(getToken(2).image) != null
                     })
           "*" token=<IDENTIFIER>
               {
                   cm = (CaseModule)casesPool.get(token.image);
                   cmlist.add(cm);
	       }
        )*
            {

               try {
		   if (cmlist.size() > 1) {
		       String name = "";
	               for (int i=0; i<cmlist.size(); i++) {
			  CaseModule c = (CaseModule)cmlist.get(i);
			  if (i == 0) {
			     name += c.name;
                          } else {
                             name += " * "+c.name;
			  }
		       }
		       ModuleName modName = new ModuleName(name);
	               cm = new CaseModule(modName, cmlist);
                   } else {
                       cm = (CaseModule)cmlist.get(0);
	           }
               } catch (CaseModuleException e) {
                   String msg =  e.getMessage()+" at line "+
			         token.beginLine+", column "+
			         token.beginColumn;
	           throw new ParseException(msg);
	       }
	    }
        [
	    LOOKAHEAD({ getToken(1).image.equals("exclude") })
            <IDENTIFIER>
                  {
                        String sum = "exclude";
	          }
              ( LOOKAHEAD(2)
                    {
		        String label = "";
	            }
              "("
              token=<INTEGER_LITERAL>
                    {
	                label += token.image;
	            }
               (
               ","
               token=<INTEGER_LITERAL>
                     {
                         label += ","+token.image;
                     }
               )+
               ")"
                     {
		         // change case
	                 try {
			      cm.remove(label);
                              sum += " ("+label+")";
                         } catch (Exception e) {
	                      String msg = e.getMessage()+" at line "+
			                   token.beginLine+", column "+
			                   token.beginColumn;
	                      throw new ParseException(msg);
	                 }
		     }
             )+
                 {
		     cm.name = new ModuleName(cm.name.toString()+" "+sum);
	         }
        ]
     ]
        {
	     module = (dynmaicModule != null) ?
                          dynmaicModule : currentModule;
	      
             if (module == null) {
	         writer.write("Warning: no module input yet, "+
			      "use BOOL instead\n");
	         writer.flush();
	         module = ModuleFactory.createBool();
	     }

	     String tmp;
	}
     tmp=Term(module)
     "."
        {

	   // try to get multiple goals
	   String target = tmp.trim();

	   ArrayList goals = new ArrayList();
           int pCount = 0;   // the number of "("
           String goal = "";
	   boolean valid = true;

           while (target.length() > 0) {

	      if (target.startsWith("(")) {

		 if (pCount > 0) {
	           goal += target.substring(0, 1);
	         }
                 target = target.substring(1);
                 pCount++;
	      } else if (target.startsWith(")")) {

	         if (pCount < 1) {
	             valid = false;
                     break;

		 } else if (pCount == 1) {

		     // find a goal
		     goals.add(goal);
		     goal = "";
		     target = target.substring(1).trim();
		     pCount = 0;

	         } else if (pCount > 1) {
		    pCount--;
                    goal += target.substring(0, 1);
		    target = target.substring(1);
	         }

	      } else if (pCount > 0) {
                 goal += target.substring(0, 1);
		 target = target.substring(1);
              } else {
		 valid = false;
		 break;
	      }
           }

	   if (valid && goal.length() == 0 && goals.size() > 1) {

	       // parse goals
	       Term[] terms = new Term[goals.size()];
               Term[] cterm = new Term[goals.size()];
               Term[] lefts =  new Term[goals.size()];
	       Term[] rights =  new Term[goals.size()];
	       ArrayList hsorts = new ArrayList();
	
               long b1 = new Date().getTime();

	       for (int i=0; i<terms.length; i++) {
	          tmp = (String)goals.get(i);

		  try {
	              String cond = null;
                      int index = tmp.indexOf(" if ");
	              if (index != -1) {
		          cond = tmp.substring(index+4).trim();

		          if (cond.indexOf(" then ") != -1 &&
                              cond.indexOf(" else ") != -1) {
		             cond = null;
                          } else {
		             int count = 0;
		             for (int j=0; j<cond.length(); j++) {
		                char c = cond.charAt(j);
		                if (c == '(') {
			           count++;
		                } else if (c == ')') {
			           count--;
		                }
		                if (count < 0) {
			           break;
		                }
	                     }

		            if (count != 0) {
		               cond = null;
		            }
                         }
	              }

                      if (cond == null) {
                         terms[i] = Term.parse(module, tmp);
                      } else {
                         terms[i] =
                            Term.parse(module, tmp.substring(0, index));
                         cterm[i] = Term.parse(module, cond);

		         if (!cterm[i].getSort().equals(BoolModule.boolSort)) {
                             throw new TermException("expect a boolean term: "+
					             cond);
		         }

	              }

	              Operation op = terms[i].getTopOperation();
	              if (op.getName().equals("_ == _") &&
		          op.getInfo().equals("system-default")) {

		          lefts[i] = terms[i].getSubterms()[0];
	                  rights[i] = terms[i].getSubterms()[1];

	                  Sort lsort = lefts[i].getSort();
			  if (lsort.isHidden()) {
			      HiddenSort hsort = (HiddenSort)lsort;
		              boolean found = false;
			      for (int j=0; j<hsorts.size(); j++) {
			        HiddenSort htmp = (HiddenSort)hsorts.get(j);
			        found = htmp.equals(hsort);
				if (found) break;
                              }

		              if (!found) hsorts.add(hsort);
                          }
			
                      } else {
		          throw new TermException("cred can't be used to \""+
					   ((String)goals.get(i)).trim()+"\"");
		      }

                  }  catch (TermException e) {

                      writer.write("======================"+
                                   "====================\n");
	              writer.write(e.getMessage()+"\n");
                      writer.write("at line "+getToken(0).beginLine+"\n");
	              writer.flush();
	
		      return;
                  } 

	       }
               b1 = new Date().getTime() - b1;

	       // display message

               String modName = module.getModuleName().toString();
               writer.write("==========================================\n");
               writer.write("c-reduce in "+modName+" : \n");


	       for (int i=0; i<terms.length; i++) {
		  String deco = "";
	          if (cterm[i] != null) deco = " if "+cterm[i].toString();
	          writer.write("   "+format(terms[i].toString()+deco, 0)+"\n");
               }

               if (cm != null) {
                   writer.write("use: "+cm.name+"\n");
               }
               writer.flush();

	       if (cm == null && localCase != null) {
		   cm = localCase;
	       }

               if (currentCobasis != null) {

                    Vector cops = new Vector();
                    if (currentCobasis.validFor(module, cops)) {

		         Operation[] ops = new Operation[cops.size()];
		         cops.copyInto(ops);

                         if (ops != null && ops.length > 0) {

			      if (currentCobasis.getName().length() > 0) {
	                          writer.write("using cobasis "+
		        		       currentCobasis.getName()+
				               " for "+modName+"\n");
                              } else {
	                          writer.write("using cobasis of "+
                                               currentCobasis.module.modName+
                                               ":\n");
                                  for (int i=0; i<ops.length; i++) {
	                              writer.write("   "+
                                                   module.toString(ops[i])+
                                                   "\n");
	                          }  
	                          writer.write("   -------------------"+
                                               "--------------------\n");
			      }

                              long b = new Date().getTime();

		              module.setWriter(writer);

			      
			      boolean res = false;
                              try {
                                  res = module.behavioralMultipleReduce(lefts,
                                                                        rights,
                                                                        cterm,
                                                                        trace,
                                                                        cm);
                              }  catch (BReduceException e) {
	                          writer.write("timeout: BOBJ could not "+
			                       "determine the result\n");
	                          writer.flush();
	                      } catch (OutOfMemoryError e) {
                                  Token xt = getToken(0);
	                          writer.write("error: out of memory at line "+
                                               xt.beginLine+".\n");
                                  writer.flush();
                              }

                              if (res) {
                                  writer.write("result: true\n");
	                      } else {
                                  writer.write("result: false\n");
                              }
                              writer.write("c-rewrite time: "+
                                               (new Date().getTime() - b)+"ms");
                              writer.write("     parse time: "+b1+"ms\n");
	                      writer.flush();
		              return;
		          }
                      } else {
		          writer.write("Warning: cobasis "+
				       currentCobasis.getName()+
				       " couldn't be applied\n");
		      }
                 
	       }

               if (cobasisUpdated) {

	          boolean init = false;
		  for (int k=0; k<hsorts.size(); k++) {
		      HiddenSort hsort = (HiddenSort)hsorts.get(k);
                      Operation[] ops = module.getCobasisFor(hsort);
                      if (ops != null && ops.length > 0) {

			  if (!init) {
	                     writer.write("using cobasis for "+
                                           module.getModuleName()+":\n");
                             init = true;
                          }
                          for (int i=0; i<ops.length; i++) {
	                     writer.write("   "+module.toString(ops[i])+"\n");
	                  }  
                      }

                  }

                  writer.write("   ---------------------------------------\n");
		  cobasisUpdated = false;
               } 

               long b = new Date().getTime();

	       try {
	           module.setWriter(writer);
                   if (module.behavioralMultipleReduce(lefts, rights, cterm,
					           trace, cm)) {
                       writer.write("result: true\n");
	           } else {
                       writer.write("result: false\n");
                   }

                   writer.write("c-rewrite time: "+
                                (new Date().getTime() - b)+"ms");
                   writer.write("     parse time: "+b1+"ms\n");
	           writer.flush();

	           return;
	       } catch (BReduceException e) {
	           writer.write("timeout: BOBJ could not "+
			        "determine the result\n");
	           writer.flush();
	       } catch (OutOfMemoryError e) {
                  Token xt = getToken(0);
	          writer.write("error: out of memory at line "+
                               xt.beginLine+".\n");
                  writer.flush();
               }

	   }

           // end handling multiple goals
           try {

	       String cond = null;
               int index = tmp.indexOf(" if ");
	       if (index != -1) {
		  cond = tmp.substring(index+4).trim();

		  if (cond.indexOf(" then ") != -1 &&
                      cond.indexOf(" else ") != -1) {
		     cond = null;
                  } else {
		     int count = 0;
		     for (int i=0; i<cond.length(); i++) {
		        char c = cond.charAt(i);
		        if (c == '(') {
			   count++;
		        } else if (c == ')') {
			   count--;
		        }
		        if (count < 0) {
			   break;
		        }
	             }

		     if (count != 0) {
		        cond = null;
		     }
                  }
	       }


               long b1 = new Date().getTime();

	       Term term, cterm=null;

               if (cond == null) {
                   term = Term.parse(module, tmp);
               } else {
                   term = Term.parse(module, tmp.substring(0, index));
                   cterm = Term.parse(module, cond);
	       }
               b1 = new Date().getTime() - b1;

               if (term == null) {
	           writer.write("No parse for "+tmp+"\n");
	           writer.flush();
                   return;
               }

	       Operation op = term.getTopOperation();
	       if (op.getName().equals("_ == _") &&
		   op.getInfo().equals("system-default")) {

               Term left = term.getSubterms()[0];
	       Term right = term.getSubterms()[1];

	       String deco = "";
	       if (cterm != null) deco = " if "+cterm.toString();

	       String modName = module.getModuleName().toString();
               writer.write("==========================================\n");
               writer.write("c-reduce in "+modName+" : "+
			    format(term.toString()+deco,
				   15+modName.length())+"\n");
               if (cm != null) {
                   writer.write("use: "+cm.name+"\n");
               }
               writer.flush();

	       if (cm == null && localCase != null) {
		   cm = localCase;
	       }

               //if currentCobasis != null, check whether it can be applied
               //to the current module, it not,the cobasis should be recalcute

               if (currentCobasis != null) {
                    Vector cops = new Vector();
                    if (currentCobasis.validFor(module, cops)) {

		         Operation[] ops = new Operation[cops.size()];
		         cops.copyInto(ops);

                         if (ops != null && ops.length > 0) {

			      if (currentCobasis.getName().length() > 0) {
	                          writer.write("using cobasis "+
		        		       currentCobasis.getName()+
				               " for "+modName+"\n");
                              } else {
	                          writer.write("using cobasis of "+
                                               currentCobasis.module.modName+
                                               ":\n");
                                  for (int i=0; i<ops.length; i++) {
	                              writer.write("   "+
                                                   module.toString(ops[i])+
                                                   "\n");
	                          }  
	                          writer.write("   -------------------"+
                                               "--------------------\n");
			      }

                              long b = new Date().getTime();
		              module.setWriter(writer);

                              if (module.behavioralReduce(left,
                                                          right,
                                                          cterm,
                                                          ops,
                                                          trace,
						          cm)) {
                                  writer.write("result: true\n");
	                      } else {
                                  writer.write("result: false\n");
                              }
                              writer.write("c-rewrite time: "+
                                           (new Date().getTime() - b)+"ms");
                              writer.write("     parse time: "+b1+"ms\n");
	                      writer.flush();
		              return;
		          }
                      } else {
		          writer.write("Warning: cobasis "+
				       currentCobasis.getName()+
				       " couldn't be applied\n");
		      }
                  }


	          if (cobasisUpdated &&
                      left.getSort().isHidden()){

                       Operation[] ops = module.getCobasisFor(left.getSort());

                       if (ops != null && ops.length > 0) {

	                    writer.write("using cobasis for "+
                                          module.getModuleName()+":\n");
                            for (int i=0; i<ops.length; i++) {
	                         writer.write("   "+module.toString(ops[i])+
                                              "\n");
	                    }  
	                    writer.write("   -------------------"+
                                         "--------------------\n");
                       }
	               cobasisUpdated = false;

                  } 

                  long b = new Date().getTime();
	          module.setWriter(writer);
                  if (module.behavioralReduce(left, right, cterm, trace, cm)) {
                       writer.write("result: true\n");
	          } else {
                       writer.write("result: false\n");
                  }
                  writer.write("c-rewrite time: "+
                               (new Date().getTime() - b)+"ms");
                  writer.write("     parse time: "+b1+"ms\n");
	          writer.flush();
	     } else {
	          throw new ParseException("no behavioral rewrite "+
					   "can be done");
	     }
           
         } catch (TermException e) {

             writer.write("==========================================\n");
	     writer.write(e.getMessage()+"\n");
             writer.write("at line "+getToken(0).beginLine+"\n");
	     writer.flush();

         } catch (BReduceException e) {
	     writer.write("timeout: BOBJ could not determine the result\n");
	     writer.flush();
	 } catch (OutOfMemoryError e) {
             Token xt = getToken(0);
	     writer.write("error: out of memory at line "+
                          xt.beginLine+".\n");
             writer.flush();
         }
      }

   |
      {
	 if (dynmaicModule == null)

	     if (currentModule != null) {
                 if (mode == FILE_INPUT) {
                      writer.write("======================="+
                                   "===================\n");
                 }
                 Token xt = getToken(0);
	         writer.write("opening module "+
                              currentModule.getModuleName()+".\n");
	         writer.flush();
	         dynmaicModule = (Module)currentModule.clone();

	     } else {
                 throw new ParseException("No module is open ");
	     }
       }
       DynamicDecl(dynmaicModule)
             {
	         cobasisUpdated = true;
             }
  |
      LOOKAHEAD(10)
      ("show" | "sh" )( "case" )
      token=<IDENTIFIER>    
      "."
            {
	   	cm = (CaseModule)casesPool.get(token.image);
                
	        if (mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
                     writer.flush();
                }

                if (cm == null) {
	            String msg = "no cases with the name "+token.image+" at "+
			         "line "+token.beginLine+", column "+
			         token.beginColumn;
		    throw new ParseException(msg);
                }

	        writer.write("\n"+cm+"\n");
	        writer.flush();

            }
  |
      LOOKAHEAD(10)
      ("show" | "sh" )( "cob" | "cobasis" )
            {
	         token = null;
	    }
      [ token = <IDENTIFIER> ]
      "."
            {

	      	 module = (dynmaicModule != null) ?
                              dynmaicModule : currentModule;

                 if (module == null) {
                     if (mode == FILE_INPUT) 
                         writer.write("====================="+
                                      "=====================\n");
                     writer.write("no input module");
	             writer.flush();
                     return;
                 }

                 Operation[] cobasis = null;
	         Sort sort = null;

                 if (token != null) {
                     Sort[] sorts = module.getHiddenSortsByName(token.image);
                     if (sorts.length == 1) {

                         sort = sorts[0];
		         cobasis = module.getCobasisFor(sort);

	             } else if (sorts.length == 0) {

                         String msg= "No hidden sort "+token.image+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         throw new ParseException(msg);

	             } else {

	                 token = getToken(0);
                         String msg= "Multiple hidden "+sort+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         throw new ParseException(msg);

	             }

	         } else {

	             sort = module.getPrincipalSort();
	             if (sort.isHidden()) {

	                 cobasis = module.getCobasisFor(sort);

	             } else {
	                 token = getToken(0);
                         String msg= "No hidden "+sort+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         throw new ParseException(msg);	
	             }
                 }

	         if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\n");
	         }
	         writer.write("The cobasis for "+module.toString(sort)+
			      " is: \n");
                 String msg = "";

                 for (int i=0; i<cobasis.length; i++) {
	             msg += "   "+module.toString(cobasis[i])+"\n";
                 }
	         writer.write(msg);
	         writer.flush();

            }

    |
      
      "set"
       (
        "trace"
            (
            "on"
                 {
		     RewriteEngine.setTrace(true);
	             trace = true;
	         }
            |
            "off"
                 {
                     if (engine != null) {
		         engine.setTrace(false);
	             }	             
	         }
            )
   
       |
         "cred" "trace"
            (
             "on"
                {
	             trace = true;
                }                 
             |
	     "off"
                {
	             trace = false;
                }
            )
       |
          ("cobasis" | "cob")
          [   
	      LOOKAHEAD(30) 
              (
              token=<IDENTIFIER>
                  {
                      cobasisUpdated = true;
	              currentCobasis = (Cobasis)cobasisPool.get(token.image);
                      if (currentCobasis == null) {
	                   if (mode == FILE_INPUT) {
	                       writer.write("====================="+
				            "=====================\n");
		           }
		           writer.write("Warning: cobasis "+
				        token.image+" not found\n");
		           writer.flush();

                      } else {
	                   if (mode == FILE_INPUT) {
	                       writer.write("====================="+
				            "=====================\n");
		               writer.write("set cobasis "+token.image+"\n");
		               writer.flush();
		           }
	              }
                 }

           |
	    "of"
                 {
		     Module md;
                 }
	    md=ModExpr(null)
                 {
		      cobasisUpdated = true;
	              Operation[] ops  = md.getCobasis();

		      cob = new Cobasis("");
		      cob.setModule(currentModule);

		      try {
		          cob.add(currentModule.getPrincipalSort());
		          for (int i=0; i<ops.length; i++) {
		             cob.add(ops[i]);
	                  }
                      } catch (Exception e) {
			 token = getToken(0);
			 String msg= e.getMessage()+" at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                         throw new ParseException(msg);	
		      }

		      currentCobasis = cob;

                      if (currentCobasis == null) {
	                   if (mode == FILE_INPUT) {
	                       writer.write("====================="+
				            "=====================\n");
		           }
		           writer.write("Warning: cobasis of "+
				        md.modName+" not found\n");
		           writer.flush();

                      } else {
	                   if (mode == FILE_INPUT) {
	                       writer.write("====================="+
				            "=====================\n");
		               writer.write("set cobasis of "+md.modName+"\n");
		               writer.flush();
		           }
	              }
	         }
           )
        ]
      |
        "print" "with" "parens"
	(
            "on"
		{

                     if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
		     }
		     writer.write("ignore: set print with parens on\n");
		     writer.flush();
	        }
         |
            "off"
		{

                     if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
		     }
		     writer.write("ignore: set print with parens off\n");
		     writer.flush();
	        }	        
        )
      |
        "include"
        token=<IDENTIFIER>
             {
		 if (!token.image.equals("BOOL")) {
                     String msg= "expect BOOL, at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                     throw new ParseException(msg);	
	         }
	     }
        (
             "on"
		  {
		      boolInclude = true;
	              if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
		      }
		      writer.write("set include BOOL on\n");
		      writer.flush();
	          }
             |
             "off"
		  {
                      boolInclude = false;
	              if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
		      }
		      writer.write("set include BOOL off\n");
		      writer.flush();
		  }
        )
     |
	"show"
	token=<IDENTIFIER>
            {
		 if (!token.image.equals("details") &&
		     !token.image.equals("detail") &&
                     !token.image.equals("retracts") &&
		     !token.image.equals("retract")) {
                     String msg= "expect detail or retracts, at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                     throw new ParseException(msg);	
	         }
	     } 
	( 
           "on"
		  {
		      if (token.image.startsWith("detail")) {
		          detail = true;
                      } else {
			  Term.showRetract = true;
		      }

	              if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
			  writer.write("set show "+token.image+" on\n");
		          writer.flush();
                      }
		      
	          }
         |
	   "off"
		  {
		      if (token.image.startsWith("detail")) {
		          detail = false;
                      } else {
			  Term.showRetract = false;
		      }
                      
	              if (mode == FILE_INPUT) {
	                  writer.write("====================="+
				       "=====================\n");
		        writer.write("set show "+token.image+" off\n");
		        writer.flush();
                      }

		  }
        ) 
     )

     [ "." ] 

    |

      "***>"
	 {
               boolean found = false;
               String msg = "";
               while (!found) {
                 try {
	            char more = jj_input_stream.readChar();
	            found = more == '\n';
	            msg += more;
                 } catch (IOException e) {
		    found = true;
	            msg += "\n";
	         }
	       }
               if (mode == FILE_INPUT)
                  writer.write("====================="+
                               "=====================\n");
	       writer.write("***> "+msg);
               writer.flush();

         }
    |
           {
               	
		String cmd = null;
		Token nameToken = null;
		TermSelection select;
                Hashtable map = new Hashtable();
                String varname = null;
                Term term = null;
                boolean at = true;
                Map v2t = new HashMap();
	   }
       "apply"
	      {
		  cmd = "apply";
		  token = getToken(0);

		  if (currentTerm == null) {
		       msg= "no term is defined by \"start\" command, "+
			    " at line "+token.beginLine+
			    ", column "+token.endColumn+".";
                       throw new ParseException(msg);	
		  }

	          if (dynmaicModule != null) {
	              module = dynmaicModule;
	          } else {
	              module = currentModule;
	          }

                  if (module == null) {
	              writer.write("Warning: no module input yet,"+
                                   " use BOOL instead\n");
	              writer.flush();
	              module = ModuleFactory.createBool();
	          }

	      }
       (
             (
                 nameToken=<IDENTIFIER>
                |
	         nameToken=<FLOATING_POINT_LITERAL> 
             )
                 
             [
                 "with"
		     {
                         string = "";
		     }
                 token=<IDENTIFIER>
		     {
			 varname = token.image;
		     }
                 token=<IDENTIFIER>
		     {
			 if (!token.image.equals("=")) {
                             msg= "expect '=', at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                             throw new ParseException(msg);	
			 }
		     }
                 (
                      "("
                          (
                            (
                            token=<IDENTIFIER>
			        {
				   string += token.image+" ";
				}
                            |
			    token=<INTEGER_LITERAL>
				{
		                   string += token.image+" ";
				}
                            |
			    token="*"
			        {
				   string += token.image+" ";
			        }
                            )
			       
                          )+
                      ")"
                 |
                      token=<IDENTIFIER>
			  {
			     string = token.image;
			  }
                 |
		      token=<INTEGER_LITERAL>
			  {
			     string = token.image;
			  }
                 )
		     {

                         try {
                             term = Term.parse(module, string);
                             v2t.put(varname, term);
			 } catch (TermException e) {
			     msg= e.getMessage()+" at line "+
                                  token.beginLine+".\n";
                             throw new ParseException(msg);
			 }
		     }


                 (
                     ","
			{
			   string = "";
		        }
                    token=<IDENTIFIER>    // var
		        {
			     varname = token.image;
		        }
                    token=<IDENTIFIER>    // =
		        {
			    if (!token.image.equals("=")) {
                                msg= "expect '=', at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                                throw new ParseException(msg);	
			    }
		        }
                    (
		        token=<IDENTIFIER>
			   {
			        string += token.image;
			   }
		        |
			token=<INTEGER_LITERAL>
			    {
			        string += token.image;
			    }
		        |
			(
			   "("
                                (
                                     token=<IDENTIFIER>
			                 {
			                     string += token.image;
			                 }
                                )+
                           ")"
			)
		    )
			{
			     try {
                                 term = Term.parse(module, string);
                                 v2t.put(varname, term);
			     } catch (TermException e) {
			         msg= e.getMessage()+" at line "+
                                      token.beginLine+".\n";
                                 throw new ParseException(msg);
			     }   
			}
                 )* 

           ]
       |
           "print"
       |
	   "red"
	       {
		   cmd = "red";
	       }
       |
           "reduction"
	       {
		   cmd = "red";
	       }
       |
	   "reduce"
               {	  
		   cmd = "red";
	       }	       
       )
       ( 
           "at" 
          | 
           "within"
	      {
	         at = false;
	      } 
       )
       select=Selection(at)
       (
         "of"
	     {
	         TermSelection ts;
	     }
         ts=Selection(at)
	     {
		 ts.append(select);
                 select = ts;
	     }
       )*
            {
		if (cmd.equals("apply")) {

		   if (nameToken != null) {

        	       String name = nameToken.image;
		       String modName = null;

		       boolean reverse = false;
		       if (name.startsWith("-")) {
		          reverse = true;
		          name = name.substring(1);
		       }

		       int index = name.indexOf(".");
		       if (index == 0) {
			    name = name.substring(1);
		       } else {
			    name = name.substring(index+1);
			    modName = name.substring(0, index);
		       }

	               Equation eq = module.getEquation(name);
		       
		       if (eq == null) {

			   eq = module.getGeneralEquation(name);
			   if (eq == null) {

			      try {
			         int pos = Integer.parseInt(name);
                                 //eq = (Equation)module.equations.get(pos-1);
				 eq = module.getRule(pos);
                              } catch (Exception e){}

			      if (eq == null) {
                                  msg= "no equation with name "+name+
                                       " at line "+nameToken.beginLine+
                                       ", column "+nameToken.endColumn+".";
                                  throw new ParseException(msg);
		              }
		           }
		       }

                       // create map
                       Iterator itor = v2t.keySet().iterator();
                       string = "";
		       while (itor.hasNext()) {
			   varname = (String)itor.next();
			   term = (Term)v2t.get(varname);

			   if (string.length() == 0) {
			       string += varname+" = "+term;
			   } else {
			       string += ", "+varname+" = "+term;
			   }

			   Variable var;
                           if (reverse) {
		               var = eq.left.getVariableWithName(varname);
		           } else {
                               var = eq.right.getVariableWithName(varname);
                           }

			   if (var == null && eq.condition != null) {
                               var = eq.condition.getVariableWithName(varname);
			   }

			   if (var == null) {
			      msg= "no variable with name "+varname+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                              throw new ParseException(msg);
	                   }

			   map.put(var, term);

		       }


		       writer.write("====================="+
                                "=====================\n");
                       if (reverse) {
		            writer.write("reverse apply: "+
					 format(eq.toString(), 15)+"\n");
                       } else {
                            writer.write("apply: "+
					 format(eq.toString(), 15)+"\n");
	               }

		       writer.write("term: "+
				    format(currentTerm.toString(), 6)+
				    "\n");

                       if (at) {
		            writer.write("at: "+select+"\n");
	               } else {
                            writer.write("within term\n");
	               }

		       if (string.length() > 0) {
                           writer.write("with: "+string+"\n");
		       }
		       writer.flush();

		       try {

                           engine = new RewriteEngine(module);
		           currentTerm = engine.apply(currentTerm,
                                                      eq,
                                                      reverse,
                                                      select,
                                                      map);

			   Term shift =(Term)currentTerm.getPropertyBy("cond");
			   if (shift != null) {

                               currentTerm.removePropertyBy("cond");
			       termStack.push(currentTerm);
		               currentTerm = shift;

                               writer.write("shifting focus to condition\n");
			       writer.write("condition: "+shift+"\n");
			       writer.flush();

                           } else if (termStack.isEmpty()) {

                               writer.write("result: "+
					    format(currentTerm.toString(),
						   8)+
                                            "\n");
			       writer.flush();

                           } else {
			       if (currentTerm.operation != null &&
				   currentTerm.operation.equals(
						BoolModule.trueOp)){

				  writer.write("result: true\n");
                                  writer.write("condition is satisfied,"+
					       " applying rule\n");
				  writer.write("shifting focus back"+
					       " to previous context\n");

				  currentTerm = (Term)termStack.pop();
			          writer.write("term: "+
						format(currentTerm.toString(),
						       6)+
					        "\n");
			          writer.flush();
			       } else {
                                  writer.write("result: "+
					       format(currentTerm.toString(),
						     8)+
					       "\n");
			          writer.flush();
			       }
		           }

	               } catch (Exception e) {
			   token = getToken(0);
                           msg= e.getMessage()+	
                                " at line "+token.beginLine+".\n";
                           throw new ParseException(msg);
	               }

		  } else {
 		       writer.write("====================="+
                                "=====================\n");
                       writer.write("apply print at "+select+"\n");

		       if (select != null) {
			   engine = new RewriteEngine(module);
                           try {
                               writer.write("result: "+format(
                                   engine.select(currentTerm,
                                                 select).selected.toString(),
                                   8)+
                                            "\n");
                           } catch (Exception e) {
                           }
                       } else {
                           writer.write("result: "+currentTerm+"\n");
                       }
		       writer.flush();
		  }

              } else if (cmd.equals("red")) {

                   writer.write("====================="+	
                                "=====================\n");
                   writer.write("apply red at "+select+"\n");
	           writer.flush();

		   try {
		       engine = new RewriteEngine(module);
                       currentTerm = engine.applyReductionAt(currentTerm,
						             select);

		       if (termStack.isEmpty()) {
                           writer.write("result: "+currentTerm+"\n");
                           writer.flush();
                       } else {

			   if (currentTerm.operation != null &&
			       currentTerm.operation.equals(
					      BoolModule.trueOp)){

				  writer.write("result: true\n");
                                  writer.write("condition is satisfied,"+
					       " applying rule\n");
				  writer.write("shifting focus back"+
					       " to previous context\n");

				  currentTerm = (Term)termStack.pop();
			          writer.write("term: "+currentTerm+"\n");
			          writer.flush();
			   } else {
                                  writer.write("result: "+currentTerm+"\n");
			          writer.flush();
			   }

		       }

		   } catch (Exception e) {
		       msg= e.getMessage()+	
                            " at line "+token.beginLine+".\n";
                       throw new ParseException(msg);
	          }
              }
	   }

       "."

    |
       "start"
	   {
	        if (dynmaicModule != null) {
	             module = dynmaicModule;
	        } else {
	             module = currentModule;
	        }

                if (module == null) {
	            writer.write("Warning: no module input yet,"+
                                 " use BOOL instead\n");
	            writer.flush();
	            module = ModuleFactory.createBool();
	        }

	   }
       string=Term(module)
	   {

                 try {

                     long beginTime = new Date().getTime();	
                     currentTerm = Term.parse(module, string);
                     long parseTime = new Date().getTime() - beginTime;
                
		     writer.write("===================="+
				  "======================\n");
	             writer.write("start: "+
				  format(currentTerm.toString(), 13)+
                                  "\n");
                     writer.write("parse time: "+parseTime+"ms\n");
	             writer.flush();

		     termStack = new Stack();

                 } catch (TermException e) {

	             writer.write(e.getMessage()+"\n");
	             writer.flush();
                 }               
	   }
       "."
  )
   

}


TermSelection Selection(boolean at) :
{
   TermSelection select;
   String msg = "";
   Token token;
}
{

    ( 
        "["
	      {
		  Token token1, token2, token3;
		  int begin=-1, end=-1;
	      }
              (
                  (
                     token1=<INTEGER_LITERAL>
			{
			      token3 = token1;
			      begin = Integer.parseInt(token1.image);
			      end = begin;

			      if (begin < 0){
				  msg= "wrong occurance "+" at line "+
                                        token1.beginLine+", column "+
                                        token1.endColumn+".";
                                  throw new ParseException(msg);
			      }
			 }
                   [
                     token2=<IDENTIFIER>
			 {
			       if (!token2.image.equals("..")) {
                                  msg= "expect .. "+" at line "+
                                           token2.beginLine+", column "+
                                           token2.endColumn+".";
                                  throw new ParseException(msg);
			       }
			  }
	             token3=<INTEGER_LITERAL>
			  {
			       end = Integer.parseInt(token3.image);
			       if (end < begin){
				    msg= "wrong occurance "+" at line "+
                                         token3.beginLine+", column "+
                                         token3.endColumn+".";
                                         throw new ParseException(msg);
			            }
                               }
                   ]
              )
		      {
			  select = new TermSelection(begin, end);
		      }
          
           |
              
              token=<IDENTIFIER>
                   {
			String string = token.image;
                        int index = token.image.indexOf("..");
			if (index != -1) {

			    String b = token.image.substring(0, index);
			    String a = token.image.substring(index+2);
                        
			    begin = Integer.parseInt(b);
			    end = Integer.parseInt(a);

			    if (begin < 0 || end < begin) {
				  msg= "wrong subsequence"+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                                  throw new ParseException(msg);
	                    }

			    select = new TermSelection(begin, end);
			} else {
                            msg= "wrong subsequence "+" at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                            throw new ParseException(msg);
			}
	           }
             ) 
        "]"
   |
        "("
	      {
		   List list = new ArrayList();
              }
              (
                   token=<INTEGER_LITERAL>
		       {
			   list.add(token);
		       }
              )*
		       {
				
			  int[] seq = new int[list.size()];
			  for (int i=0; i<seq.length; i++) {
			      token = (Token)list.get(i);
			      int position = Integer.parseInt(token.image);
			      if (position < 0){
				  msg= "wrong occurance "+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                                  throw new ParseException(msg);
			      }
			      seq[i] = position;
			   }

			    select = new TermSelection(seq);
		        }
          ")"
       |
	  //LOOKAHEAD( <IDENTIFIER> ("," <INTEGER_LITERAL>)* "," <IDENTIFIER>)
	  LOOKAHEAD( { getToken(1).image.startsWith("{") &&
		       getToken(1).image.length() > 1    &&
		       !getToken(1).image.endsWith("}") })
	      {
		 ArrayList slist = new ArrayList();
	      }
	  token=<IDENTIFIER>
	      {
		  String string = token.image;
		  if (string.startsWith("{")) {
		      string = string.substring(1);
		     
		      int pos = Integer.parseInt(string);
		      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);
	              }

		      slist.add(new Integer(pos-1));
	          }
	      } 
	  (
	     LOOKAHEAD(10)
             "," 
	     token=<INTEGER_LITERAL>
		  {
		      string = token.image;
	              int pos = Integer.parseInt(string);
		      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);
	              }

		      slist.add(new Integer(pos-1));
		  }
          )* 
          "," 
          token=<IDENTIFIER>
	     {
                  string = token.image;
		  if (string.endsWith("}")) {
		      string = string.substring(0, string.length()-1);
		      int pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);
	              }

		      slist.add(new Integer(pos-1));
		     
	          }

		  select = new TermSelection(slist);
	     }
       |
	   LOOKAHEAD ( { getToken(1).image.equals("{") } ) 
	      {
                   ArrayList slist = new ArrayList();	
	      }
	   <IDENTIFIER> 
	   token=<INTEGER_LITERAL>
	       {
		      String string = token.image;
	              int pos = Integer.parseInt(string);
		      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);
	              }

		      slist.add(new Integer(pos-1));
	       } 
	   (
            LOOKAHEAD("," <INTEGER_LITERAL>)
            "," 
            token=<INTEGER_LITERAL>
	           {
		      string = token.image;
	              pos = Integer.parseInt(string);
		      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);
	              }

		      slist.add(new Integer(pos-1));
	           }
           )* 
	   ( 
               token=<IDENTIFIER>
	          {
		      if (!token.image.equals("}")) {
	                 msg= "expect '}' at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         throw new ParseException(msg);	          
	              }
		  } 
            | "," token=<IDENTIFIER> 
		  {
                     string = token.image;
		     if (string.endsWith("}")) {
		          string = string.substring(0, string.length()-1);
		          pos = Integer.parseInt(string);
                          if (pos <= 0) {
                             msg= "wrong selection at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                             throw new ParseException(msg);
	                  }
		          slist.add(new Integer(pos-1));
	              }
		  }
           )
		{
		    select = new TermSelection(slist);
		}
       |
	  LOOKAHEAD({ getToken(1).image.startsWith("{")   &&
		      getToken(1).image.endsWith("}")      })
	  token=<IDENTIFIER>
	     {
		 String string = token.image;
                 string = string.substring(1);
                 string = string.substring(0, string.length()-1);

                 try {
		     ArrayList slist = new ArrayList();
		     int pos = Integer.parseInt(string);

		     if (pos <= 0) {
                        msg= "expect a natural number at line "+
                             token.beginLine+", column "+
                             token.endColumn+".";
                        throw new ParseException(msg);
		     }

		     slist.add(new Integer(pos-1));
                     select = new TermSelection(slist);
		 } catch (Exception e) {	    
                     msg= "expect an integer at line "+
                          token.beginLine+", column "+
                          token.endColumn+".";
                     throw new ParseException(msg);
                 }
	     }
       |
	  token=<IDENTIFIER>
             {
		    if (!token.image.equals("term") &&
			!token.image.equals("top")) {
	
                        msg= "expect 'term' or 'top'"+
			     " or a selection  at line "+
                             token.beginLine+", column "+
                             token.endColumn+".";
                        throw new ParseException(msg);

		    } else {
		        select = new TermSelection(at);
	            }
	    }
       )   
	    {
		return select;
	    }
}


void BatchCommand() throws IOException :
{}
{
  (  Command()
   |
     "eof"
       {
	  return;
       }
  )+
  
     {
          Token token = getToken(1);
          String string = token.image.trim();
          if (!string.equals("")) {
              String msg= "Unknown token "+string+
                          " at line "+token.beginLine+
                          ", column "+token.endColumn+".";
              throw new ParseException(msg);
          }
     }
}



void DynamicDecl(Module module) :
{}
{

      ProtectedImport(module)
    |
      ExtendedImport(module)
    |
      UsedImport(module)
    |
      SortsDecl(module)
    |
      SubsortDecl(module)
    |
      VarDecl(module)
    |
      VarImport(module)
    |
      OperationDecl(module)
    |
      {
	  RewriteEngine.cleanCache();
      }
      EquationDecl(module)
    |
      DefDecl(module)
    |
      LetDecl(module)
    |
      MembershipDecl(module) 
}



Module[] Start() :
{
    Module module;
    Vector vec = new Vector();
    View view;
    Token token;
}
{
   (
       ( "obj" | "object" )
	    {
	       paraPool = new Hashtable();
	    }
       (module=Module(Module.INITIAL))
       ("endo" | "end" | "jbo")
            {
                //modPool.put(module.getModuleName(), module);
		saveModule(module);
                vec.addElement(module);
		paraPool = new Hashtable();
            }
     |
       "dth"
	    {
	       paraPool = new Hashtable();
	    }
       (module=Module(Module.INITIAL))
       ("endd" | "end" )
           {
               //modPool.put(module.getModuleName(), module);
	       saveModule(module);
               vec.addElement(module);
	       paraPool = new Hashtable();
           }
     |
       ( "th" | "theory")
	    {
	       paraPool = new Hashtable();
	    }
       (module= Module(Module.LOOSE))
       ( "endth" | "end" | "ht"  )
           {	
               //modPool.put(module.getModuleName(), module);
	       saveModule(module);
               vec.addElement(module);
	       paraPool = new Hashtable();
           }
     |
       "bth"
	    {
	       paraPool = new Hashtable();
	    }
       (module=Module(Module.BEHAVORIAL))
       ( "endb" | "end" )
           {
               //modPool.put(module.getModuleName(), module);
	       saveModule(module);
               vec.addElement(module);
	       paraPool = new Hashtable();
           }
     |
       "view"
	   {
	       paraPool = new Hashtable();
	   }
       (view=ViewDecl())
       ( "endv" | "end")
	   {
               viewPool.put(view.getName(), view);
	       paraPool = new Hashtable();
	   }
     |
       "morph"
           {
	       paraPool = new Hashtable();
	   }
       (view=MorphismDecl())
       "end"
	   {
               viewPool.put(view.getName(), view);
	       paraPool = new Hashtable();
	   }
    )+
       {
           Module[] result = new Module[vec.size()];
	   vec.copyInto(result);
 
           token = getToken(1);
           String string = token.image.trim();
           if (!token.equals("")) {
               String msg="Unknown token "+string+
                          " at line "+token.beginLine+
                          ", column "+token.endColumn+".";
               throw new ParseException(msg);
           }

           return result;
       }
}




Module Module(int type) :
{
  Module module;
}
{
   module=Interface(type)
   "is"
   (
      ModElt(module)
   )+
      {
	 return module;
      }
}



Module Interface(int type) :
{
    String name;
    Module module = null;
}
{

   (name=ModId())
      {
          try {

             ModuleName modName = new ModuleName(name);
	     module = new Module(type, modName);
             if (boolInclude) {
                 module.importModule(ModuleFactory.createBool());
             }
          } catch (SignatureException e) {}
    
	  ArrayList list = new ArrayList();

       }
   (
     "["
     ParametersDeclaration(module)
     ( 
         "," 
         ParametersDeclaration(module)
     )*
     "]"
          {
             list.add(new Integer(module.paraNames.size()));
	  }
   )* 
      {

	 if (list.size() > 0) {
	     int[] levels = new int[list.size()];
	     for (int i=0; i<list.size(); i++) {
		Integer aInt = (Integer)list.get(i);
		levels[i] = aInt.intValue();
	     }
	     module.setParametersLevel(levels);
	 }

	 if (module.isSecondOrder()) {
	     module.bindings = (Hashtable)modPool.clone();
	 }

         return module;
      }
}



void ParametersDeclaration(Module module) :
{
    List parameterNames = new ArrayList();
    List parameterTokens = new ArrayList();
    Module parameter;
    Token token;
    String name;
}
{
     (
       name=ModId()
          {
	      token = getToken(0); 
              parameterNames.add(name);
              parameterTokens.add(token);
              lookForParameter = true;
          }
     )+  
     "::"  
     (parameter=ModExpr(module)) 
          {

	       for (int i=0; i<parameterNames.size(); i++) {
                    name = (String)parameterNames.get(i);
                    token = (Token)parameterTokens.get(i);

                    // if parameter is a higher order module
                    // then change its parameter name

		    Module theModule = parameter;
                    if (parameter.isParameterized()) {
                        //theModule = parameter.rename();

			/*
		        System.out.println("------ before rename ------");
		        System.out.println(parameter);
		        System.out.println("------ after rename ------");
                        System.out.println(theModule);
                        System.exit(0);
			*/

		    }

                    try {                    
                        module.addParameter(name, theModule, getEnv());
       		        paraPool.put(name, theModule);
                    } catch (SignatureException e) {

                        String msg = e.getMessage()+
                                     " at line "+token.beginLine+
                                     ", column "+token.endColumn+".";
                        throw new ParseException(msg);

                    } catch (ModuleParameterException e) {

                        String msg = e.getMessage()+
                                     " at line "+token.beginLine+
                                     ", column "+token.endColumn+".";
                        throw new ParseException(msg);
                    }
               }
	    
               lookForParameter = false;
         }

}



Module ModExpr(Module mod) :
{
   Module module, module1, module2;
   ModuleName modName;
   Token token;
}
{

   (module1=ModSumExpTerm(mod))
       {

	    module = module1;

	    String notation = (String)module1.getProperty("notation");

	    if (notation != null) {	
                try {
		    module = module.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);	
                   String msg = e.getMessage()+
			        " at line "+token.beginLine+".";
                   throw new ParseException(msg);
           	}
	    }
       }
   (
     LOOKAHEAD(2)
     "+"
       {
	    if (module1.isParameterized()  &&
		lookForParameter) {
                token = getToken(0);	
                String msg = "Parameterized module "+module1.modName+
                             " must be used directly "+
			     "as parameter at line "+token.beginLine+".";
                throw new ParseException(msg);
            }
        }
     (module2=ModExpr(mod))
        {

	    if (module2.isParameterized()  &&
		lookForParameter) {
                token = getToken(0);	
                String msg = "Parameterized module "+module2.modName+
                             " must be used directly "+
			     "as parameter at line "+token.beginLine+".";
                throw new ParseException(msg);
            }

	    notation = (String)module2.getProperty("notation");
	    if (notation != null) {
                try {
	            module2 = module2.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);	
                   String msg = e.getMessage()+
			        " at line "+token.beginLine+".";
                   throw new ParseException(msg);
           	}
	    }

            int type = module1.getType();
	    if (module2.getType() > type) {
                type = module2.getType();
            }

	    modName = module1.getModuleName().sum(module2.getModuleName());
            module = new Module(type, modName);

            try {

                module.protectedImport(module1);
	        module.protectedImport(module2);
                module1 = module;

            } catch (SignatureException e) {
	        token = getToken(0);
                String msg = e.getMessage()+" at line "+token.beginLine+".";
                throw new ParseException(msg);
            }	   
        }
   )*
        {       
	    return module;
        }
}




Module ModSumExpTerm(Module mod) :
{
     Module module;
     List list = new ArrayList();
}
{

   module = ModExpTerm(mod)
       {

	    String notation = (String)module.getProperty("notation");

	    if (notation != null) {
                ModuleName nname = module.modName.addAnnotation(notation);
                try {
		    module = module.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);	
                   String msg = e.getMessage()+
			        " at line "+token.beginLine+".";
                   throw new ParseException(msg);
           	}
	    }

            list.add(module);
       }
   (
     LOOKAHEAD(10) 
     "||"
       {
	    if (module.isParameterized()  &&
		lookForParameter) {
                token = getToken(0);	
                String msg = "Parameterized module "+module.modName+
                             " must be used directly "+
			     "as parameter at line "+token.beginLine+".";
                throw new ParseException(msg);
            }
        }
     module = ModExpTerm(mod)
          {
	      if (module.isParameterized()  &&
		  lookForParameter) {
                  token = getToken(0);	
                  String msg = "Parameterized module "+module.modName+
                               " must be used directly "+
			       "as parameter at line "+token.beginLine+".";
                  throw new ParseException(msg);
              }

              notation = (String)module.getProperty("notation");
	      if (notation != null) {	
                  try {
	             module = module.addAnnotation(notation, getEnv());
                  } catch (Exception e) {
                     token = getToken(0);	
                     String msg = e.getMessage()+
			          " at line "+token.beginLine+".";
                     throw new ParseException(msg);
           	  }
	      }
	      list.add(module);
          }
   )*
       {
            if (list.size() > 1) {
	       try {
                    module = Module.makeTuple(mod.getModuleName(), list);
               } catch (Exception e) {
                    
	            token = getToken(0);
                    String msg = e.getMessage()+" at line "+
                                 token.beginLine+".";
                    throw new ParseException(msg);
               }
            }

            return module;
        }
}



Module ModExpTerm(Module mod) :
{
    Module module;
    String mname;
    Module mtmp;
    Token token;

    String name;
}
{
   (    
      (name=ModId())  
         {
	     module = null;

	     if (mod != null) {

                if (paraPool != null) {
		     // find a module from parameter 
		     module = (Module)paraPool.get(name);
                     if (module != null) {
                        module.setProperty("notation", name);
	             }
	        }            
	     } 

             if (module == null) {

	         // find module from previously defined modules
                 ModuleName modName = new ModuleName(name);

	         module = null;
                 Enumeration enum_ = modPool.keys();
                 while (enum_.hasMoreElements()) {
	            ModuleName tmp = (ModuleName)enum_.nextElement();
                    if (tmp.equals(modName)) {
                        module = (Module)modPool.get(tmp);
	                module = (Module)module.clone();
			break;
                    }
                 }

             } else {
                 module = (Module)module.clone();
	         module.setProperty("parameter", name);
             }

             if (module == null) {

                 // find module from system default modules
                 module = ModuleFactory.getDefaultModule(name);
             }


             if (module == null) {

		 // find module from previously defined view
         	 View view = (View)viewPool.get(name);
                 if (view != null) {
	             module = (Module)view.getTarget().clone();
                     module.setProperty("view", view);
                 }    
             }

             if (mod != null && module == null) {
                  Sort[] sorts = mod.getSortsByName(name);
                  if (sorts.length == 1) {

                      //ModuleName modName = sorts[0].getModuleName();
                      ModuleName modName = new ModuleName(name);
		      if (sorts[0].isInitial()) {
                          module = new Module(Module.INITIAL, modName);
                      } else if (sorts[0].isHidden()) {
                          module = new Module(Module.BEHAVORIAL, modName);
                      } else {
                          module = new Module(Module.LOOSE, modName);
	              }

                     try {
	                  module.protectedImport(ModuleFactory.createBool());
                          module.addSort(sorts[0]);
                      } catch (Exception e) {}
                  }

             }

             if (module == null) {
                 module = ModuleFactory.getDefaultModule(name);
             }

             if (module == null)  {
                 token = getToken(0);
                 String msg = "Unknown module: "+name+" at line "+
                              token.beginLine+", column "+token.endColumn+".";
                 throw new ParseException(msg);
             }

         }
      |
      "("
           module=ModExpr(mod)
      ")"

   )

   (
     LOOKAHEAD("*" | "[")
     (
        "*"
            {

	        if (module.isParameterized()  &&
		    lookForParameter) {
                    token = getToken(0);	
                    String msg = "Parameterized module "+module.modName+
                                 " must be used directly "+
			         "as parameter at line "+token.beginLine+".";
                    throw new ParseException(msg);
                }		

		Map map = new HashMap();
	    }

        "("
            
            (module=RenameElt(module.getModuleName(), module, map))
            (
               ","
               (module=RenameElt(module.getModuleName(), module, map))
            )*
                 
        ")"
             {
		 ModuleName oldName = module.getModuleName();
		 ModuleName newName = oldName.renaming(map);

		 try {
		     module = module.changeModuleName(oldName,
						      newName,
						      newName);
                 } catch (SignatureException e) {
	      
		    token = getToken(0);
                    String msg = e.getMessage()+" at line "+
                                 token.beginLine+", column "+
				 token.endColumn+".";
                    throw new ParseException(msg);
	         }

	     }

     |
        
        "["
         
             {
		
                Vector referViews = new Vector();

                Module mainMod = (Module)module.clone();
                ModuleName modName = mainMod.getModuleName();
                Vector modules = new Vector();
                Vector flags = new Vector();
	        String parameterName;

                token = getToken(0);
                int index = 0;         // indicate the parameter's position

		Vector views = new Vector();

	        String notation = (String)mainMod.getProperty("notation");
	        if (notation != null) {
                    try {
		        mainMod = mainMod.addAnnotation(notation, getEnv());
                        modName = modName.addAnnotation(notation);
                    } catch (Exception e) {
		        e.printStackTrace();
	            }
	        }

	     }
          (

	     LOOKAHEAD ( "(" OpName() ")" "." "(" ModExpr() ")" )
	         {
		    String string;
		 }
             "("
                 string=OpName()
             ")" 
	     "." 
	     token="("
                 module=ModExpr(mod)
              ")"
	         {
		     if (module == null) {
			 String msg = "unknown module at line "+
				      token.beginLine+", column "+
				      token.beginLine;
		         throw new ParseException(msg);   
	             }

		     try {
			
			  // setup source module
                          Module source;
			  View vi = (View)mainMod.getProperty("view"); 
		          if (vi != null && vi.main != null) {
			      source = vi.main.getParameterAt(index);
			  } else {
		              source = mainMod.getParameterAt(index);
			  }

			  // setup target module
			  Module target = module;

                          // get operations defined in source
			  Operation[] sops = source.getOperationsIn(
                                                 source.getModuleName());
			  if (sops.length != 1) {
                              String msg = "module "+
					   source.getModuleName()+
					   " doesn't have a single "+
                                           "operator";
			      throw new ParseException(msg);
			  }

			  // get operations form target
			  Operation[] tops =
			      target.getOperationsWithName(
				  Operation.normalize(string));

			  boolean useOp = true;
                          Term term = null;

			  if (tops.length > 1) {

                              String msg = "module "+
					   target.getModuleName()+
					   " has no unique "+
                                           "operator "+string+".";
			      throw new ParseException(msg);

			  } else if (tops.length == 0) {

			      try {
				  // need to tokenize opName
				  StringTokenizer st =
				      new StringTokenizer(string);
				  String str = "";
				  while (st.hasMoreTokens()) {
				      String s = st.nextToken();
				      if (target.containsToken(s)) {
					  str += s+" ";
				      } else {
                                          String ss =
					      target.decomposeToken(s);
					  if (ss == null) {
					      str += s+" ";
					  } else {
					      str += ss+" ";
					  }
				       }
				  }

                                  term = Term.parse(target, str);
				  useOp = false;

			      } catch (TermException ex) {
		
				  if (string.indexOf("_") == -1) {
				       tops =target.getOperationsWithCleanName(
					        string.trim());
				       if (tops.length != 1) {
				             String msg = "module "+	
						       target.getModuleName()+
						       " has no unique "+
                                                       "operator "+string;
			                     throw new ParseException(msg);
				       }
				  } else {
				       String msg = "module "+	
				            target.getModuleName()+
				            " has no operator "+string;
			                  throw new ParseException(msg);
                                  }
                               }
		           }

			   String viewName = "("+string.trim()+")"+".("+
					  module.modName+")";
		           if (!useOp && sops[0].isConstant()) {
                                viewName = "("+term+")"+".("+
					   module.modName+")";
                           }

                           View view = new View(viewName, source, target);
                           if (useOp) {
			       view.addOperationMap(sops[0], tops[0]);
                           } else if (sops[0].isConstant()) {
			       Term left = new Term(sops[0]);
			       view.addTransformation(left, term);
			   } else {
			       String msg = string+" is not a constant";
			       throw new ParseException(msg);
			   }   
                            
                           view.validate();
			   target.setProperty("view", view);	

		           flags.addElement(null);
		           modules.addElement(module);	

			   views.addElement(view);

                      }  catch (ViewException e) {
                           String msg = e.getMessage()+"  at line "+
				        token.beginLine+", column "+
				        token.beginColumn;

	                   if (detail) {
	                        msg = "format:"+format(msg, 0)+"\n"+
		                      "the failed view is\n"+e.getView();
                           }

			   throw new ParseException(msg);
		      } catch (Exception e) {
                            String msg = e.getMessage()+"  at line "+
				         token.beginLine+", column "+
				         token.beginColumn;
			    throw new ParseException(msg);
                      }
	         }
             |
             LOOKAHEAD("("
                           ( <IDENTIFIER>
                             |
                             <INTEGER_LITERAL>
                             |
                             <SYMBOL>
                             /*
                             |
	                     MetaToken()
                             */
			     |
			     "(" OpName() ")"
                           )+
                       ")"
                        <IDENTIFIER>
                     )
                     {
		        String opName = null;
			String stModName = null;
			String tmp;
	             }
                "("
                     (
                        (
                        token=<IDENTIFIER>
	                    {
                                if (opName == null) {
				    opName = token.image;
			        } else {
				    opName += " "+token.image;
                                }
			    }
                        |
		        token=<INTEGER_LITERAL>
	                    {
                                if (opName == null) {
				    opName = token.image;
			        } else {
				    opName += " "+token.image;
                                }
			    }
                        |
			token=<SYMBOL>
	                    {
                                if (opName == null) {
				    opName = token.image;
			        } else {
				    opName += " "+token.image;
                                }
			    }
                        |
			token=MetaToken()
	                    {
                                if (opName == null) {
				    opName = token.image;
			        } else {
				    opName += " "+token.image;
                                }
			    }
		        |
	                "(" tmp=OpName() ")"
			    {
				if (opName == null) {
				    opName = "( "+tmp+" ) ";
			        } else {
				    opName += " ( "+tmp+" ) ";
                                }
			    }
                        )
                            
                     )+
                 ")"
                 (
                 token=<IDENTIFIER>
                    {
		        stModName = token.image;
			if (stModName.startsWith(".")) {
		            stModName = stModName.substring(1);

		            module = getModule(stModName);
			    if (module == null) {
                                String msg = "No module has the name "+
					      stModName+"  at line "+
				              token.beginLine+", column "+
				              token.beginColumn;
			        throw new ParseException(msg);
			    }

			    // in this case, make sure
                            // formal parameter is a  single operator modules

			    try {

				Module source;

				View vi = (View)mainMod.getProperty("view"); 
				if (vi != null && vi.main != null) {
				    source = vi.main.getParameterAt(index);
				} else {
		                    source = mainMod.getParameterAt(index);
			        }

			        Module target = module;

			        Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
				if (sops.length != 1) {
                                    String msg = "module "+
						 source.getModuleName()+
						 " doesn't have a single "+
                                                 "operator";
			            throw new ParseException(msg);
			        }

				Operation[] tops =
				    target.getOperationsWithName(
					Operation.normalize(opName));

				boolean useOp = true;
                                Term term = null;

				if (tops.length > 1) {
                                    String msg = "module "+
						 target.getModuleName()+
						 " has no unique "+
                                                 "operator "+opName+".";
			            throw new ParseException(msg);
			        } else if (tops.length == 0) {

			            try {

				       // need to tokenize opName
				       StringTokenizer st =
				           new StringTokenizer(opName);
				       String str = "";
				       while (st.hasMoreTokens()) {
					  String s = st.nextToken();
					  if (target.containsToken(s)) {
					     str += s+" ";
					  } else {
                                             String ss =
						target.decomposeToken(s);
					     if (ss == null) {
						str += s+" ";
					     } else {
						str += ss+" ";
					     }
					  }
				       }
                                       //opName = str;
				       term = Term.parse(target, str);
				       useOp = false;
				    } catch (TermException ex) {

				       if (opName.indexOf("_") == -1) {
				          tops =
                                             target.getOperationsWithCleanName(
					        opName.trim());
				          if (tops.length != 1) {
				             String msg = "module "+	
						       target.getModuleName()+
						       " has no unique "+
                                                       "operator "+opName;
			                     throw new ParseException(msg);
					  }
				       } else {

				          String msg = "module "+	
						       target.getModuleName()+
						       " has no "+
                                                       "operator "+opName;
			                  throw new ParseException(msg);
                                       }

                                    }
		                }

				String viewName = "("+opName.trim()+")"+"."+
						  stModName;
				if (!useOp && sops[0].isConstant()) {
                                    viewName = "("+term+")"+"."+
						  stModName;
                                }

                                View view = new View(viewName, source, target);
                                if (useOp) {
			           view.addOperationMap(sops[0], tops[0]);
                                } else if (sops[0].isConstant()) {
				   Term left = new Term(sops[0]);
			           view.addTransformation(left, term);
			        } else {
				   String msg = opName+" is not a constant";
			           throw new ParseException(msg);
			        }

                                view.validate();
			        target.setProperty("view", view);	

		                flags.addElement(null);
		                modules.addElement(module);	

				views.addElement(view);

                            }  catch (ViewException e) {
                                String msg = e.getMessage()+"  at line "+
				             token.beginLine+", column "+
				             token.beginColumn;

	                        if (detail) {
	                            msg = "format:"+format(msg, 0)+"\n"+
		                          "the failed view is\n"+e.getView();
                                }

			        throw new ParseException(msg);
		            } catch (Exception e) {
                                String msg = e.getMessage()+"  at line "+
				             token.beginLine+", column "+
				             token.beginColumn;
			        throw new ParseException(msg);
                            }

		        } else {
                            String msg = "expect \".\" at line "+
				         token.beginLine+", column "+
				         token.beginColumn;
			    throw new ParseException(msg);
			}


                    }
             )
             |
             module = ModExpr(mod)
                 {

	             modules.addElement(module);
		     String flag = (String)module.getProperty("parameter");
		     flags.addElement(flag);

		     if (flag != null) {
                         module.removeProperty("parameter");
		     }

		     // handle dependent type
                     try {
                     	Module parameter;
		     	View vi = (View)mainMod.getProperty("view");
			String paraName;
		     	if (vi != null && vi.main != null) {
			    parameter = vi.main.getParameterAt(index);
			    paraName = vi.main.getParameterNameAt(index);
		        } else {
		            parameter = mainMod.getParameterAt(index);
                            paraName = mainMod.getParameterNameAt(index);
		        }

		        View view = (View)module.getProperty("view");

	                if (view == null) {
		            view = module.getViewFor(parameter);
			    module.setProperty("view", view);

			    if (view == null) {
				 String msg = module.getModuleName()+
				              " is not an instance of "+
				              parameter.getModuleName();
		                 throw new ParseException(msg);
			    }
	                } else if (!view.source.modName.equals(
                                       parameter.modName)){
			    String msg = "the view is defined on "+
					 view.source.modName+", "+
				         "not on "+parameter.modName; 
		            throw new ParseException(msg); 
			}

			view = view.addNotation(paraName, null, getEnv());

                        views.addElement(view);
                        view.validate();

	             } catch (Exception e) {

                        String msg = e.getMessage()+" at line "+
				     token.beginLine+", column "+
				     token.beginColumn;
			throw new ParseException(msg);
		     } 

		     // end handling

                 }
             |
                 {
                     Module source = null;
                     try {
		         source = mainMod.getParameterAt(index);

		         // for dependent type, source is not correct

                     } catch (ModuleParameterException e) {
                         token = getToken(0);
                         String msg = e.getMessage()+" at line "+
                                      token.beginLine+", column "+
                                      token.endColumn+".";
                         throw new ParseException(msg);
		     }

	         }
	     module=LocalViewDecl(mod, source, views)
		{
		       
		    flags.addElement(null);
		    modules.addElement(module);

		    // handle dependent type
		    views.addElement(module.getProperty("view"));
	        }
          )
              {
		  index++;
	      }
          (
             ","

             (


	     LOOKAHEAD ( "(" OpName() ")" "." "(" ModExpr() ")" )
	         {
		    String string;
		 }
             "("
                 string=OpName()
             ")" 
	     "." 
	     token="("
                 module=ModExpr(mod)
              ")"
	         {
		     if (module == null) {
			 String msg = "unknown module at line "+
				      token.beginLine+", column "+
				      token.beginLine;
		         throw new ParseException(msg);   
	             }

		     try {
			
			  // setup source module
                          Module source;
			  View vi = (View)mainMod.getProperty("view"); 
		          if (vi != null && vi.main != null) {
			      source = vi.main.getParameterAt(index);
			  } else {
		              source = mainMod.getParameterAt(index);
			  }

                          // get operations defined in source
			  Operation[] sops = source.getOperationsIn(
                                                 source.getModuleName());
			  if (sops.length != 1) {
                              String msg = "module "+
					   source.getModuleName()+
					   " doesn't have a single "+
                                           "operator";
			      throw new ParseException(msg);
			  }

			  // handle depentdent type
			  if (!source.isParameterized()) {
			      Module m = source;
			      for (int i=0; i<views.size(); i++) {
				  vi = (View)views.elementAt(i);
                                  String paraName = mainMod.getParameterNameAt(i);
				  vi = vi.addNotation(paraName, null, getEnv());

				  if (m.containsAnnotation(paraName)) {
				     m.importModule(vi.target);
				     m = vi.getImage(m);

                                     m = m.changeModuleName(vi.source.modName,
				                            vi.target.modName,
					                    m.modName);			
		    
                                     sops[0] = vi.getImage(sops[0]);
                                     sops[0] = sops[0].changeModuleName(
						   vi.source.modName,
				                   vi.target.modName);
				  }                                 
			       }
			       source = m;
                          }

			  // setup target module
			  Module target = module;

			  // get operations form target
			  Operation[] tops =
			      target.getOperationsWithName(
				  Operation.normalize(string));

			  boolean useOp = true;
                          Term term = null;

			  if (tops.length > 1) {

                              String msg = "module "+
					   target.getModuleName()+
					   " has no unique "+
                                           "operator "+string+".";
			      throw new ParseException(msg);

			  } else if (tops.length == 0) {

			      try {
				  // need to tokenize opName
				  StringTokenizer st =
				      new StringTokenizer(string);
				  String str = "";
				  while (st.hasMoreTokens()) {
				      String s = st.nextToken();
				      if (target.containsToken(s)) {
					  str += s+" ";
				      } else {
                                          String ss =
					      target.decomposeToken(s);
					  if (ss == null) {
					      str += s+" ";
					  } else {
					      str += ss+" ";
					  }
				       }
				  }
                                      
				  term = Term.parse(target, str);
				  useOp = false;

			      } catch (TermException ex) {

				  if (string.indexOf("_") == -1) {
				       tops = target.getOperationsWithCleanName(
					        string.trim());
				       if (tops.length != 1) {
				             String msg = "module "+	
						       target.getModuleName()+
						       " has no unique "+
                                                       "operator "+string;
			                     throw new ParseException(msg);
				       }
				  } else {
				       String msg = "module "+	
				            target.getModuleName()+
				            " has no operator "+string;
			                  throw new ParseException(msg);
                                  }
                               }
		           }

			   String viewName = "("+string.trim()+")"+".("+
					  module.modName+")";
		           if (!useOp && sops[0].isConstant()) {
                                viewName = "("+term+")"+".("+
					   module.modName+")";
                           }

                           View view = new View(viewName, source, target);
                           if (useOp) {
			       view.addOperationMap(sops[0], tops[0]);
                           } else if (sops[0].isConstant()) {
			       Term left = new Term(sops[0]);
			       view.addTransformation(left, term);
			   } else {
			       String msg = string+" is not a constant";
			       throw new ParseException(msg);
			   }   
                            
                           view.validate();
			   target.setProperty("view", view);	

		           flags.addElement(null);
		           modules.addElement(module);	

			   views.addElement(view);

                      }  catch (ViewException e) {
                           String msg = e.getMessage()+"  at line "+
				        token.beginLine+", column "+
				        token.beginColumn;

	                   if (detail) {
	                        msg = "format:"+format(msg, 0)+"\n"+
		                      "the failed view is\n"+e.getView();
                           }

			   throw new ParseException(msg);
		      } catch (Exception e) {
                            String msg = e.getMessage()+"  at line "+
				         token.beginLine+", column "+
				         token.beginColumn;
			    throw new ParseException(msg);
                      }
	         }
             |

             LOOKAHEAD("(" (   <IDENTIFIER>
                             | <INTEGER_LITERAL>
                             | <SYMBOL>
                             | MetaToken()
                             | "(" OpName() ")"
                           )+
                       ")" <IDENTIFIER>)
                     {
		        String opName = null;
			String stModName = null;
			String tmp;
	             }
                "("
                     (
                        (
                        token=<IDENTIFIER>
      	                    {
                                if (opName == null) {
				   opName = token.image;
			        } else {
				   opName += " "+token.image;
                                }
			    }
                        |
		        token=<INTEGER_LITERAL>
      	                    {   
                                if (opName == null) {
				   opName = token.image;
			        } else {
				   opName += " "+token.image;
                                }   
			    }
                        |
			token=<SYMBOL>
      	                    {
                                if (opName == null) {
				   opName = token.image;
			        } else {
				   opName += " "+token.image;
                                }   
			    }
                        |
			token=MetaToken()
			    {
                                if (opName == null) {
				   opName = token.image;
			        } else {
				   opName += " "+token.image;
                                }   
			    }
                        |
			"(" tmp=OpName()
			       {
                                  if (opName == null) {
                                      opName = " ( "+tmp+" ) ";
                                  } else {
				      opName += " ( "+tmp+" ) ";
                                  }
			       }
                        ")"
                        )

                     )+
                 ")"
                 token=<IDENTIFIER>
                    {
		        stModName = token.image;
			if (stModName.startsWith(".")) {
		            stModName = stModName.substring(1);

		            module = getModule(stModName);
			    if (module == null) {
                                String msg = "No module has the name "+
					      stModName+"  at line "+
				              token.beginLine+", column "+
				              token.beginColumn;
			        throw new ParseException(msg);
			    }
	                    

			    // in this case, make sure
                            // formal parameter is a single operator modules

                            try {

				Module source;

				View vi = (View)mainMod.getProperty("view"); 
				if (vi != null && vi.main != null) {
				    source = vi.main.getParameterAt(index);
				} else {
		                    source = mainMod.getParameterAt(index);
			        }


			        Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
				if (sops.length != 1) {
                                    String msg = "module "+
						 source.getModuleName()+
						 " doesn't have a single "+
                                                 "operator";
			            throw new ParseException(msg);
			        }
				if (!source.isParameterized()) {
				    Module m = source;
			            for (int i=0; i<views.size(); i++) {
				        vi = (View)views.elementAt(i);

                                        String paraName =
                                            mainMod.getParameterNameAt(i);
				        vi = vi.addNotation(paraName,
						            null,
						            getEnv());

				        if (m.containsAnnotation(paraName)) {
				            m.importModule(vi.target);
				            m = vi.getImage(m);

                                            m = m.changeModuleName(
				                  vi.source.modName,
				                  vi.target.modName,
					          m.modName);			
		    
                                            sops[0] = vi.getImage(sops[0]);
                                            sops[0] =
                                               sops[0].changeModuleName(
						      vi.source.modName,
				                      vi.target.modName);
				        }                                 
			            }

			            source = m;
                                }

			        Module target = module;

				boolean useOp = true;
                                Term term = null;

				Operation[] tops =
				    target.getOperationsWithName(
					Operation.normalize(opName));

				if (tops.length > 1) {

				    ArrayList list = new ArrayList();
				    for (int i=0; i<tops.length; i++) {
				       if (tops[i].hasSameSignature(sops[0])) {
					  list.add(tops[i]);
				       }
                                    }

				    if (list.size() != 1) {
                                       String msg = "module "+
						    target.getModuleName()+
						    " has multiple "+
                                                    "operator "+opName ;
			               throw new ParseException(msg);
                                    } else {
				       tops[0] = (Operation)list.get(0);
				    }
			        } else if (tops.length == 0) {

			            try {

				       // need to tokenize opName
				       StringTokenizer st =
				           new StringTokenizer(opName);
				       String str = "";
				       while (st.hasMoreTokens()) {
					  String s = st.nextToken();
					  if (target.containsToken(s)) {
					     str += s+" ";
					  } else {
                                             String ss =
						target.decomposeToken(s);
					     if (ss == null) {
						str += s+" ";
					     } else {
						str += ss+" ";
					     }
					  }
				       }
                                       opName = str;

				       term = Term.parse(target, opName);
				       useOp = false;
				    } catch (TermException ex) {

				       if (opName.indexOf("_") == -1) {
				          tops =
                                             target.getOperationsWithCleanName(
					        opName.trim());
				          if (tops.length != 1) {
				             String msg = "module "+	
						       target.getModuleName()+
						       " has no unique "+
                                                       "operator "+opName;
			                     throw new ParseException(msg);
					  }
				       } else {

				          String msg = "module "+	
						       target.getModuleName()+
						       " has no "+
                                                       "operator "+opName;
			                  throw new ParseException(msg);
                                       }
                                    }
		                } 

				/*
			        Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
				if (sops.length != 1) {
                                    String msg = "module "+
						 source.getModuleName()+
						 " doesn't have a single "+
                                                 "operator";
			            throw new ParseException(msg);
			        }
                                */

				String viewName = "("+opName.trim()+")"+"."+
						  stModName;
				if (!useOp && sops[0].isConstant()) {
                                    viewName = "("+term+")"+"."+
						  stModName;
                                }

                                View view = new View(viewName, source, target);

			        if (useOp) {
			           view.addOperationMap(sops[0], tops[0]);
                                } else if (sops[0].isConstant()) {
				   Term left = new Term(sops[0]);
			           view.addTransformation(left, term);
			        } else {
				   String msg = opName+" is not a constant";
			           throw new ParseException(msg);
			        }

                                view.validate();
                                target.setProperty("view", view);	

		                flags.addElement(null);
		                modules.addElement(module);	

				views.addElement(view);

			        index++;

                            } catch (ViewException e) {

                                String msg = e.getMessage()+" at line "+
				             token.beginLine+", column "+
				             token.beginColumn;

	                        if (detail) {
	                            msg = "format:"+format(msg, 0)+"\n"+
		                          "the failed view is\n"+e.getView();
                                }
			        throw new ParseException(msg);
		            } catch (Exception e) {
                                String msg = e.getMessage()+" at line "+
				             token.beginLine+", column "+
				             token.beginColumn;
			        throw new ParseException(msg);
                            }

                   } else {
                            String msg = "expect \".\" at line "+
				         token.beginLine+", column "+
				         token.beginColumn;
			    throw new ParseException(msg);
			}
                    }
               |
               (module=ModExpr(mod))
                  {
	              modules.addElement(module);
		      String flag = (String)module.getProperty("parameter");
		      flags.addElement(flag);

		      if (flag != null) {
                         module.removeProperty("parameter");
		      }

		      // handle dependent type
                      try {

                     	Module parameter;
		     	View vi = (View)mainMod.getProperty("view"); 
		     	if (vi != null && vi.main != null) {
			    parameter = vi.main.getParameterAt(index);
		        } else {
		            parameter = mainMod.getParameterAt(index);

			    // this parameter maybe not right
			    // should check it at first

                            if (!parameter.isParameterized()) {
                                Module tmp = parameter;
	
			        for (int i=0; i<views.size(); i++) {
				    vi = (View)views.elementAt(i);
								
                                    String paraName =
                                        mainMod.getParameterNameAt(i);
				    vi = vi.addNotation(paraName,
							null,
						        getEnv());

				    if (tmp.containsAnnotation(paraName)) {
				        tmp.importModule(vi.target);
				        tmp = vi.getImage(tmp);

                                        ModuleName tmpName = tmp.modName;
					tmpName = tmpName.changeModuleName(
						    vi.source.modName,
						    vi.target.modName);

                                        tmp = tmp.changeModuleName(
				               vi.source.modName,
				               vi.target.modName,
					       tmpName);

				    }                                 
			        }

			        parameter = tmp;
                            } 
                        }

		        View view = (View)module.getProperty("view");

	                if (view == null) {
		            view = module.getViewFor(parameter);
			    if (view == null) {
				 String msg = module.getModuleName()+
				              " is not an instance of "+
				              parameter.getModuleName();
		                 throw new ParseException(msg);
			    }
                        }

                        views.addElement(view);
			module.setProperty("view", view);

	              } catch (Exception e) {
                        String msg = e.getMessage()+"  at line "+
				     token.beginLine+", column "+
				     token.beginColumn;
			throw new ParseException(msg);
		      }  

		      // end handling

                      index++;

	           }
                |

                   {

                       Module source = null;
                       try {
	 	           source = mainMod.getParameterAt(index);

			   if (!source.isParameterized()) {
                               Module tmp = source;

			       for (int i=0; i<views.size(); i++) {
				    View vi = (View)views.elementAt(i);
                                    String paraName =
                                        mainMod.getParameterNameAt(i);
				    vi = vi.addNotation(paraName,
						        null,
							getEnv());

                                    if (tmp.containsAnnotation(paraName)) {

				        tmp.importModule(vi.target);
                                        tmp = vi.getImage(tmp);

				        /*
			                tmp = tmp.changeModuleName(
				                 new ModuleName(paraName),
				                 vi.target.modName,
					         tmp.modName);
				        */
				
					ModuleName tmpName = tmp.modName;
					tmpName = tmpName.changeModuleName(
						    vi.source.modName,
						    vi.target.modName);

                                        tmp = tmp.changeModuleName(
				                  vi.source.modName,
				                  vi.target.modName,
					          tmpName);

				    }     

			       }

		               source = tmp;

			    } else {

				// bug fix: 2002 6 6

		                // handle dependent type

			        // this parameter maybe not right
			        // should check it at first

				// create correct module name
                                Module tmp = source;
			        for (int i=0; i<views.size(); i++) {
				   View vi = (View)views.elementAt(i);

                                   String paraName =
                                        mainMod.getParameterNameAt(i);
				   vi = vi.addNotation(paraName,
						       null,
						       getEnv());
				   tmp.importModule(vi.target);
				   tmp = vi.getImage(tmp);

                                   ModuleName tmpName = tmp.modName;
			           tmpName = tmpName.changeModuleName(
					  vi.source.modName,
				          new ModuleName(vi.name));

				   tmp = tmp.changeModuleName(vi.source.modName,
				                              new ModuleName(vi.name),
						              tmpName);

                                }

			        source = tmp;
                                // end handling

			    }


                       } catch (Exception e) {
                           token = getToken(0);
                           String msg = e.getMessage()+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                           throw new ParseException(msg);
		       }

	           }
                module=LocalViewDecl(mod, source, views)
		   {

                       flags.addElement(null);
		       modules.addElement(module);
		       index++;

                       views.addElement(module.getProperty("view"));
	           }
              )
          )*
      "]"
            {
                module = mainMod;

                // setup actual parameters
                Module[] parameters = new Module[modules.size()];
                modules.copyInto(parameters);

                // setup flags for the actual parameters
                String[] notations = new String[flags.size()];
		flags.copyInto(notations);

	        // handle parameterized view
		View view = (View)module.getProperty("view");
		if (view != null && view.main != null) {

		    try {
	                view = view.instanceBy(parameters,
					       notations,
					       getEnv());

		    } catch (Exception e) {
		        String msg = e.getMessage();
   	                msg += " at line "+token.beginLine+", column "+
			       token.endColumn+".";
        	        throw new ParseException(msg);
                    }
		    module = view.target;
		    module.setProperty("view", view);

	        } else {

                   try {
			boolean highOrder = false;
			if (mod != null) {
			    highOrder = mod.isSecondOrder();
			}

            	        module = module.instanceBy(parameters,
						   notations,
						   getEnv(),
						   highOrder);


     	           } catch (ModuleInstanceException e) {

		        //e.printStackTrace();

   	                String msg = e.getMessage();
   	                msg += " at line "+token.beginLine+", column "+
			       token.endColumn+".";
        	        throw new ParseException(msg);
                   } 
                }
            }
       )

   )*
      {
	   return module;
      }
}




Module RenameElt(ModuleName modName, Module mod, Map map) :
{
    Token token;
    Sort sourceSort, targetSort;
    String source, target;
    Module module = null ;
}
{
 (
   "sort"
   sourceSort = SortReference(mod)
        {
             if (sourceSort == null) {
                   String msg = sourceSort+" "+
                                "is not found in the "+
			        "module "+mod.getModuleName()+
                                "at line "+getToken(0).beginLine;
		   throw new ParseException(msg);
             }
         }
   "to"
   token = <IDENTIFIER>
       {
	   
            try {
                if (sourceSort.isHidden()) {
                    targetSort =
                       new HiddenSort(token.image, mod.getModuleName());
	        } else if (sourceSort.isInitial()) {
                    targetSort =
                       new InitialSort(token.image, mod.getModuleName());
                } else {
                    targetSort = new Sort(token.image, mod.getModuleName());
                }

                module = mod.changeSort(modName, sourceSort, targetSort);
                map.put(sourceSort, targetSort);

            } catch (SignatureException e) {

                String msg = e.getMessage()+
                             "at line "+getToken(0).beginLine;
		throw new ParseException(msg);
            }
       }

 |

    "op" 
    (
        source=OpNameNoComma()
        |
        "(" source=OpNameNoComma() ")"
    )
        {

              Operation[] ops = mod.getOperationsWithName(source.trim());
              if (ops.length == 0) {

	           String msg = "op "+source.trim()+" "+
                                "is not found in the "+
			        "module "+mod.getModuleName()+
                                " at line "+getToken(0).beginLine;
		   throw new ParseException(msg);

              }
         }
    "to" 
    (
        target=OpNameNoComma()
        |
        "(" target=OpNameNoComma() ")"
    )    
        {
             try {


                 for (int i=0; i<ops.length; i++) {

                     Operation sourceOp = ops[i];
                     Operation targetOp =sourceOp.replaceOperationName(target);

		     if (i == 0) {
                         module = mod.replaceOperation(modName,
                                                       sourceOp,
                                                       targetOp);
                     } else {
			 module = module.replaceOperation(modName,
                                        	          sourceOp,
                                                          targetOp);
	             }
	            
		      map.put(sourceOp, targetOp);
                  }
             } catch (SignatureException e) {
                String msg = e.getMessage()+
                             "at line "+getToken(0).beginLine;
		throw new ParseException(msg);
            }
        }
  )
        {
            return module;
        }
}




Sort SortReference(Module module) :
{
    Token token;
    ModuleName modName = null;
    Module mod = null;
}
{
    (
       token=<IDENTIFIER>
       |
       token=<INTEGER_LITERAL>
    )
       {
	  boolean okay = false;
	  try {
	     Token t1 = getToken(1);
	     if (t1.next != null &&
		 t1.next.beginLine == t1.beginLine &&
		 t1.endColumn + 1 == t1.next.beginLine) {
	        okay = true;
	     }	
	  } catch (Exception e) {
	
	  }
       }
    [ LOOKAHEAD( //"." ModExpr()
               	 { okay }
	       )
      "." mod=ModExpr(module) ]
        {
            int index = token.image.indexOf(".");
            if (index != -1) {
	        
		String modRef = token.image.substring(index+1);
                modName = new ModuleName(modRef);
                Sort sort = new Sort(token.image.substring(0, index),
				     modName); 
                sort = module.getSort(sort);

		if (sort == null && paraPool.containsKey(modRef)) {
	            Module para = (Module)paraPool.get(modRef);
		    modName = para.getModuleName().addAnnotation(modRef);
                    sort = new Sort(token.image.substring(0, index),
				    modName); 
                    sort = module.getSort(sort);

	        }

	        if (sort == null) {

   	             String msg = "No sort with name "+token.image+
	                          " was found in the module "+
			          module.getModuleName()+" "+
   	                          "at line "+token.beginLine+", column "+
			          token.endColumn+".";

        	     throw new ParseException(msg);


	        } else {
	            return sort;
                }

            } else if (mod != null) {

		Sort sort = new Sort(token.image,
				     mod.getModuleName()); 
                sort = module.getSort(sort);

	        if (sort == null) {

   	             String msg = "No sort with name "+token.image+
	                          " was found in the module "+
			          module.getModuleName()+" "+
   	                          "at line "+token.beginLine+", column "+
			          token.endColumn+".";

        	     throw new ParseException(msg);


	        } else {
	            return sort;
                }
	
            } else {

	        Sort[] sorts = module.getSortsByName(token.image);
	        if (sorts.length == 0) {

   	             String msg = "No sort with name "+token.image+
	                          " was found in the module "+
			          module.getModuleName()+" "+
   	                          "at line "+token.beginLine+", column "+
			          token.endColumn+".";
        	     throw new ParseException(msg);

	        } else if (sorts.length == 1) {

                     return sorts[0];

                } else {
   	              String msg = sorts.length+" sorts with name "+
                                   token.image+" was found in the module "+
			           module.getModuleName()+" at line "+
                                   token.beginLine+", column "+
                                   token.endColumn+".";
        	      throw new ParseException(msg);
                 }
	   }
       }
}




ModuleName ModuleReference(Module module) :
{
    Token token;
}
{
    token=<IDENTIFIER>
	{
	     return new ModuleName(token.image);
	}
}



String ModId():
{
  Token token;
}
{

  (
     token=<IDENTIFIER>
     |
     token=<INTEGER_LITERAL>
  )
       {
            return token.image; 
       }       
}


void ModElt(Module module) :
{}
{
  (
     LOOKAHEAD(2)
     (
          ProtectedImport(module)
          |
          ExtendedImport(module)
          |
          UsedImport(module)	
          |
          SortsDecl(module)
          |
          SubsortDecl(module)
          |
          VarDecl(module)
          |
          VarImport(module)
          |
          OperationDecl(module)
          |
          EquationDecl(module)
          |
          DefDecl(module)
          |
          MembershipDecl(module) 
          |
          LetDecl(module)
          |
          "***>"
	    {
               boolean found = false;
               String msg = "";
               while (!found) {
                 try {
	            char more = jj_input_stream.readChar();
	            found = more == '\n';
	            msg += more;
                 } catch (IOException e) {
		    found = true;
	            msg += "\n";
	         }
	       }

               try {
                  if (mode == FILE_INPUT)
                      writer.write("====================="+
                                   "=====================\n");
	          writer.write("***> "+msg);
                  writer.flush();
               } catch (IOException e) {
		  throw new ParseException(e.getMessage()+" at line "+
					   getToken(0).beginLine+".");
	       }
            }


     )
          {
	      cobasisUpdated = true;
          }
  )+
}



void ProtectedImport(Module module) :
{
  Module mod;
  Token token;
}
{
   ("pr" | "protecting" )
   (
       LOOKAHEAD(<IDENTIFIER> "is") 
       ( (token=<IDENTIFIER>) "is" (mod=ModExpr(module)) )
	   {
               try {
                  
                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\n");
		       writer.write("protecting "+token.image+" is "+
				    mod.getModuleName()+"\n");
	               writer.flush();
                   }                

		   String notation = (String)mod.getProperty("notation");
	           if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
	               mod = mod.changeModuleName(mod.modName, nname, nname);
	           }

		   ModuleName nname = new ModuleName(token.image);
		   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
	           module.protectedImport(mod);
	        
                   saveModule(mod);	   

               } catch (Exception e) {
	           Token xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   throw new ParseException(msg);           
               }
	   }
      |
      (
         (mod=ModExpr(module))
         {
             try {

		 String notation = (String)mod.getProperty("notation");
	         if (notation != null) {
	             mod = mod.addAnnotation(notation, getEnv());
	         }
		
                 module.protectedImport(mod);

                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
		     writer.write("protecting "+mod.getModuleName()+"\n");
	             writer.flush();
                 }       

             } catch (Exception e) {
                 Token xt = getToken(0);
                 String msg = e.getMessage();
                 msg +=" at line "+xt.beginLine+".";
                 throw new ParseException(msg);                   
             }
         }
     )*

  )
   "."
}



void ExtendedImport(Module module) :
{
  Module mod;
  Token token, xt;
}
{
  (xt="ex" | xt="extending" )
  (
       LOOKAHEAD(<IDENTIFIER> "is") 
       ( (token=<IDENTIFIER>) "is" (mod=ModExpr(module)) )
	   {
               try {

                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\n");
		       writer.write("using "+token.image+" is "+
				    mod.getModuleName()+"\n");
	               writer.flush();
                   }                


		   String notation = (String)mod.getProperty("notation");
	           if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
	               mod = mod.changeModuleName(mod.modName, nname, nname);
	           }

		   ModuleName nname = new ModuleName(token.image);
		   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
	           //module.usedImport(mod);
	           module.protectedImport(mod);

                   saveModule(mod);	  

               } catch (Exception e) {
	           xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   throw new ParseException(msg);           
               }
	   }
   |
   (
      (mod=ModExpr(module))
        {
             try {

		 String notation = (String)mod.getProperty("notation");
	         if (notation != null) {
	             mod = mod.addAnnotation(notation, getEnv());
	         }

	         module.extendedImport(mod);
                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
		     writer.write("extending "+mod.getModuleName()+"\n");
	             writer.flush();
                 }       


             } catch (Exception e) {
                 String msg = e.getMessage();
                 msg +=" at line "+xt.beginLine+".";

                 throw new ParseException(msg);        
             }
        }
   )*
   )
   "."
}




void UsedImport(Module module) :
{
  Module mod;
  Token token, xt;
}
{
   (xt="us" | xt="using" | xt="inc" | xt="including" )

   (
       LOOKAHEAD(<IDENTIFIER> "is") 
       ( (token=<IDENTIFIER>) "is" (mod=ModExpr(module)) )
	   {
               try {

                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\n");
		       writer.write("using "+token.image+" is "+
				    mod.getModuleName()+"\n");
	               writer.flush();
                   }                


		   String notation = (String)mod.getProperty("notation");
	           if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
	               mod = mod.changeModuleName(mod.modName, nname, nname);
	           }

		   ModuleName nname = new ModuleName(token.image);
		   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
	           //module.usedImport(mod);
	           module.protectedImport(mod);

                   saveModule(mod);	  



               } catch (Exception e) {
	           xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   throw new ParseException(msg);           
               }
	   }
   |


   (
      (mod=ModExpr(module))
        {
             try {

		 String notation = (String)mod.getProperty("notation");
	         if (notation != null) {
	             mod = mod.addAnnotation(notation, getEnv());
	         }

                 module.usedImport(mod);
                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
		     writer.write("including "+mod.getModuleName()+"\n");
	             writer.flush();
                 }      

              } catch (Exception e) {
                  String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  throw new ParseException(msg);        
              }
        }
   )*
   [ "with"  (<IDENTIFIER>)+ ]

   )
   "."
}




void SortsDecl(Module module) :
{
  Token token;
  Sort sort = null;
}
{
  
     ("sort" | "sorts")
        
     (
        (  token=<IDENTIFIER>
           |
	   token=<INTEGER_LITERAL>
        )
             {

	          if (module.isBehavorial()) {
	              sort = new HiddenSort(token.image,
                                            module.getModuleName());
	          } else if (module.isInitial()) {
                      sort = new InitialSort(token.image,
                                            module.getModuleName());	    
	          } else {
                      sort = new Sort(token.image,
                                      module.getModuleName());	
                  }

                  module.addSort(sort);

		  // make sort is a subsort of Universal
                  try {
		      module.addSubsort(BoolModule.univSort, sort);
                  } catch (Exception e) {}

             }
     )+
     "."
        
   |

     ("dsort" | "dsorts")
           {
                if (!module.isBehavorial()) {
	             Token xt = getToken(0);
	             String msg = "\"dsort\" only can be used in bth,";
                     msg += " at line "+xt.beginLine+", column "+
                            xt.beginColumn+".";
                     throw new ParseException(msg);
	        }
           }
     (
       token=<IDENTIFIER>
           {
	         sort = new Sort(token.image, module.getModuleName());
                 module.addSort(sort);
           }
     )*

     "."

}





void SubsortDecl(Module module) :
{
     List small = new ArrayList();
     List big = new ArrayList();
     Sort sort;
}
{
  ("subsorts" | "subsort")
          {
	     Token token = getToken(0);
	  }
  (
     sort=SortReference(module)  
           {
               small.add(sort);
           }
  )+

  (
     "<"

     (
         sort=SortReference(module)
            {
	        big.add(sort);
	    }
     )+

     {

         try {
             for (int i=0; i<small.size(); i++) {
                Sort s = (Sort)small.get(i);
                for (int j=0; j<big.size(); j++) {
                    Sort b = (Sort)big.get(j);
                    module.addSubsort(b,s);
                }
             }

             small = big;
             big = new ArrayList();

         } catch (SignatureException e) {
             String msg =" at line "+token.beginLine+".";
             throw new ParseException(e.getMessage()+msg);          
         }
     }    
   )+
   "."

}




void VarImport(Module module) :
{
    String name = null;
    Token token;
}
{
   "vars-of"
        {
            token = getToken(0);
        }
   [ name=ModId() ]
   "."
        {
          try {

	     Module tmp = null;

             if (name != null) {

                ModuleName modName = new ModuleName(name);

                Enumeration enum_ = modPool.keys();
                while (enum_.hasMoreElements()) {
	            ModuleName key = (ModuleName)enum_.nextElement();
                 
                    if (key.equals(modName)) {
                        tmp = (Module)modPool.get(key);
                        break;
                    } 
                }

                if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
		     writer.write("vars-of "+name+"\n");
	             writer.flush();
                }

             } else {
		tmp = dynmaicModule != null ? dynmaicModule : lastModule ;

                if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\n");
		     writer.write("vars-of\n");
	             writer.flush();
                }                
             }
	    
	     if (tmp == null) {
                String msg = "no module "+name+" is found";
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                throw new ParseException(msg);
             }

             Variable[] vars = tmp.getVariables();

             try {

                for (int i=0; i<vars.length; i++) {
                    module.addVariable(vars[i]);
                }

             } catch (SignatureException e) {
                String msg = e.getMessage();
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                throw new ParseException(msg);
             }

	  } catch (IOException e) {
                String msg = e.getMessage();
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                throw new ParseException(msg);
          }
       }

}



void VarDecl(Module module) :
{
    List varNames = new ArrayList();
    List tokens = new ArrayList();
    Token token;
    Sort sort;
}
{
   ("var" | "vars")
   (  (token=<IDENTIFIER>)
         {
             varNames.add(token.image);
	     tokens.add(token);
         }
     |
       (token=<QUIT>)
         {
             varNames.add(token.image);
	     tokens.add(token);
         }
   )+
   ":"
   sort=SortReference(module)
   "."
         {
              for (int i=0; i<varNames.size(); i++) {
                   String name = (String)varNames.get(i);
                   token = (Token)tokens.get(i);

                   try {
                        Variable var = new Variable(name, sort);
                        module.addVariable(var);
                   } catch (SignatureException e) {
	                String msg = e.getMessage();
                        msg +=" at line "+token.beginLine+
                              ", column "+token.beginColumn+".";
                        throw new ParseException(msg);  	          
                   }
               }

               try {
                   if (dynmaicModule != null && mode == FILE_INPUT) {
                        writer.write("======================="+
                                     "===================\n");
                        if (varNames.size() > 1) {
                             writer.write("vars ");
		             for (int i=0; i<varNames.size(); i++) {
                                 writer.write(varNames.get(i)+" ");
			     }
                             writer.write(": "+sort.getName()+"\n");
                             writer.flush();
                         } else {
                             writer.write("var "+varNames.get(0)+" : "+
				          sort.getName()+"\n");
                             writer.flush();
		         }
                    }
               } catch (Exception e) {
                    String msg = e.getMessage();
                    msg += " at line "+token.beginLine+
                           ", column "+token.beginColumn+".";
                           throw new ParseException(msg);
               }
         }
}



Operation[] OperationDecl(Module module) :
{
      String opName = "";
      Sort sort;
      Vector argSorts = new Vector();
      Sort resSort = null;
      Vector opVt = new Vector();
      Operation op = null;
      Vector ops = new Vector();

      boolean behaviorial = false;

      Token token, xt;
      int beginLine = 0;
      ModuleName modName = module.getModuleName();
}
{
    xt="op"
    (   opName=OpName()
        |
        ( "(" opName = OpName() ")" )
    )
    ":"
    (
        sort=SortReference(module)
           {
	       argSorts.addElement(sort);
	   }
    )*
    "->"
    resSort= SortReference(module)
           {
               Sort[] args = new Sort[argSorts.size()];
               argSorts.copyInto(args);

	       if (module.hasOperation(opName, args, resSort)) {
                   try {
		      writer.write("======================="+
                                   "===================\n");
                      writer.write("Warning: operation "+opName.trim()+
				   " is already defined at line "+
				   xt.beginLine+"\n");
                      writer.flush();

	              op = new Operation(opName, args, resSort, modName);
                      opVt.addElement(op);

                   } catch (IOException e) {
		      throw new ParseException(e.getMessage());
		   } catch (SignatureException e) {
	              String msg = e.getMessage();
                      msg +=" at line "+xt.beginLine+".";
                      throw new ParseException(msg);  	       
                   }


	       } else {

                  try {
	              op = new Operation(opName, args, resSort, modName);

                      /*
	              if (module.hasCompatibleOperation(op)) {

                          writer.write("======================="+
                                       "===================\n");
                          writer.write(format("Warning: operation "+
				       op.getCleanName().trim()+
				       " overwrites some opeartions"+
				       " from other modules at line "+
				       xt.beginLine, 0)+"\n");
                          writer.flush();

	              }
	              */

                      opVt.addElement(op);

                  } catch (SignatureException e) {
	              String msg = e.getMessage();
                      msg +=" at line "+xt.beginLine+".";
                      throw new ParseException(msg);  	       
                  }
               }
           }
    [ "[" (OpProperty(opVt, module))+ "]" ]
    "."
        {
             try {
                  for (int i=0; i<opVt.size(); i++) {
                     op = (Operation)opVt.elementAt(i);
                     module.add(op);
                  }

                  if (dynmaicModule != null && mode == FILE_INPUT) {
                      writer.write("======================="+
                                   "===================\n");
                      writer.write(module.toString(op)+"\n");
                      writer.flush();
                  }

              } catch (Exception e) {
	          String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  throw new ParseException(msg);  	       
              }

	      Operation[] result = new Operation[opVt.size()];
              for (int i=0; i<opVt.size(); i++) {
                  result[i] = (Operation)opVt.elementAt(i);
              }
	      return result;
      }

 |

    xt="op-as"
    (
        opName=OpName()
        |
        "(" opName = OpName() ")" 
              {
	          opName = "( "+opName+" ) ";
	      }
    )
    ":"
    (
       {
          xt = getToken(0);
          beginLine = xt.beginLine;
       }
       sort = SortReference(module)
           {     
                argSorts.addElement(sort);
           }          
      
    )*
    "->"
    resSort = SortReference(module)
          {
             try {
                  args = new Sort[argSorts.size()];
	          argSorts.copyInto(args);

	          if (module.hasOperation(opName, args, resSort)) {
                      try {
		          writer.write("======================="+
                                       "===================\n");
                          writer.write("Warning: operation "+opName+
				       " is already defined at line "+
				       xt.beginLine+"\n");
                          writer.flush();
                      } catch (IOException e) {
		          throw new ParseException(e.getMessage());
		      }
	          } else {
                      op = new Operation(opName,args, resSort, modName);
                      opVt.addElement(op);
                  }

             } catch (SignatureException e) {
                  xt = getToken(0);
	          String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  throw new ParseException(msg);  	       
             }
          }       

    (<IDENTIFIER> | <SYMBOL> | "of" | "(" | ")" | "in" | "," )+

    [ "[" (OpProperty(opVt, module))+ "]" ]
    "."
     {
         try {
            for (int i=0; i<opVt.size(); i++) {
                op = (Operation)opVt.elementAt(i);
                module.add(op);
            }
         } catch (SignatureException e) {
	    String msg = e.getMessage();
            msg +=" at line "+beginLine+".";
            throw new ParseException(msg);  	       
         }

	 Operation[] result1 = new Operation[opVt.size()];
         for (int i=0; i<opVt.size(); i++) {
             result1[i] = (Operation)opVt.elementAt(i);
         }
	 return result1;

      }

 |
    
    "ops"
       {
          xt = getToken(0);
          beginLine = xt.beginLine;
       }
    /*
    (
       (
         "("
         (opName=OpName())
              {
                 ops.addElement(opName);
              }
         ")"
       )+
     |
       (
	  (opName=OpName())
             {
     	         StringTokenizer st = new StringTokenizer(opName, " ");
	         while (st.hasMoreTokens()) {
                     ops.addElement(st.nextToken());
	         }
             }
       )+
    )
    */

    (
       (
         "("
         (opName=OpName())
              {
                 ops.addElement(opName);
              }
         ")"
       )
     |
       (
	  (opName=OpName())
             {
     	         StringTokenizer st = new StringTokenizer(opName, " ");
	         while (st.hasMoreTokens()) {
                     ops.addElement(st.nextToken());
	         }
             }
       )
    ) +


    ":"
    (
       sort=SortReference(module)
           {
	       argSorts.addElement(sort);
	   }
    )*
    "->"
    resSort=SortReference(module)
          {
              args = new Sort[argSorts.size()];
              argSorts.copyInto(args);
	
              try {
	           for (int i=0; i<ops.size(); i++) {
	               opName = (String)ops.elementAt(i);


	               if (module.hasOperation(opName, args, resSort)) {
                          try {
		             writer.write("======================="+
                                          "===================\n");
                             writer.write("Warning: operation "+opName+
				          " is already defined at line "+
				          xt.beginLine+"\n");
                             writer.flush();
                          } catch (IOException e) {
		             throw new ParseException(e.getMessage());
		          }
	              } else {

	                 op = new Operation(opName, args, resSort, modName);
                         opVt.addElement(op);

                      }
                   }
              } catch (SignatureException e) {
	          String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  throw new ParseException(msg);  	       
              }
          }       
    [ "[" (OpProperty(opVt, module))+ "]" ]
    "."
      {
         try {

             for (int i=0; i<opVt.size(); i++) {
                 op = (Operation)opVt.elementAt(i);
                 module.add(op);
             }

             if (dynmaicModule != null && mode == FILE_INPUT) {
                 writer.write("==========================================\n");
		 writer.write("ops ");
	         for (int i=0; i<opVt.size(); i++) {
                     op = (Operation)opVt.elementAt(i);
                     if (i != opVt.size()-1) {
                         writer.write(op.name+" ");
                     } else {
                         writer.write(module.toString(op).substring(3)+"\n");
	             }
                 }
		 writer.flush();
	     } 

         } catch (Exception e) {
	     String msg = e.getMessage();
             msg +=" at line "+beginLine+".";
             throw new ParseException(msg);  	       
         }

         Operation[] result2 = new Operation[opVt.size()];
         for (int i=0; i<opVt.size(); i++) {
             result2[i] = (Operation)opVt.elementAt(i);
         }
	 return result2;

      }

}



String OpName() :
{
   String result = "";
   String tmp;
   Token token;
}
{

 (

  LOOKAHEAD(20)
  {
      Token tk = getToken(0);
      int endLine = tk.endLine;
      int endColumn = tk.endColumn;
  } 

  (
    (token=<IDENTIFIER>)
       {

          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
	    result = result.trim();
          }
	  result += token.image +" ";
	  
       }
  |
    (token=<INTEGER_LITERAL>)
       {
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
	    result = result.trim();
          }
	  result += token.image+" ";
       }
  | token=<OBJ>
       {
	  result += token.image+" ";
       }
  | token=<TH>
       {
	  result += token.image+" ";
       }
  | token=<BTH>
       {
	  result += token.image+" ";
       }
  | token=<DTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDO>
       {
	  result += token.image+" ";
       }
  | token=<ENDTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDB>
       {
	  result += token.image+" ";
       }
  | token=<ENDD>
       {
	  result += token.image+" ";
       }
  | token=<END>
       {
	  result += token.image+" ";
       }
  | token=<PR>
       {
	  result += token.image+" ";
       }
  | token=<PROTECTING>
       {
	  result += token.image+" ";
       }
  | token=<EX>
       {
	  result += token.image+" ";
       }
  | token=<EXTENDING>
       {
	  result += token.image+" ";
       }
  | token=<US>
       {
	  result += token.image+" ";
       }
  | token=<USING>
       {
	  result += token.image+" ";
       }
  | token=<BSORT>
       {
	  result += token.image+" ";
       }
  | token=<BSORTS>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORT>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORTS>
       {
	  result += token.image+" ";
       }
  |
    (token=<LESS>)
       {
	  result += token.image+" ";
       }
  |
    (token=<ARROW>)
       {
	  result += token.image+" ";
       }
  |
    (token=<VAR>)
       {
	  result += token.image+" ";
       } 
  |
    (token=<VARS>)
       {
          result += token.image+" ";
       }
  |
    (token=<SORT>)
       {
          result += token.image+" ";
       }
  |
    (token=<SORTS>)
       {
          result += token.image+" ";
       }
  |
    (token=<MAKE>)
       {
          result += token.image+" ";
       }
  |
    <IS>
       {
          result += "is ";
       }
  |
    <LET>
       {
	  result += "let ";
	}
  |
    <SUM>
       {
	  result += "|| ";
       }
  |
     <PARENS>
       {
	  result += "parens ";
       }
  |
     <INCLUDE>
       {
	  result += "include ";
       }
  |
     <REDUCTION>
       {
	  result += "result ";
       }
  |
     <INC>
       {
	  result += "inc ";
       }
  |
     <INCLUDING>
       {
	  result += "including ";
       }
  |
     <REDUCE>
       {
	  result += "reduce ";
       }
  |
     <TIME>
       {
	  result += "time ";
       }
  |
     <JBO>
       {
	  result += "jbo ";
       }
  |
     <ASSOCIATIVE>
       {
	  result += "associative ";
       }
  |
     <COMMUTATIVE>
       {
	  result += "commutative ";
       }
  |
     <IDEMPOTENT>
       {
	  result += "idempotent ";
       }
  |
     <HT>
       {
	  result += "ht ";
       }
  |
     <WEIV>
       {
	  result += "weiv ";
       }
  |
     <ENDVIEW>
       {
	  result += "endview ";
       }
  |
     <GATHERING>
       {
	  result += "gathering ";
       }
  |
     <PRECEDENCE>
       {
	  result += "precedence ";
       }
  |
     <THEORY>
       {
	  result += "theory ";
       }
  |
     <SH>
       {
	  result += "sh ";
       }
  |
     <LONGQUIT>
       {
	  result += "quit ";
       }
  |
     <OBJECT>
       {
	  result += "quit ";
       }
  |
     <DEFINE>
       {
	  result += "define ";
       }
  |
     <IDENTITY>
       {
	  result += "identity ";
       }
  |
     <INPUT>
       {
	  result += "input ";
       }
  |

    ","
       {
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
	    result = result.trim();
	  }
	  result += ", ";
       }
  |
    "+"
       {
	  result += "+ ";
       }
  |
    "*"
       {
	  result += "* ";
       }
  |
    "eq"
       {
	  result += "eq ";
       }
  |
    "q" 
       {
          result += "q ";
       }
  |
    "eof"
       {
	  result += "eof ";
	}
  |
    "select"
	{
	  result += "select ";
	}
  |
    "show"
	{
	  result += "show ";
	}
  |
    "set" 
       {
          result += "set ";
       }
  |
    "trace"
       {
	  result += "trace ";
	}
  |
    "on"
	{
	  result += "on ";
	}
  |
    "off"
	{
	  result += "off ";
	}
  |
    "full"
	{
	  result += "full ";
	}
  |
    "from"
	{
	  result += "from ";
	}
  |
    "of"
	{
	  result += "of ";
	}
  |
    "in"
        {
	  result += "in ";
	}
  |
    "apply"
        {
	  result += "apply";
	}
  |
    "within"
        {
	  result += "within";
	}
  |
    "at"
        {
	  result += "at";
	}
  |
    "print"
        {
	  result += "print";
	}
  |
    "start"
        {
	  result += "start";
	}
  |
    /*
    "[" (tmp=OpName()) "]" 
       {

          if (tmp.trim().startsWith("[") && tmp.trim().endsWith("]")) {
             tmp = "["+tmp.trim()+"] ";
          } else {
             tmp = "[ "+tmp.trim()+" ] ";
          }

          result += tmp;
       }
     */
     
     "["
          {
		  	 
	       char c = ' ';
	       String str = result.trim(); 
               boolean alphanum = false;
               if (str.length() > 0) {
		   c = str.charAt(str.length()-1);
                   alphanum = (c >= 'a' && c <= 'z') ||
			      (c >= 'A' && c <= 'Z');
	       }
         	
               tk = getToken(0);
               if (!alphanum &&
        	   tk.endLine == endLine &&
                   tk.beginColumn == endColumn+1) {
		   result = result.trim()+"[ ";
	       } else {
                   result = result+"[ ";
	       }
         
	  }
   |
     "]"
	  {
	      tk = getToken(0);
	      if (tk.endLine == endLine && tk.beginColumn == endColumn+1) {
		  result = result.trim()+"] ";
	      } else {
                  result = result+"] ";
	      }
	  }
       
  )
  [
     LOOKAHEAD(30)
     "("
         (tmp=OpName())
            {
	       result += "( "+tmp.trim()+" ) ";
            }
     ")"
  ]

 )+
     {
            return result;
     }
}






String SimpleOpName() :
{
   String result = "";
   String tmp;
   Token token;
}
{

 (

  LOOKAHEAD( { !getToken(1).image.equals("strat") &&
               !getToken(1).image.equals("strategy") &&
	       !getToken(1).image.equals("gather") &&
	       !getToken(1).image.equals("gathering") &&
	       !getToken(1).image.equals("]") &&
	       !getToken(1).image.equals("prec") &&
	       !getToken(1).image.equals("precedence") &&
	       !getToken(1).image.equals("assoc") &&
               !getToken(1).image.equals("associative") &&
	       !getToken(1).image.equals("comm") &&
               !getToken(1).image.equals("commutative") &&
	       !getToken(1).image.equals("idem") &&
               !getToken(1).image.equals("idempotent") &&
	       !getToken(1).image.equals("ncong") &&
	       !getToken(1).image.equals(")") }
           )
  {
      Token tk = getToken(0);
      int endLine = tk.endLine;
      int endColumn = tk.endColumn;
  } 
  (
    (token=<IDENTIFIER>)
       {

          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
	    result = result.trim();
          }
	  result += token.image +" ";
	  
       }
  |
    (token=<INTEGER_LITERAL>)
       {
	  result += token.image+" ";
       }

  | token=<OBJ>
       {
	  result += token.image+" ";
       }
  | token=<TH>
       {
	  result += token.image+" ";
       }
  | token=<BTH>
       {
	  result += token.image+" ";
       }
  | token=<DTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDO>
       {
	  result += token.image+" ";
       }
  | token=<ENDTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDB>
       {
	  result += token.image+" ";
       }
  | token=<ENDD>
       {
	  result += token.image+" ";
       }
  | token=<END>
       {
	  result += token.image+" ";
       }
  | token=<PR>
       {
	  result += token.image+" ";
       }
  | token=<PROTECTING>
       {
	  result += token.image+" ";
       }
  | token=<EX>
       {
	  result += token.image+" ";
       }
  | token=<EXTENDING>
       {
	  result += token.image+" ";
       }
  | token=<US>
       {
	  result += token.image+" ";
       }
  | token=<USING>
       {
	  result += token.image+" ";
       }
  | token=<BSORT>
       {
	  result += token.image+" ";
       }
  | token=<BSORTS>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORT>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORTS>
       {
	  result += token.image+" ";
       }
  |
    (token=<LESS>)
       {
	  result += token.image+" ";
       }
  |
    (token=<ARROW>)
       {
	  result += token.image+" ";
       }
  |
    (token=<VAR>)
       {
	  result += token.image+" ";
       } 
  |
    (token=<VARS>)
       {
          result += token.image+" ";
       }   
  |
    <IS>
       {
          result += "is ";
       }
  |
    <LET>
       {
	  result += "let ";
	}
  |
    <SUM>
       {
	  result += "|| ";
       }
  | <JBO>
       {
	  result += "jbo ";
       }
  | <HT>
       {
	  result += "ht ";
       }
  | <WEIV>
       {
	  result += "weiv ";
       }
  | <ENDVIEW>
       {
	  result += "endview ";
       }
  | <THEORY>
       {
	  result += "theory ";
       }
  | <SH>
       {
	  result += "sh ";
       }
  | <LONGQUIT>
       {
	  result += "quit ";
       }
  | <OBJECT>
       {
	  result += "object ";
       }
  | <DEFINE>
       {
	  result += "define ";
       }
  | <INPUT>
       {
	  result += "input ";
       }
  |

    ","
       {
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
	    result = result.trim();
	  }
	  result += ", ";
       }
  |
    "+"
       {
	  result += "+ ";
       }
  |
    "*"
       {
	  result += "* ";
       }
  |
    "eq"
       {
	  result += "eq ";
       }
  |
    "q" 
       {
          result += "q ";
       }
  |
    "eof"
       {
	  result += "eof ";
	}
  |
    "select"
	{
	  result += "select ";
	}
  |
    "show"
	{
	  result += "show ";
	}
  |
    "set" 
       {
          result += "set ";
       }
  |
    "trace"
       {
	  result += "trace ";
	}
  |
    "on"
	{
	  result += "on ";
	}
  |
    "off"
	{
	  result += "off ";
	}
  |
    "full"
	{
	  result += "full ";
	}
  |
    "from"
	{
	  result += "from ";
	}
  |
    "of"
	{
	  result += "of ";
	}
  |
    "in"
        {
	  result += "in ";
	}
 |
    "apply"
        {
	  result += "apply";
	}
  |
    "within"
        {
	  result += "within";
	}
  |
    "at"
        {
	  result += "at";
	}
  |
    "print"
        {
	  result += "print";
	}
  |
    "start"
        {
	  result += "start";
	}
  )

  [
     "("
         (tmp=OpName())
            {
	       result += "( "+tmp.trim()+" ) ";
            }
     ")"
  ]

 )+
     {
         return result;
     }
}






void OpProperty(Vector ops, Module module) :
{
  Token token, xt;
  String opname;
}
{
      "ncong"
        {
          
          for (int i=0; i<ops.size(); i++) {
              Operation op = (Operation)ops.elementAt(i);
              op.setBehavorial(false);
          }

        }        
   |
      ( "assoc" | "associative" )
        {
          
           try {
              for (int i=0; i<ops.size(); i++) {
                 Operation op = (Operation)ops.elementAt(i);
                 op.setAssociativity(module);
              }
           } catch (SignatureException e) {
               xt = getToken(0);
	       String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+
                     ", column "+xt.beginColumn+".";
               throw new ParseException(msg);
           }
        }
   |
      ( "comm" | "commutative" )
        {
           try {
              for (int i=0; i<ops.size(); i++) {
                Operation op = (Operation)ops.elementAt(i);
                op.setCommutativity(module);
              }
           } catch (SignatureException e) {
               xt = getToken(0);
	       String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+", column "+
                     xt.beginColumn+".";
               throw new ParseException(msg);
           }
        }
   |
      ( "idem" | "idempotent" )
        {
           try {
               for (int i=0; i<ops.size(); i++) {
                   Operation op = (Operation)ops.elementAt(i);
                   op.setIdempotence();
               }
           } catch (SignatureException e) {
               xt = getToken(0);
	       String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+", column "+
                     xt.beginColumn+".";
               throw new ParseException(msg);
           }
        }        
   |
     ("idr:" | "id:" | "identity" )
     (
        opname=SimpleOpName()
        |
	"(" opname=SimpleOpName() ")"
     )
        {

           Operation[] id = module.getConstants(opname.trim());
           for (int i=0; i<ops.size(); i++) {
               Operation op = (Operation)ops.elementAt(i);
               boolean found = false;
               for (int j=0; j<id.length && !found; j++) {
	           try {
                       op.setIdentity(id[j], module);
	               found = true;
                   } catch (SignatureException e) {}
               }

               if (!found) {
                   xt = getToken(0);
	           String msg = "Can't set identity for the operation "+
			        op.getName();
                   msg += " at line "+xt.beginLine+
                          ", column "+xt.beginColumn+".";
                   throw new ParseException(msg);
               } 
           }

        }
   |
      ( "prec" | "precedence" ) (token=<INTEGER_LITERAL>)
         {
            int prec = Integer.parseInt(token.image);
            for (int i=0; i<ops.size(); i++) {
                 Operation op = (Operation)ops.elementAt(i);
                 op.setPriority(prec);
            }
         }
   |
      "memo"
   |
      (token=<IDENTIFIER>)
         {
	     int kind = 0;

	     if (token.image.equals("gather") ||
		 token.image.equals("gathering")) {
		 kind = 1;
             } else if (token.image.equals("strat") ||
			token.image.equals("strategy") ) {
		 kind = 2;
	     } else {
	         String msg = "expect gather or gathering "+
                              "or strat or strategy";
                 msg +=" at line "+token.beginLine+
		       ", column "+token.beginColumn+".";
                 throw new ParseException(msg);
	      } 
	  }
      "("
           {
	       List list = new ArrayList();
	   }
       
	   (
              token=<IDENTIFIER>
                  {
		      if (kind == 2) {

			  try {
			    int aInt = Integer.parseInt(token.image);
			    list.add(token.image);
	                  } catch (Exception e) {

	                    String msg = "expect a natural number ";
                            msg +=" at line "+token.beginLine+
		                ", column "+token.beginColumn+".";
                            throw new ParseException(msg);
                          }
		      } else {

		         if (!token.image.equals("E") &&
		             !token.image.equals("e") &&
			     !token.image.equals("&")) {
		
	                     String msg = "expect E e &";
                             msg +=" at line "+token.beginLine+
		                   ", column "+token.beginColumn+".";
                             throw new ParseException(msg);
		         }

		         list.add(token.image);

		      }
		 }
              |
                 token=<INTEGER_LITERAL>
		     {
		         if (kind == 1) {
	                    String msg = "expect E e &";
                            msg +=" at line "+token.beginLine+
		                  ", column "+token.beginColumn+".";
                            throw new ParseException(msg);
		         }

		         list.add(token.image);			 
		     }
              )
	   (
              (
              
              token=<IDENTIFIER>
                  {
		      if (kind == 2) {


			  try {
			    int aInt = Integer.parseInt(token.image);
			    list.add(token.image);
	                  } catch (Exception e) {

       	                    String msg = "expect a natural number ";
                            msg +=" at line "+token.beginLine+
		                  ", column "+token.beginColumn+".";
                            throw new ParseException(msg);
                          }
		      } else {

		         if (!token.image.equals("E") &&
		             !token.image.equals("e") &&
			     !token.image.equals("&")) {
		
	                     String msg = "expect E e &";
                             msg +=" at line "+token.beginLine+
		                   ", column "+token.beginColumn+".";
                             throw new ParseException(msg);
		         }

		         list.add(token.image);

	              }
		  }
             |
                 token=<INTEGER_LITERAL>
		     {
		         if (kind == 1) {
	                    String msg = "expect E e &";
                            msg +=" at line "+token.beginLine+
		                  ", column "+token.beginColumn+".";
                            throw new ParseException(msg);
		         }

			 if (list.contains(token.image)) {
	                    String msg = token.image+" is defined in the "+
					 "strategy";
                            msg +=" at line "+token.beginLine+
		                  ", column "+token.beginColumn+".";
                            throw new ParseException(msg);
			 }

		         list.add(token.image);			 
		     }
              )

           )*

		{

                    if (kind == 1) {
     
		        String[] gather = new String[list.size()];
	                for (int i=0; i<gather.length; i++) {
		            gather[i] = (String)list.get(i);
		        }

	                for (int i=0; i<ops.size(); i++) {
        	             Operation op = (Operation)ops.elementAt(i);
                             try {
                	         op.setGather(gather);
                             } catch (SignatureException e) {
                                 String msg = e.getMessage();
                                 msg +=" at line "+token.beginLine+
		                       ", column "+token.beginColumn+".";
                                 throw new ParseException(msg);
			     }
           	        }

	            } else {

			int[] strategy = new int[list.size()];
		       	for (int i=0; i<strategy.length; i++) {
		           strategy[i] = Integer.parseInt((String)list.get(i));
		        }

	                for (int i=0; i<ops.size(); i++) {
        	             Operation op = (Operation)ops.elementAt(i);
                	     op.setStrategy(strategy);
			}			

		    }
              }

      ")"
}


void LetDecl(Module module) :
{
   Token t1, t2;
   String st;
}
{
   "let" 
   ( t1=<IDENTIFIER> | t1=<INTEGER_LITERAL> ) 
   t2=<IDENTIFIER> 
      {

          if (!t2.image.equals("=")) {
	      String msg = "Expect \"=\"  at line "+t2.beginLine+
                           ", column "+t2.beginColumn+".";
              throw new ParseException(msg);
          }
	
      }
  (st = Term(module)) 
    {
       try {

	   FastTermParser.debug = true;

           Term term = Term.parse(module, st);
           Operation op = new Operation( t1.image, 
                                         new Sort[0], 
                                         term.getSort(),
					 module.getModuleName());
           module.addOperation(op);
           module.addEquation(new Equation(new Term(module, op, new Term[0]),
                              term));

	   if (dynmaicModule != null && mode == FILE_INPUT) {
               writer.write("======================="+
                            "===================\n");
               writer.write("let "+t1.image+" = "+st+"\n");
               writer.flush();
           }   

       } catch (Exception e) {
           String msg = e.getMessage();
	   if (e instanceof TermException) {
	      msg += "\n";
           }
           msg +="at line "+t2.beginLine+".";
           throw new ParseException(msg);      
       }       
    }
  "."
}


void MembershipDecl(Module module) :
{
   String string = null;
   Token token;
}
{
   "mb"
       {
           token = getToken(0);
       }
   (string = Term(module))
       {


	   String termStr=null, sortName=null, cond=null;

           int l = -1;
           int r = -1;

           int count = 0;
           String tmp = string;
           while (!tmp.equals("")) {

               if (tmp.startsWith("(")) {
                   count++;
                   tmp = tmp.substring(1);
               } else if (tmp.startsWith(")")) {
	           count--;
                   tmp = tmp.substring(1);
               } else if (tmp.startsWith(" : ")) {

                   if (count == 0) {
                       l = string.length()-tmp.length();
                       termStr = string.substring(0, l);
                       tmp = tmp.substring(3);
                   } else {
                       tmp = tmp.substring(3);
                   }

               } else if (tmp.startsWith(" if ")) {

                   int k = tmp.indexOf(" then ");
                   if (count == 0 && k == -1) {

                        r = string.length()-tmp.length();
                        sortName = string.substring(l+3,r);
                        cond = tmp.substring(4);
                        tmp = "";
            
	           } else {
                        tmp = tmp.substring(4);
	           }

                } else {
                   tmp = tmp.substring(1);
                }
            }

	    if (cond == null) {
                sortName = string.substring(l+2).trim();
	    }


	    Term term = null, cterm = null;
            try {	
                term = Term.parse(module, termStr);
	
	        if (cond != null) {
	           cterm = Term.parse(module, cond);
	        }

            } catch (TermException e) {

                String eMsg = e.getMessage();
	        if (eMsg.startsWith("multiple parsing results")) {

                    int index = eMsg.indexOf("\n");
	            eMsg = eMsg.substring(index);

	            String msg = "format:There are "+e.getCount()+" parses"+
			         " for the term at line "+
                                 token.beginLine+":\n";
		    msg += "   mb "+string;
                    msg += "\nThe first 2 parse trees are:";
                    msg += eMsg;
                    throw new ParseException(msg);

                } else {

	            String msg = "format:no parse "+
			    "for the term at line "+token.beginLine+":\n";
	            msg += "   mb "+string;
	       	    throw new ParseException(msg);
	        }

	    }

            Sort[] sorts = module.getSortsByName(sortName);
	    if (sorts.length == 0) {

   	         String msg = "No sort with name "+token.image+
	                      " was found in the module "+
			      module.getModuleName()+" "+
   	                      "at line "+token.beginLine+".";
        	 throw new ParseException(msg);

	    } else if (sorts.length == 1) {

            } else {
   	          String msg = sorts.length+" sorts with name "+
                               token.image+" was found in the module "+
			       module.getModuleName()+" at line "+
                               token.beginLine+".";
        	  throw new ParseException(msg);
            }

	    // check var(cterm) \subset var(term)

            boolean wrong = false;
	    if (cond != null) {
	       Variable[] cvars = cterm.getVariables();
               
               for (int i=0; i<cvars.length; i++) {
                   if (!term.contains(cvars[i])) {
                      System.out.println("Warning at line "+
				      token.beginLine+": \n"+
                                      "The condition has variables "+
                                      "not in the term. \n"+
                                      "The membership definition"+
                                      " will be ignored for rewriting.");
		      wrong = true;
                   }
                }	    
            }

            // check subSort < superSort

            Sort superSort = term.getSort();
            Sort subSort = sorts[0];

	    if (!wrong && !module.less(subSort, superSort) &&
		 !subSort.equals(superSort)) {
   	          String msg = subSort.getName()+" is not a subsort of "+
			       superSort.getName()+" at line "+
                               token.beginLine+".";
        	  throw new ParseException(msg);
	    }

	   
            Term left = null, right = null;
	    try {

		if (!wrong && term.var == null) {
		   Operation sortOp = new Operation(sortName,
						 new Sort[]{},
						 BoolModule.univSort,
						 BOBJModule.getModuleName());
		   Term term2 = new Term(sortOp);	
		   Operation op = BOBJModule.getSetsortOperation();
		   right = new Term(module,
				    op,
				    new Term[]{term2, term});

		   Equation eq = (cond == null) ?
                                  new Equation(term, right) :
			          new Equation(cterm, term, right);
                   module.addEquation(eq);
               
	        } else if (!wrong) {

		   Sort[] args = new Sort[] { superSort };
		   Sort res = subSort;
		   Operation retOp = new Operation("r:"+superSort.getName()+
						   ">"+subSort.getName()+
						   "(_)",
						   args,
						   res,
						   BOBJModule.getModuleName());
		   retOp.info = "system-retract";
		    
		   left = new Term(module, 
				   retOp, 
				   new Term[] {term});

		   Operation sortOp = new Operation(sortName,
						    new Sort[]{},
						    BoolModule.univSort,
						   BOBJModule.getModuleName());
		   Term term2 = new Term(sortOp);
		   Operation op = BOBJModule.getSetsortOperation();
		   right = new Term(module,
				    op,
				    new Term[]{term2, term});

		   Equation eq = (cond == null) ?
                                 new Equation(left, right) :
			         new Equation(cterm, left, right);
                   module.addEquation(eq);

	        }

	    } catch (Exception e){

            }
       }
   "."
}


Equation EquationDecl(Module module) :
{
    String eq, name=null;
    Token xt;
    boolean conditional = false;
    Equation equat = null;
}
{
   [
      "["
      xt=<IDENTIFIER>
	   {
	       name = xt.image;
	   }
      "]"

   ]
   (  "eq"
    |
      "cq"
	  {
	     conditional = true;
	  }
    |
       "ceq"
          {
	     conditional = true;
          }
   )
       {
           xt = getToken(0);
       }
   (eq = Term(module))
       {

        String left = "";
        String right = "";
        String cond = "";

        int l = -1;
        int r = -1;

        int count = 0;
        String tmp = eq;
        while (!tmp.equals("")) {

          if (tmp.startsWith("(")) {

             count++;
             tmp = tmp.substring(1);

          } else if (tmp.startsWith(")")) {

	     count--;
             tmp = tmp.substring(1);

          } else if (tmp.startsWith(" = ")) {

             if (count == 0) {
                l = eq.length()-tmp.length();
                left = eq.substring(0, l);
                tmp = tmp.substring(3);
             } else {
                tmp = tmp.substring(3);
             }

          } else if (tmp.startsWith(" if ")) {

             int k = tmp.indexOf(" then ");
             if (count == 0 && k == -1) {

                r = eq.length()-tmp.length();
                right = eq.substring(l+3,r);
                cond = tmp.substring(4);
                tmp = "";
            
	     } else {
                tmp = tmp.substring(4);
	     }

          } else {

             tmp = tmp.substring(1);
          }
        }

        if (right.equals("")) {
            right = eq.substring(l+3);
        }

        /*
        System.out.println("----------------------------");
	System.out.println("eq: "+eq);
        System.out.println("left: "+left);
        System.out.println("right: "+right);
        System.out.println("cond: "+cond);
        */

        if (left.equals("") || right.equals("")) {
	    String msg = "format:No parse for the equation ";
            msg +="at line "+xt.beginLine+":\n";

	    if (conditional) {
		msg += "   cq "+eq;
	    } else {
		msg += "   eq "+eq;
            }
            throw new ParseException(msg);   
        }

        Term lterm, rterm, cterm=null;

        try {
           lterm = Term.parse(module, left);
        } catch (TermException e) {

            String eMsg = e.getMessage();
	    if (eMsg.startsWith("multiple parsing results")) {
	       int index = eMsg.indexOf("\n");
	       eMsg = eMsg.substring(index);

	       String msg = "format:There are "+e.getCount()+" parses"+
			    " for LHS of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }
               msg += "\nThe first 2 parse trees are:";
               msg += eMsg;
               throw new ParseException(msg);
            } else {
	       String msg = "format:no parse "+
			    "for LHS of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }

               throw new ParseException(msg);
	    }
        }

	try {
           rterm = Term.parse(module, right, lterm.getSort());
	} catch (TermException e) {

            String eMsg = e.getMessage();
	    if (eMsg.startsWith("multiple parsing results")) {
	       int index = eMsg.indexOf("\n");
	       eMsg = eMsg.substring(index);

	       String msg = "format:There are "+e.getCount()+" parses"+
			    " for RHS of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }
               msg += "\nThe first 2 parse trees are:";
               msg += eMsg;
               throw new ParseException(msg);

            } else {
	       String msg = "format:no parse "+
			    "for RHS of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }

               throw new ParseException(msg);
	    }
        }

	try {
           cterm = null;
           if (!cond.equals("")) {
              cterm = Term.parse(module, cond);
           }
	} catch (TermException e) {

            String eMsg = e.getMessage();
	    if (eMsg.startsWith("multiple parsing results")) {
	       int index = eMsg.indexOf("\n");
	       eMsg = eMsg.substring(index);

	       String msg = "format:There are "+e.getCount()+" parses"+
			    " for the condition of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }
               msg += "\nThe first 2 parse trees are:";
               msg += eMsg;
               throw new ParseException(msg);

            } else {
	       String msg = "format:no parse "+
			    "for the condition of equation "+
			    "at line "+xt.beginLine+":\n";
	       if (conditional) {
		  msg += "   cq "+eq;
	       } else {
		  msg += "   eq "+eq;
               }

               throw new ParseException(msg);
	    }
        }

        try {
	   Equation equ;
	   if (cterm != null) {
	      equ = new Equation(cterm, lterm, rterm);
	   } else {
              equ = new Equation(lterm, rterm);
           }
	   equ.info = module.modName.toString();

           if (name != null) {	
	       equ.setName(name);
	   }	

	   equat = equ;

	   boolean wrong = false;
           if (lterm.getVariable() != null ) {

              if (cterm != null) {
		
	          // check variables in rterm
	          Variable[] rvars = rterm.getVariables();
                  for (int i=0; i<rvars.length; i++) {
                      if (!lterm.contains(rvars[i])) {
                          System.out.println("====================="+
                                             "=====================");
	                  System.out.println(
                                "Warning at line "+xt.beginLine+": \n"+
                                "The RHS has variables "+
                                "not in the LHS. \n"+
                                "The equation will be ignored for rewriting.");
                          wrong = true;
	                  module.addGeneralEquation(equ);
		          break;
		       }
                  }

	          // check variable in cterm
                  if (!wrong && cterm != null) {

		      Variable[] vars = cterm.getVariables();
                      for (int i=0; i<vars.length; i++) {
		          if (!lterm.contains(vars[i])) {
		             System.out.println("====================="+
                             	                "=====================");
	                     System.out.println(
                                "Warning at line "+xt.beginLine+": \n"+
                                "The condition has variables "+
                                "not in the LHS. \n"+
                                "The equation will be ignored for rewriting.");
                            wrong = true;
	                    module.addGeneralEquation(equ);
		            break;
		       }
		    }
                 }
		 if (!wrong) 
                     module.addEquation(equat);

	      } else {

	          if (module instanceof CaseModule) {

                  } else {

		      System.out.println("====================="+
				         "=====================");
	              System.out.println("Warning at line "+xt.beginLine+":\n"+
			                 "The left term is a variable. "+
				         "The equation will be ignored "+
				         "for rewriting.");
                  }

	          wrong = true;
	          module.addGeneralEquation(equ);
	      }
           } else {
	      Variable[] rvars = rterm.getVariables();
              for (int i=0; i<rvars.length; i++) {
                 if (!lterm.contains(rvars[i])) {
                     System.out.println("====================="+
                                        "=====================");
	             System.out.println(
                       "Warning at line "+xt.beginLine+": \n"+
                       "The RHS has variables "+
                       "not in the LHS. \n"+
                       "The equation will be ignored for rewriting.");
                    wrong = true;
	            module.addGeneralEquation(equ);
		    break;
		    
	         }
              }

              if (!wrong && cterm != null) {
                 boolean wrongEq = false;
                 boolean wrongRule = false;
		 Variable[] vars = cterm.getVariables();
                 for (int i=0; i<vars.length; i++) {
		    if (!lterm.contains(vars[i])) {
		       wrongRule = true;

		       if (!rterm.contains(vars[i])) {
			   wrongEq = true;
			   break;
		       }
		    }
    
                 }

                 if (wrongEq) {

                     System.out.println("====================="+
                                        "=====================");
	             System.out.println(
                       "Warning at line "+xt.beginLine+":\n"+
                       "The condition has variables "+
                       "not in the LHS. \n"+
		       "The equation will be ignored for rewriting.");

	             module.addGeneralEquation(equ);


                 } else if (wrongRule) {

                     System.out.println("====================="+
                                        "=====================");
	             System.out.println(
                       "Warning at line "+xt.beginLine+":\n"+
                       "The condition has variables "+
                       "not in the LHS. \n"+
		       "The equation will be ignored for rewriting.");
	             module.addGeneralEquation(equ);

                 } else {

		      Equation equation = new Equation(cterm,lterm,rterm);
		      if (name != null) {
			  equation.setName(name);
	              }
                      equation.info = module.modName.toString();
		      module.addEquation(equation);
		      equat = equation;

                      if (dynmaicModule != null && mode == FILE_INPUT) {
                           writer.write("====================="+
                                        "=====================\n");
			   writer.write(format(equation.toString(), 0)+"\n");
                      }

                 }

              } else if (!wrong) {
		 Equation equation = new Equation(lterm,rterm);
		 if (name != null) {
	              equation.setName(name);
	         }
                 equation.info = module.modName.toString();
                 module.addEquation(equation);
                 equat = equation;	

                 if (conditional) {
                     writer.write("====================="+
                                  "=====================\n");
	             writer.write("Warning at line "+xt.beginLine+
                                  ":\nuse \"cq\" for an unconditional"+
                                  " equation.\n");
		     writer.write("   "+equation.toString()+"\n");
		     writer.flush();
                 } else {

                      if (dynmaicModule != null && mode == FILE_INPUT) {
                           writer.write("====================="+
                                        "=====================\n");
			   writer.write(format(equation.toString(), 0)+"\n");
                           writer.flush();
                      }

		 }
              }
           }

         } catch (IOException e) {

	    String msg = e.getMessage();
            msg +="at line "+xt.beginLine+".";
            throw new ParseException(msg);

         }
      }
  "."
      {
	  return equat;
      }
}



String Term(Module module) :
{
    String result = "";
    String mid = "";
    String tmp;
}
{
   (
      LOOKAHEAD(30)
      (
      (tmp = TermTokens(module))
        {
            tmp = tmp.trim();
            result += tmp+" ";
        }
     |

       token="("
          {
	     mid = "( ";
	  }
          (
             (tmp=Term(module))
                 {
                    mid += tmp;
                 }
           |
             token="."
                 {
                     		     
                     Token token = getToken(0);
                     if (!module.containsToken(".")) {
                          String msg = "Unknown token: "+token.image+
				" at line "+token.beginLine+", column "+
				token.beginColumn+".";
                          throw new ParseException(msg);
                     }
		     mid += ". ";

                 }

          )+
        token=")"
            {   
	        result += mid+") ";
            }
        |
            LOOKAHEAD( { mode == FILE_INPUT &&
                         getToken(1).image.equals(".") &&
                         getToken(2).image.equals("(") })
            token="."
                {
                    result += ". ";
	        }
       )
   )+
        {
           return result;
        }
}



String TermTokens(Module module) :
{
    String result = "";
    String tmp;
    Token token, last = null;
    boolean defined = false;
}
{
 (
  LOOKAHEAD(200)
  (
    (token=<IDENTIFIER>)
       {
         if (!module.containsToken(token.image)) {

	     boolean isNum = false;
	     try {
                int num = Integer.parseInt(token.image);
		
                ModuleName nat = new ModuleName("NAT");
	        ModuleName imt = new ModuleName("INT");
                if ((num >= 0 &&
                     module.containsSystemSort(new Sort("Nat", nat))) ||
                    (num < 0  &&
                     module.containsSystemSort(new Sort("Int", imt)))) {

		    isNum = true;

		}
             } catch (Exception e) {}

	     if (isNum) {
		  result += token.image+" ";
             } else {

		  Sort[] sorts = module.getSortsByName(token.image);
		  if (sorts.length > 0) {
		     result += token.image+" ";
	          } else {

                     String stmp = module.decomposeToken(token.image);
                     if (stmp != null) {
                        result += stmp.trim()+" ";
                     } else if (token.image.startsWith("'") &&
                                module.getQidAlias() != null &&
                                module.getQidAlias().length > 0) {
		        result += token.image+" ";
                     } else {
		        result += token.image+" ";
                     }
                  }

             }
          } else {
	     result += token.image +" ";
          }

       }
  |
    (token=<INTEGER_LITERAL>)
       {

          if (!module.containsToken(token.image)) {

             int num = Integer.parseInt(token.image);
             ModuleName nat = new ModuleName("NAT");
	     ModuleName imt = new ModuleName("INT");
             
             if ((num >= 0 &&
                  module.containsSystemSort(new Sort("Nat", nat))) ||
                 (num < 0 &&
                  module.containsSystemSort(new Sort("Int", imt))) ||
		 module.containsSystemSort(FloatModule.floatSort)) {

                 result += token.image+" ";	

             } else {

                 /*
                 String msg = "Unknown token: "+token.image+" at line "+
		              token.beginLine+", column "+
                              token.beginColumn+".";
                 throw new ParseException(msg);
                 */

                 if (last != null && token.beginLine == last.endLine &&
                     token.beginColumn == last.endColumn+1) {
                     result = result.substring(0, result.length()-1);
                     result += token.image+" ";
                 } else {
                     result += token.image+" ";
                 }

             }
          } else {
	     result += token.image+" ";	
          }	  
       }
  |
    (token=<FLOATING_POINT_LITERAL>)
       {
          if (!module.containsToken(token.image)) {

             ModuleName floatMod = new ModuleName("FLOAT");
	                  
             if ( !module.containsSystemSort(new Sort("Float", floatMod)) ) {
		    
                 String msg = "Unknown token: "+token.image+" at line "+
		              token.beginLine+", column "+
                              token.beginColumn+".";
                 throw new ParseException(msg);
             }
          }
	  result += token.image+" ";	  
       }
  |
    (token=<LESS>)
       {

          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
	  result += token.image+" ";
       }
  |
    (token=<ARROW>)
       {

          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
	  result += token.image+" ";
       }
  |
    (token="dth")
       {

          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
	  result += token.image+" ";
       }
  |
    (token="end")
       {

          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
	  result += token.image+" ";
       }
  |
    (token="op")
       {

          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
	  result += token.image+" ";
       }

  |
    (token=<IS>)
       {

          if (!module.containsToken("is")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "is ";
       }
 |
    (token=<VAR>)
       {

          if (!module.containsToken("var")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "var ";
       }
 |
    (token=<VARS>)
       {

          if (!module.containsToken("vars")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "vars ";
       }
 |
    (token=<WITH>)
       {

          if (!module.containsToken("with")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "with ";
       }
 |
    (token=<WITHIN>)
       {

          if (!module.containsToken("within")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "within ";
       }
 |
    (token=<APPLY>)
       {

          if (!module.containsToken("apply")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "apply ";
       }
 |
    (token=<PRINT>)
       {

          if (!module.containsToken("print")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "print ";
       }
 |
    (token=<INC>)
       {

          if (!module.containsToken("inc")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "inc ";
       }
 |
    (token=<INCLUDING>)
       {

          if (!module.containsToken("including")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "including ";
       }
 |
    (token=<REDUCTION>)
       {

          if (!module.containsToken("reduction")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "reduction ";
       }
 |
    (token=<REDUCE>)
       {

          if (!module.containsToken("reduce")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "reduce ";
       }   
 |
    (token=<SORTS>)
       {

          if (!module.containsToken("sorts")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "sorts ";
       }
 |
    (token=<SORT>)
       {

          if (!module.containsToken("sort")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "sort ";
       }
 |
    (token=<MAKE>)
       {

          if (!module.containsToken("make")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "make ";
       }
  |
    (token=<EQ>)
       {

          if (!module.containsToken("eq")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "eq ";
       }
  |
    (token=<IN>)
       {

          if (!module.containsToken("in")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "in ";
       }
  |
    (token=<QUIT>)
       {

          if (!module.containsToken("q")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "q ";
       }
  |
    (token=<LET>)
       {
          if (!module.containsToken("let")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "let ";
       }
  |
    (token=<STOP>)
       {
          if (!module.containsToken("eof")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "eof ";
       }
  |
    (token=<SELECT>)
       {
          if (!module.containsToken("select")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "select ";
       }
  |
    (token="show")
       {
          if (!module.containsToken("show")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "show ";
       }

  |
    (token=<SET>)
       {
          if (!module.containsToken("set")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "set ";
       }
  |
    (token=<TRACE>)
       {
          if (!module.containsToken("trace")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "trace ";
       }
  |
    (token=<ON>)
       {
          if (!module.containsToken("on")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "on ";
       }
  |
    (token=<OFF>)
       {
          if (!module.containsToken("off")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "off ";
       }
 |
    (token=<FULL>)
       {
          if (!module.containsToken("full")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "full ";
       }
 |
    (token=<FROM>)
       {
          if (!module.containsToken("from")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "from ";
       }
 |
    (token=<OF>)
       {
          if (!module.containsToken("of")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "of ";
       }
 |
    (token=<TIME>)
       {
          if (!module.containsToken("time")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "time ";
       }
 |
    (token=<RULES>)
       {
          if (!module.containsToken("rules")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "rules ";
       }
  |
    (token=<SUM>)
       {
          if (!module.containsToken("||")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "|| ";
       }

  |  token=<JBO>
       {
          if (!module.containsToken("jbo")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "jbo ";
       }
  |  token=<ASSOCIATIVE>
       {
          if (!module.containsToken("associative")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "associative ";
       }
  |  token=<COMMUTATIVE>
       {
          if (!module.containsToken("commutative")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "commutative ";
       }
  |
    token=<IDEMPOTENT>
       {
          if (!module.containsToken("idempotent")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "idempotent ";
       }     
  |  token=<HT>
       {
          if (!module.containsToken("ht")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "ht ";
       }
  |  token=<WEIV>
       {
          if (!module.containsToken("weiv")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "weiv ";
       }
  |  token=<ENDVIEW>
       {
          if (!module.containsToken("endview")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "endview ";
       }
  |  token=<GATHERING>
       {
          if (!module.containsToken("gathering")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "gathering ";
       }
  |  token=<PRECEDENCE>
       {
          if (!module.containsToken("precedence")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "precedence ";
       }
  |  token=<THEORY>
       {
          if (!module.containsToken("theory")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "theory ";
       }
  |  token=<SH>
       {
          if (!module.containsToken("sh")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "sh ";
       }
  |  token=<LONGQUIT>
       {
          if (!module.containsToken("quit")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "quit ";
       }
  |  token=<INPUT>
       {
          if (!module.containsToken("input")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "input ";
       }
  |  token=<DEFINE>
       {
          if (!module.containsToken("define")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "define ";
       }
  |  token=<IDENTITY>
       {
          if (!module.containsToken("identity")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "identity ";
       }
  |  token=<OBJECT>
       {
          if (!module.containsToken("object")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "object ";
       }
  |  token=<FOR>
       {
          if (!module.containsToken("for")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "for ";
       }
  |
    token=","
       {
	  result += ", ";
       }
  |
    (token="+")
       {
         if (!module.containsToken("+")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "+ ";
       }

  |
    (token="*")
       {
          if (!module.containsToken("*")) {
             String msg = "Unknown token: "+token.image+" at line "+
                      token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          result += "* ";
       }
  |
    (token=":")
       {
          /*
          if (!module.containsToken(":")) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          */
          result += ": ";
       }
  |
    (token="[")
       {
	 
	   if (last != null &&
               last.beginLine == token.beginLine &&
	       last.endColumn+1 == token.beginColumn) {

	       // this token is connected to the last token
               // there are two choices:
               //   (1) seperated from the last
	       //          if last is defined and (last+this)
               //             is undefined
               //   (2) connected with the last
               //          if (last+this) is defined or 
               //             (last+this) and this is undefined

	       String string = result.trim();
               int index = string.lastIndexOf(" ");
               if (index != -1) {
                  string = string.substring(index).trim();
	       }

	       boolean all = true;
	       for (int i=0; i<string.length(); i++) {
		  if (!string.substring(i, 1).equals("[")) {
                      all = false;
                      break;
                  }
               }
	       
	       if (all) {

	          if (module.containsToken(string) &&
	              !module.containsToken(string+token.image)) {
		      result += "[ ";
	          } else {
		      if (module.containsTokenForModuleName(string) && 
	                  !module.containsToken(string+token.image)) {
		         result += "[ ";
                      } else {
		         result = result.trim();
		         result += "[ ";
                      }
                  }

	       } else {
                  //result += "[ ";

	          if (module.containsToken(string) &&
	              !module.containsToken(string+token.image)) {
		      result += "[ ";
                  } else if (module.containsTokenForModuleName(string) && 
	                  !module.containsToken(string+token.image)) {
		      result += "[ ";	
	          } else if (last.image.equals(",") ||
			     last.image.startsWith("'")) {
                      result += "[ ";
                  } else {
		      result = result.trim();
		      result += "[ ";
                  }
               }

	   } else {
	       // this token is seperated from the last token
               result += "[ ";
           }
       }
  |
    (token="]")
       {

	   if (last != null &&
               last.beginLine == token.beginLine &&
	       last.endColumn+1 == token.beginColumn) {

	       // this token is connected to the last token
               // there are two choices:
               //   (1) seperated from the last
	       //          if last is defined and (last+this)
               //             is undefined
               //   (2) connected with the last
               //          if (last+this) is defined or 
               //             (last+this) and this is undefined

	       String string = result.trim();
               int index = string.lastIndexOf(" ");
               if (index != -1) {
                  string = string.substring(index).trim();
	       }

	       boolean all = true;
	       for (int i=0; i<string.length(); i++) {
		  if (!string.substring(i, 1).equals("]")) {
                      all = false;
                      break;
                  }
               }

	       if (all) {
	       	   if (module.containsToken(string) &&
	               !module.containsToken(string+token.image)) {
		       result += "] ";

	           } else {
		       result = result.trim();
		       result += "] ";
                   }

	       } else {

                   // if connected is an existing token, then use it
                   // otherwise seperate them

                   string += "]";
                   if (module.containsToken(string)) {
                       result = result.trim();
		       result += "] ";
                   } else {
                       result += "] ";
                   }
            
		   //result += "] ";
	       }

	   } else {

	       // this token is seperated from the last token
               result += "] ";

           }

       }

  )
       {         
	  last = token;
       }
 )+
    {
       return result;
    }
}



void DefDecl(Module mod) :
{
  Token token;
  Module module;
}
{
  ( "dfn" | "define" )
  (token=<IDENTIFIER>) "is" (module=ModExpr(mod)) "."
    {
        try {

             Sort from = module.getPrincipalSort();
             Sort to = new Sort(token.image, mod.getModuleName());
             
             module = module.changeSort(module.getModuleName(), from, to);
	     module = module.changeModuleName(module.modName,
					      new ModuleName(token.image),
					      new ModuleName(token.image));

             mod.importModule(module);

	     if (from.isDefault() && from.getName().equals("Id")) {
	         mod.addQidAlias(to);
	     }

        } catch (SignatureException e) {
             Token xt = token;
             String msg = e.getMessage();
             msg += ", at line "+xt.beginLine+".";
             throw new ParseException(msg);
        } 

   }
}


String OpNameNoComma() :
{
   String result = "";
   String tmp;
   Token token;
}
{
 (
  LOOKAHEAD(2)
  (
    (token=<IDENTIFIER>)
       {
	  result += token.image +" ";
       }
  |
    (token=<INTEGER_LITERAL>)
       {
	  result += token.image+" ";
       }

  | token=<OBJ>
       {
	  result += token.image+" ";
       }
  | token=<TH>
       {
	  result += token.image+" ";
       }
  | token=<BTH>
       {
	  result += token.image+" ";
       }
  | token=<DTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDO>
       {
	  result += token.image+" ";
       }
  | token=<ENDTH>
       {
	  result += token.image+" ";
       }
  | token=<ENDB>
       {
	  result += token.image+" ";
       }
  | token=<ENDD>
       {
	  result += token.image+" ";
       }
  | token=<END>
       {
	  result += token.image+" ";
       }
  | token=<PR>
       {
	  result += token.image+" ";
       }
  | token=<PROTECTING>
       {
	  result += token.image+" ";
       }
  | token=<EX>
       {
	  result += token.image+" ";
       }
  | token=<EXTENDING>
       {
	  result += token.image+" ";
       }
  | token=<US>
       {
	  result += token.image+" ";
       }
  | token=<USING>
       {
	  result += token.image+" ";
       }
  | token=<BSORT>
       {
	  result += token.image+" ";
       }
  | token=<BSORTS>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORT>
       {
	  result += token.image+" ";
       }
  | token=<SUBSORTS>
       {
	  result += token.image+" ";
       }
  |
    (token=<LESS>)
       {
	  result += token.image+" ";
       }
  |
    (token=<ARROW>)
       {
	  result += token.image+" ";
       }
  |
    (token=<VAR>)
       {
	  result += token.image+" ";
       }
  |
    (token=<VARS>)
       {
	  result += token.image+" ";
       }
  |
    <IS>
       {
          result += "is ";
       }
  |
    <LET>
       {
	  result += "let ";
	}
  |
    <SUM>
       {
	  result += "|| ";
       }
  |
     <PARENS>
       {
	  result += "parens ";
       }
  |
     <INCLUDE>
       {
	  result += "include ";
       }
  |
     <REDUCTION>
       {
	  result += "result ";
       }
  |
     <INC>
       {
	  result += "inc ";
       }
  |
     <INCLUDING>
       {
	  result += "including ";
       }
  |
     <REDUCE>
       {
	  result += "reduce ";
       }
  |
     <TIME>
       {
	  result += "time ";
       }
  |
     <JBO>
       {
	  result += "jbo ";
       }
  |
     <ASSOCIATIVE>
       {
	  result += "associative ";
       }
  |
     <COMMUTATIVE>
       {
	  result += "commutative ";
       }
  |
     <IDEMPOTENT>
       {
	  result += "idempotent ";
       }
  |
     <HT>
       {
	  result += "ht ";
       }
  |
     <WEIV>
       {
	  result += "weiv ";
       }
  |
     <ENDVIEW>
       {
	  result += "endview ";
       }
  |
     <GATHERING>
       {
	  result += "gathering ";
       }
  |
     <PRECEDENCE>
       {
	  result += "precedence ";
       }
  |
     <THEORY>
       {
	  result += "theory ";
       }
  |
     <SH>
       {
	  result += "sh ";
       }
  |
     <LONGQUIT>
       {
	  result += "quit ";
       }
  |
     <OBJECT>
       {
	  result += "quit ";
       }
  |
     <DEFINE>
       {
	  result += "define ";
       }
  |
     <IDENTITY>
       {
	  result += "identity ";
       }
  |
     <INPUT>
       {
	  result += "input ";
       }
  |
    "+"
       {
	  result += "+ ";
       }
  |
    "*"
       {
	  result += "* ";
       }
  | "q"
       {
	  result += "q ";
       }
  |
    "[" (tmp=OpName()) "]" 
       {

          if (tmp.trim().startsWith("[") && tmp.trim().endsWith("]")) {
             tmp = "["+tmp.trim()+"] ";
          } else {
             tmp = "[ "+tmp.trim()+" ] ";
          }

          result += tmp;

       }
  )
 )+
  {
     return result;
  }
}




View ViewDecl() :
{
    String viewName;
    Module source, target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
    boolean hasParameter = false;
    boolean force = false;
    ArrayList views = null ;
}
{
   (token=<IDENTIFIER> | token=<INTEGER_LITERAL>)
      {
	 viewName = token.image;
         Module pmod = null;
      }
   [
     "["
          {
	      String str = "parameter-module-in-view"+token.image;
	      ModuleName modName = new ModuleName(str);
	      pmod = new Module(Module.LOOSE, modName);
	      Module mod;
              List list = new ArrayList();
	  }
      (token=<IDENTIFIER>
	     {
		list.add(token.image);
	     }
      )+
      "::"
      mod=ModExpr(pmod)
	 {
               try {
		   for (int i=0; i<list.size(); i++) {
		       String paraName = (String)list.get(i);
	               pmod.addParameter(paraName, mod, getEnv());
		       paraPool.put(paraName, mod);
                   }
	       } catch (SignatureException e) {
		   String msg = e.getMessage()+" at line "+
			        token.beginLine+" column "+
		                token.beginColumn;
                   throw new ParseException(msg);
	       } catch (ModuleParameterException e) {
		   String msg = e.getMessage()+" at line "+
			        token.beginLine+" column "+
		                token.beginColumn;
                   throw new ParseException(msg);
	       }
	  }
      (
          ","
               {
		   list = new ArrayList();
	       }
          (
            token=<IDENTIFIER>
	       {
		   list.add(token.image);
	       }
          )+
          "::"
          mod=ModExpr(pmod)
	     {
                 try {
		     for (int i=0; i<list.size(); i++) {
		         String paraName = (String)list.get(i);
	                 pmod.addParameter(paraName, mod, getEnv());
			 paraPool.put(paraName, mod);
                     }
	         } catch (SignatureException e) {
		     String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                     throw new ParseException(msg);
	         } catch (ModuleParameterException e) {
		     String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                     throw new ParseException(msg);
	         }
	    }
     )*
     "]"
          {
	     hasParameter = true;
	  }
   ]
   "from"
   (source=ModExpr(pmod))
   "to"
   (target=ModExpr(pmod))
      [
          "with"
	  "["
	       {
                  int index = 0;
		  View[] vs = new View[source.paraNames.size()];
		  Module[] mds = new Module[vs.length];
		  String[] ns = new String[vs.length];
		  views = new ArrayList();

                  Module psrc = null;
		  try {
	              psrc = target.getParameterAt(index);
                      //ns[index] = source.getParameterNameAt(index);
		  } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                      throw new ParseException(msg);
	          }

		  Module md;
	       }
	       mds[index] = LocalViewDecl(pmod, psrc, new Vector())
		  {
                     vs[index] = (View)mds[index].getProperty("view");
		     views.add(vs[index].copy(""));

		     try {
		        vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());

                        //mds[index] = vs[index].source;
                        mds[index] = vs[index].target;
		        mds[index].setProperty("view", vs[index]);

                     } catch (Exception e) {
                        String msg = e.getMessage()+" at line "+
			             token.beginLine+" column "+
		                     token.beginColumn;
                        throw new ParseException(msg);
	             }

		     index++;
		  }
               (
                  ","
                     {
		        try {
	                   psrc = target.getParameterAt(index);
                           //ns[index] = source.getParameterNameAt(index);
                        } catch (ModuleParameterException e) {
		           String msg = e.getMessage()+" at line "+
			               token.beginLine+" column "+
		                       token.beginColumn;
                           throw new ParseException(msg);
	                }
                     }
                   mds[index] = LocalViewDecl(pmod, psrc, new Vector())
		      {
                          vs[index] = (View)mds[index].getProperty("view");
		          views.add(vs[index].copy(""));

                          try {
		             vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());
                             //mds[index] = vs[index].source;
                             mds[index] = vs[index].target;
		             mds[index].setProperty("view", vs[index]);
                          } catch (Exception e) {
                             String msg = e.getMessage()+" at line "+
			             token.beginLine+" column "+
		                     token.beginColumn;
                             throw new ParseException(msg);
	                  }
		          index++;
		      }
               )* 
          "]"
               {
                   try {
                      md = target.instanceBy(mds, ns, getEnv(), false);
                   } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			           token.beginLine+" column "+
		                   token.beginColumn;
                      throw new ParseException(msg);
	           }

		   Module newTarget = md;
		   newTarget.modName = target.modName;
		   newTarget.paraNames.addAll(source.paraNames);
		   newTarget.paraModules.addAll(source.paraModules);
		   newTarget.levels = new int[1];
		   newTarget.levels[0] = source.paraNames.size();

		   target = newTarget;

	       }
      ]
   "is"
        {
	    view = new View(viewName, source, target);
	    if (hasParameter) {
		view.record(pmod);
	    }
        }
   (
        {
	    Vector vnames = new Vector();
        }
      ("vars" | "var")
      (
         (token=<IDENTIFIER>)
            {
	       vnames.addElement(token);
	    }
      )+
      ":" 
      sort=SortReference(source)
      "."
           {
	    
	      for (int i=0; i<vnames.size(); i++) {
		 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
	 	 } catch (ViewException e) {
		    String msg = e.getMessage();
		    msg += " at line "+tmp.beginLine+
			      ", column "+tmp.beginColumn+".";
		    throw new ParseException(msg);
		 }
	      }
           }
    |
      "sort"
	  {
	     token1 = getToken(0);
          }
      sort1=SortReference(source)
      "to"
          {
	     token2 = getToken(0);
          }
      sort2=SortReference(target)
      "."
         {
            try {

	      Sort tmp = view.getTarget(sort1);
	      if (tmp != null && tmp.equals(sort2)) {
                  System.out.println("=================="+
                                     "========================");
		  System.out.println("Warning: duplicate mapping from "+
				     sort1.getName()+" to "+sort2.getName()+
				     " at line "+token1.beginLine);
	      } 

              view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
	       String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
 	       throw new ParseException(msg);
            }
         }
    |
      {
	 String opname1, opname2;
      }
      "op"
          {
	     token1 = getToken(0);
	  }
      (
         (opname1=OpName())
       |
         "(" opname1=Term(view.getEnrichedTarget()) ")"
      )
      "to"
          {
	     token2 = getToken(0);
	  }
      (     
         (opname2=OpName())
       |
         "(" opname2=Term(view.getEnrichedTarget()) ")"
     )
      "."
          {

	     Operation[] ops1 = source.getOperationsWithName(opname1.trim());

             if (ops1.length > 1) {
		String msg = "Multiple operations with the name "+
			      opname1+" in the module "+source.getModuleName()+
			      " at line "+token1.beginLine+" column "+
			      token1.beginColumn+".";
                throw new ParseException(msg);
             }

             Operation op1, op2;

             if (ops1.length == 1) {

	        Operation[] ops2 =target.getOperationsWithName(opname2.trim());

                if (ops2.length > 1) {

                    Vector pool = new Vector();
		    for (int i=0; i<ops2.length; i++) {
		         boolean found = false;
		         for (int j=0; j<pool.size(); j++) {
		              Operation op = (Operation)pool.elementAt(j);
		              if (op.less(target, ops2[i])) {
			           pool.removeElementAt(j);
			           pool.insertElementAt(ops2[i], j);
			           found = true;
		              } else if (ops2[i].less(target, op)) {
			           found = true;
		              }
		         }

		         if (!found) {
		             pool.addElement(ops2[i]);
		         }
		    }

		    if (pool.size() > 1) {

		        String msg = "Multiple operations with the name "+
			             opname2+" in the module "+
                                     target.getModuleName()+
			             " at line "+token2.beginLine+" column "+
			             token2.beginColumn+".";
                        throw new ParseException(msg);
		    } else {
		        ops2 = new Operation[pool.size()];
		        pool.copyInto(ops2);
		    }
                }

                if (ops2.length == 0) {

	             // no operation is found, parse it as a term
	             try {
		          Term term = Term.parse(view.getEnrichedTarget(),
			                         opname2);
			  if (ops1[0].isConstant()) {

			     Term left = new Term(ops1[0]);
		             view.addTransformation(left, term);

	                  } else {
		              String msg = opname1.trim()+
					   " is not a constant in the module "+
					   source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
			     throw new ParseException(msg);
		          }

                     } catch (TermException e) {

                          ops2 =
			    target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

			     try {
                                op1 = ops1[0];
 		                op2 = ops2[0];
			        view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
	                        String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
 	                        throw new ParseException(msg);
		             }

			  } else {

		              String msg = "Unresolvable tokens "+
                                           opname2.trim()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                              throw new ParseException(msg);
                          }
	             }

	        } else {

		   op1 = ops1[0];
 		   op2 = ops2[0];

		   Operation tmp = view.getTarget(op1);
	           if (tmp != null && tmp.equals(op2)) {
                      System.out.println("======================"+
					 "====================");
	              System.out.println("Warning: duplicate mapping from "+
					  op1.getCleanName()+" to "+
				          op2.getCleanName()+
			        	  " at line "+token2.beginLine+
		                          " column "+token2.beginColumn+".");
	           }

		   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
	              String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
 	              throw new ParseException(msg);
		   }
		}

	     } else {

		// no operation is found, try to parse term
                boolean okay = false;
		Term left = null;
                Term right = null;

	        try {

                  left =
		     Term.parse(view.getEnrichedSource(),
				opname1);

		  right =
		     Term.parse(view.getEnrichedTarget(),
				opname2);

		  if (left != null && right != null) {
		     view.addTransformation(left, right);
		     okay = true;
		  }

                } catch (TermException e) {}

		if (!okay) {

		   Operation lop = null, rop = null;
		   if (left == null) {
                      Operation[] lops =
		          source.getOperationsWithCleanName(opname1.trim());
		      if (lops.length == 1) {
			 lop = lops[0];
                      }
		   }

                   if (right == null) {
                      Operation[] rops =
		          source.getOperationsWithCleanName(opname2.trim());
		      if (rops.length == 1) {
			 rop = rops[0];
                      }
		   }		   

                   // there are 3 cases:
                   try {
		       if (left != null && rop != null) {
			    view.addTransformation(left, new Term(rop));
			    okay = true;
		       } else if (lop != null && right != null) {
		            view.addTransformation(new Term(lop), right);
			    okay = true;
		       } else if (lop != null && rop != null) {
		            view.addOperationMap(lop, rop);
			    okay = true;
                       }
                   } catch (Exception ex) {}
		}


                if (!okay && left == null) {
		   String msg = "No operations with the name \""+
			     opname1.trim()+"\" in the module "+
			     source.getModuleName()+
			     " at line "+token1.beginLine+" column "+
			     token1.beginColumn+".";
                   throw new ParseException(msg);
                } else if (!okay && right == null) {
		   String msg = "No operations with the name \""+
			     opname2.trim()+"\" in the module "+
			     target.getModuleName()+
			     " at line "+token2.beginLine+" column "+
			     token2.beginColumn+".";
                   throw new ParseException(msg);
                } else if (!okay) {
		   String msg = "No parse "+
			        " at line "+token1.beginLine+" column "+
			        token1.beginColumn+".";
                   throw new ParseException(msg);

		}

	     } 

	  }
   )*
      {
         try {

	     if (views != null) {
		view.views = views;
                view.record();
	     }
	     view.validate();

	 } catch (ViewException e) {

	     Token xt = getToken(0);
             String msg = e.getMessage()+
		          " at line "+xt.beginLine+", column "+
			  xt.beginColumn+".";

	     if (detail) {
	        msg = "format:"+format(msg, 0)+"\n"+
		      "the failed view is\n"+e.getView();
             }

             throw new ParseException(msg);
       	 }

	 return view;
      }

}



Module LocalViewDecl(Module mod, Module source, Vector views) :
{
    Module target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
}
{
   "view" "to"
   (target=ModExpr(mod))
   "is"
        {
	     view = new View("", source, target);
        }
   (
      {
	 Vector vnames = new Vector();
      }
      ("vars" | "var")
      (
         (token=<IDENTIFIER>)
            {
	       vnames.addElement(token);
	    }
      )+
      ":" 
      sort=SortReference(source)
      "."
           {
	      for (int i=0; i<vnames.size(); i++) {
		 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
	 	 } catch (ViewException e) {
		    String msg = e.getMessage();
		    msg += " at line "+tmp.beginLine+
			      ", column "+tmp.beginColumn+".";
		    throw new ParseException(msg);
		 }
	      }
           }
    |
      "sort"
           {
	      token1 = getToken(0);
	   }
      sort1=SortReference(source)
      "to"
           {
	      token2 = getToken(0);
	   }
      sort2=SortReference(target)
      "."
         {
            try {
               view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
	       String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
 	       throw new ParseException(msg);
            }
         }
    |
      {
	 String opname1, opname2;
         String modStr1=null, modStr2=null;
      }
      "op"
          {
	     token1 = getToken(0);
	  }
      (
          (opname1=OpName())
       |
          "(" opname1=Term(view.getEnrichedTarget()) ")"
         [
            token=<IDENTIFIER>
               {
                   modStr1 = token.image;
                   if (modStr1.startsWith(".")) {
		       modStr1 = modStr1.substring(1);
                   } else {
	               String msg = "expect . ";
                       msg += " at line "+token.beginLine+" column "+
			      token.beginColumn+".";
 	               throw new ParseException(msg);
		   }
	       }
         ]
      )
      "to"
          {
	     token2 = getToken(0);
	  }
      ( 
         (opname2=OpName())
       |
         "(" opname2=Term(view.getEnrichedTarget()) ")"
         [
            token=<IDENTIFIER>
               {
		   modStr2 = token.image;
                   if (modStr2.startsWith(".")) {
		       modStr2 = modStr2.substring(1);
                   } else {
	               String msg = "expect . ";
                       msg += " at line "+token.beginLine+" column "+
			      token.beginColumn+".";
 	               throw new ParseException(msg);
		   }
	       }
         ]
      )
      "."
          {

	     Operation[] ops1 = source.getOperationsWithName(opname1.trim());

	     if (modStr1 != null) {

	         ArrayList list = new ArrayList();
	         for (int i=0; i<ops1.length; i++) {
		     if (ops1[i].modName.op == ModuleName.ATOM &&
			 ops1[i].modName.atom.equals(modStr1)) {
			 list.add(ops1[i]);
		     }
	         }

	         ops1 = new Operation[list.size()];
		 for (int i=0; i<ops1.length; i++) {
		    ops1[i] = (Operation)list.get(i);
                 }
	     }

             if (ops1.length > 1) {
		String msg = "Multiple operations with the name "+
			      opname1+" in the module "+source.getModuleName()+
			      " at line "+token1.beginLine+" column "+
			      token1.beginColumn+".";
                throw new ParseException(msg);
             }


             Operation op1, op2;

             if (ops1.length == 1) {

	        Operation[] ops2=target.getOperationsWithName(opname2.trim());

	        if (modStr2 != null) {

	            ArrayList list = new ArrayList();
	            for (int i=0; i<ops2.length; i++) {


		        if (ops2[i].modName.op == ModuleName.ATOM &&
			    ops2[i].modName.atom.equals(modStr2)) {
			   list.add(ops2[i]);
		        }

	            }

	            ops2 = new Operation[list.size()];
		    for (int i=0; i<ops2.length; i++) {
		       ops2[i] = (Operation)list.get(i);
                    }
	        }

                if (ops2.length > 1) {

                    Vector pool = new Vector();
		    for (int i=0; i<ops2.length; i++) {
		        boolean found = false;
		        for (int j=0; j<pool.size(); j++) {
		            Operation op = (Operation)pool.elementAt(j);
		            if (op.less(target, ops2[i])) {
			        pool.removeElementAt(j);
			        pool.insertElementAt(ops2[i], j);
			        found = true;
		            } else if (ops2[i].less(target, op)) {
			        found = true;
		            }
		        }

		        if (!found) {
		            pool.addElement(ops2[i]);
		        }
		  }

		  if (pool.size() > 1) {

		     String msg = "Multiple operations with the name "+
			          opname2+" in the module "+
                                  target.getModuleName()+
			          " at line "+token2.beginLine+" column "+
			          token2.beginColumn+".";
                     throw new ParseException(msg);
		  } else {
		     ops2 = new Operation[pool.size()];
		     pool.copyInto(ops2);
		  }
                }

                if (ops2.length == 0) {

	             // no operation is found, parse it as a term
	             try {
		          Term term = Term.parse(view.getEnrichedTarget(),
			                         opname2);
			  if (ops1[0].isConstant()) {

			     Term left = new Term(ops1[0]);
		             view.addTransformation(left, term);

	                  } else {
		              String msg = opname1.trim()+
					   " is not a constant in the module "+
					   source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
			     throw new ParseException(msg);
		          }

                     } catch (TermException e) {

			  // try to use clean name
                          ops2 =
			    target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

			     try {
                                op1 = ops1[0];
 		                op2 = ops2[0];
			        view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
	                        String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
 	                        throw new ParseException(msg);
		             }

			  } else {

		            String msg = "Unresolvable tokens "+opname2.trim()+
                                        " at line "+token2.beginLine+
                                        ", column "+token2.beginColumn;
                            throw new ParseException(msg);
                          }
	             }

	        } else {

		   op1 = ops1[0];
 		   op2 = ops2[0];

		   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
	              String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
 	              throw new ParseException(msg);
		   }
		}

	     } else {

		// no operation is found, try to parse term
                boolean okay = false;
		Term left = null;
                Term right = null;

	        try {

                  left =
		     Term.parse(view.getEnrichedSource(),
				opname1);

		  right =
		     Term.parse(view.getEnrichedTarget(),
				opname2);

		  if (left != null && right != null) {
		     view.addTransformation(left, right);
		     okay = true;
		  }

                } catch (TermException e) {}

		if (!okay) {

		   Operation lop = null, rop = null;
		   if (left == null) {
                      Operation[] lops =
		          source.getOperationsWithCleanName(opname1.trim());
		      if (lops.length == 1) {
			 lop = lops[0];
                      }
		   }

                   if (right == null) {
                      Operation[] rops =
		          source.getOperationsWithCleanName(opname2.trim());
		      if (rops.length == 1) {
			 rop = rops[0];
                      }
		   }		   

                   // there are 3 cases:
                   try {
		       if (left != null && rop != null) {
			    view.addTransformation(left, new Term(rop));
			    okay = true;
		       } else if (lop != null && right != null) {
		            view.addTransformation(new Term(lop), right);
			    okay = true;
		       } else if (lop != null && rop != null) {
		            view.addOperationMap(lop, rop);
			    okay = true;
                       }
                   } catch (Exception ex) {}
		}

                if (!okay && left == null) {

		   String msg = "No operations with the name \""+
			     opname1.trim()+"\" in the module "+
                             source.getModuleName()+
			     " at line "+token1.beginLine+" column "+
			     token1.beginColumn+".";
                   throw new ParseException(msg);

                } else if (!okay && right == null) {

		   String msg = "No operations with the name \""+
			     opname2.trim()+"\" in the module "+
                             target.getModuleName()+
			     " at line "+token2.beginLine+" column "+
			     token2.beginColumn+".";
                   throw new ParseException(msg);

                } else if (!okay) {
		   String msg = "No parse "+
			        " at line "+token1.beginLine+" column "+
			        token1.beginColumn+".";
                   throw new ParseException(msg);

		}

	     } 

	  }
   )*

   ("end" | "endv" | "weiv" | "endview")
      {

         try {
             view.validate();
             target.setProperty("view", view);	
	 } catch (ViewException e) {

	     Token xt = getToken(0);
             String msg = e.getMessage()+
		  	  " at line "+xt.beginLine+", column "+
			  xt.beginColumn+".";

	     if (detail) {
	        msg = "format:"+format(msg, 0)+"\n"+
		      "the failed view is\n"+e.getView();
             }

             throw new ParseException(msg);
         }

	 return target;
      }
}






Sort[] CobSortsDecl(Module module) :
{
    Sort[] sorts;
    Vector vec = new Vector();
    Sort sort;
}
{
   ("sort" | "sorts")
   (
      sort = SortReference(module)
	  {
               vec.addElement(sort);
	  }
   )+ "."

        {
            sorts = new Sort[vec.size()];
            vec.copyInto(sorts);
            return sorts;
        }
}



Operation CobOpDecl(Module module) :
{
    Sort sort;
    Vector argv = new Vector();
    String opName;
    Token token, xt;
}
{
   xt="op"
   opName=OpName()
   ":"
   (
      sort=SortReference(module)
         {
	     argv.addElement(sort);
         }
   )*
   "->"
   sort=SortReference(module) 
   "."
         {
             Sort[] args = new Sort[argv.size()];
             argv.copyInto(args);

             try {
                return new Operation(opName,
	                             args,
                                     sort,
                                     module.getModuleName());
              } catch (SignatureException e) {
	        throw new ParseException(e.getMessage()+" at line "+
				         xt.beginLine+", column "+
                                         xt.beginColumn);
              }
         }
}





Token MetaToken() :
{
   Token token;
}
{
(
   token=<OBJ>
|  token=<TH>
|  token=<BTH>
|  token=<DTH>
|  token=<ENDO>
|  token=<ENDTH>
|  token=<ENDB>
|  token=<ENDD>
|  token=<END>
|  token=<PR>
|  token=<PROTECTING>
|  token=<EX>
|  token=<EXTENDING>
|  token=<US>
|  token=<USING>
|  token=<IS>
|  token=<SORT>
|  token=<SORTS>
|  token=<BSORT>
|  token=<BSORTS>
|  token=<SUBSORT>
|  token=<SUBSORTS>
|  token=<VAR>
|  token=<VARS>
|  token=<OP>
|  token=<OPS>
|  token=<OPAS>
|  token=<EQ>
|  token=<CQ>
|  token=<CEQ>
|  token=<ASSOC>
|  token=<COMM>
|  token=<IDEM>
|  token=<PREC>
|  token=<IDR>
|  token=<ID>
|  token=<NONCONG>
|  token=<MEMO>
|  token=<LESS>
|  token=<ARROW>
|  token=<DOT>
|  token=<VARSOF>
|  token=<COLON>
|  token=<DOUBLECOLON>
|  token=<ADD>
|  token=<SUM>
|  token=<TO>
|  token=<STAR>
|  token=<LB>
|  token=<RB>
|  token=<DFN>
|  token=<RED>
|  token=<BRED>
|  token=<SOLVE>
|  token=<OPEN>
|  token=<OPENR>
|  token=<CLOSE>
|  token=<VIEW>
|  token=<ENDV>
|  token=<FROM>
|  token=<LOAD>
|  token=<APPLY>
|  token=<QUIT>
|  token=<PWD>
|  token=<CD>
|  token=<LS>
|  token=<IN>
|  token=<SHOW>
|  token=<MAKE>
|  token=<ENDM>
|  token=<LET>
|  token=<COMMENT>
|  token=<COBASIS>
|  token=<COB>
|  token=<COV>
|  token=<STOP>
|  token=<SELECT>
|  token=<SET>
|  token=<TRACE>
|  token=<ON>
|  token=<OFF>
|  token=<FULL>
|  token=<OF>
|  token=<PARSE>
|  token=<START>
|  token=<AT>
|  token=<WITH>
|  token=<PRINT>
|  token=<PARENS>
|  token=<WITHIN>
|  token=<INCLUDE>
|  token=<REDUCTION>
|  token=<INC>
|  token=<INCLUDING>
|  token=<REDUCE>
|  token=<TIME>
|  token=<RULES>
|  token=<JBO>
|  token=<ASSOCIATIVE>
|  token=<COMMUTATIVE>
|  token=<HT>
|  token=<WEIV>
|  token=<ENDVIEW>
|  token=<GATHERING>
|  token=<PRECEDENCE>
|  token=<THEORY>
|  token=<SH>
|  token=<LONGQUIT>
|  token=<IDEMPOTENT>
|  token=<OBJECT>
|  token=<IDENTITY>
|  token=<DEFINE>
|  token=<INPUT>
|  token=<MORPH>
)
    {
	return token;
    }
}


void ContextDecl(CaseModule module) :
{
   String string;
}
{
   "context"
   string=Term(module)
       {
           try {
              Term term = Term.parse(module, string);
	      module.setContext(term);
           } catch (TermException e) {
	
	      token = getToken(0);
              String msg;

	      if (e.getCount() > 0) {
                  msg = "format:"+e.getMessage()+"\nat line "+
			token.beginLine+".\n";
	      } else {
                  msg = e.getMessage()+"at line "+
			token.beginLine+".\n";
	      }

	      throw new ParseException(msg);
           }
       }
   "."
}


void CaseDecl(CaseModule module) :
{
   String string;
}
{
   "case"
       {
	  ArrayList eqs = new ArrayList();
          Equation eq;
	  Operation[] op;
          Module mod = (Module)module.clone();
          CaseModule cm = new CaseModule(mod.getModuleName(), mod);
          cm.vars = (Vector)module.vars.clone();
        }
   (
     eq=EquationDecl(cm)
         {
            eqs.add(eq);
     	 }
    |
     op = OperationDecl(cm)
         {
             
	     for (int i=0; i<op.length; i++) {
	        eqs.add(op[i]);
	     }
             
	 }
   ) +  
        {
	   module.cases.add(eqs);
        }
}


CaseModule CaseExp() :
{
   CaseModule cm;
   Token token, ftoken, btoken=null;
}
{
    "use"    
       {
          ArrayList cmlist = new ArrayList();
	  ftoken = getToken(0);
       }
    token=<IDENTIFIER>
	{
            CaseModule tmp = (CaseModule)casesPool.get(token.image);
	    if (tmp == null) {
	         String msg = "no cases with the name "+
                              token.image+" at "+
			      "line "+token.beginLine+", column "+
			      token.beginColumn;
	         throw new ParseException(msg);
	     }
             cmlist.add(tmp);
	 }
   [
      
      (  
         "*"
          token=<IDENTIFIER>
                  {
                      tmp = (CaseModule)casesPool.get(token.image);
		      if (tmp == null) {
	                  String msg = "no cases with the name "+
                                       token.image+" at "+
			               "line "+token.beginLine+", column "+
			               token.beginColumn;
	                  throw new ParseException(msg);
		      }
                      cmlist.add(tmp);
		  }
      )+
   ]
          {
               try {
		   if (cmlist.size() > 1) {
		       String name = "";
	               for (int i=0; i<cmlist.size(); i++) {
			  CaseModule c = (CaseModule)cmlist.get(i);
			  if (i == 0) {
			     name += c.name;
                          } else {
                             name += " * "+c.name;
			  }
		       }
		       ModuleName modName = new ModuleName(name);
	               cm = new CaseModule(modName, cmlist);
                   } else {
                       cm = (CaseModule)cmlist.get(0);
	           }
               } catch (CaseModuleException e) {
                   String msg =  e.getMessage()+" at line "+
			         token.beginLine+", column "+
			         token.beginColumn;
	           throw new ParseException(msg);
	       }
          }
    [
         
         token=<IDENTIFIER>
               {
                   if (!token.image.equals("exclude")) {
	               String msg = "expect \"exclude\" at line "+
			             token.beginLine+", column "+
			             token.beginColumn;
	               throw new ParseException(msg);
	           }

		   btoken = token;
		   String sum = "exclude";
               }
         (
               {
		   String label = "";
	       }

         "("
             ( token=<INTEGER_LITERAL> | token="*" )
               {
	           label += token.image;
	       }
          (
          ","
              ( token=<INTEGER_LITERAL> | token="*" )
                {
                    label += ","+token.image;
                }
          )+
          ")"
                {
		    // change case
	            try {
			 cm.remove(label);
                         sum += " ("+label+")";
                    } catch (Exception e) {
	                 String msg = e.getMessage()+" at line "+
			              btoken.beginLine+", column "+
			              btoken.beginColumn;
	                 throw new ParseException(msg);
	            }
		}
        )+
	     {
	         cm.name = new ModuleName(cm.name.toString()+" "+sum);
	     }
     ]
     "."
         {
            try {
	      if (mode == FILE_INPUT) {
                      writer.write("======================"+
                                  "====================\n");
                      writer.write("use "+cm.name+"\n");
	              writer.flush();
              }

	   } catch (Exception e) {
              String msg = e.getMessage()+" at line "+
			   btoken.beginLine+", column "+
			   btoken.beginColumn;
	      throw new ParseException(msg);
	   }
	   return cm;

        }

}



View MorphismDecl() :
{
    String viewName;
    Module source, target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
    boolean hasParameter = false;
    boolean force = true;
    ArrayList views = null ;
}
{
   (token=<IDENTIFIER> | token=<INTEGER_LITERAL>)
      {
	 viewName = token.image;
         Module pmod = null;
      }
   [
     "["
          {
	      String str = "parameter-module-in-view"+token.image;
	      ModuleName modName = new ModuleName(str);
	      pmod = new Module(Module.LOOSE, modName);
	      Module mod;
              List list = new ArrayList();
	  }
      (token=<IDENTIFIER>
	     {
		list.add(token.image);
	     }
      )+
      "::"
      mod=ModExpr(pmod)
	 {
               try {
		   for (int i=0; i<list.size(); i++) {
		       String paraName = (String)list.get(i);
	               pmod.addParameter(paraName, mod, getEnv());
		       paraPool.put(paraName, mod);
                   }
	       } catch (SignatureException e) {
		   String msg = e.getMessage()+" at line "+
			        token.beginLine+" column "+
		                token.beginColumn;
                   throw new ParseException(msg);
	       } catch (ModuleParameterException e) {
		   String msg = e.getMessage()+" at line "+
			        token.beginLine+" column "+
		                token.beginColumn;
                   throw new ParseException(msg);
	       }
	  }
      (
          ","
               {
		   list = new ArrayList();
	       }
          (
            token=<IDENTIFIER>
	       {
		   list.add(token.image);
	       }
          )+
          "::"
          mod=ModExpr(pmod)
	     {
                 try {
		     for (int i=0; i<list.size(); i++) {
		         String paraName = (String)list.get(i);
	                 pmod.addParameter(paraName, mod, getEnv());
			 paraPool.put(paraName, mod);
                     }
	         } catch (SignatureException e) {
		     String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                     throw new ParseException(msg);
	         } catch (ModuleParameterException e) {
		     String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                     throw new ParseException(msg);
	         }
	    }
     )*
     "]"
          {
	     hasParameter = true;
	  }
   ]
   "from"
   (source=ModExpr(pmod))
   "to"
   (target=ModExpr(pmod))
   "is"
      [
        (
          LOOKAHEAD(3)
	  "["
	       {
                  force = false;
                  int index = 0;
		  View[] vs = new View[source.paraNames.size()];
		  Module[] mds = new Module[vs.length];
		  String[] ns = new String[vs.length];
		  views = new ArrayList();

                  Module psrc = null;
                  Module ptgt = null;
		  try {
	              psrc = target.getParameterAt(index);
                      ptgt = source. getParameterAt(index);
                      //ns[index] = source.getParameterNameAt(index);
		  } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			          token.beginLine+" column "+
		                  token.beginColumn;
                      throw new ParseException(msg);
	          }

		  Module md;
	       }

               (
	           mds[index] = LocalViewDecl(pmod, psrc, new Vector())
                |
                   token=<IDENTIFIER>
                      {
         	           View aView = (View)viewPool.get(token.image);
                           if (aView != null) {
	                      mds[index] = (Module)aView.getTarget().clone();
                              mds[index].setProperty("view", aView);
                           } else { 
                              String msg = "No view with the name "+
					   token.image+" was found, at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

			   if (! psrc.modName.equals(aView.source.modName)) {
                              String msg = "The view "+ token.image+
					   " is defined from the module "+
				           aView.source.modName+", not "+
					   psrc.modName+", at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

			   if (! ptgt.modName.equals(aView.target.modName)) {
                              String msg = "The view "+ token.image+
					   " is defined to the module "+
				           aView.target.modName+", not "+
					   ptgt.modName+", at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

		      }
               )
		  {
                     vs[index] = (View)mds[index].getProperty("view");
		     views.add(vs[index].copy(""));

		     try {
		        vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());

                        //mds[index] = vs[index].source;
                        mds[index] = vs[index].target;
		        mds[index].setProperty("view", vs[index]);

                     } catch (Exception e) {
                        String msg = e.getMessage()+" at line "+
			             token.beginLine+" column "+
		                     token.beginColumn;
                        throw new ParseException(msg);
	             }

		     index++;
		  }
               (
                  ","
                     {
		        try {
	                   psrc = target.getParameterAt(index);
                           ptgt = source. getParameterAt(index);
                           //ns[index] = source.getParameterNameAt(index);
                        } catch (ModuleParameterException e) {
		           String msg = e.getMessage()+" at line "+
			               token.beginLine+" column "+
		                       token.beginColumn;
                           throw new ParseException(msg);
	                }
                     }
                   (
                     mds[index] = LocalViewDecl(pmod, psrc, new Vector())
                    |
                     token=<IDENTIFIER>
                        {
         	           View aView = (View)viewPool.get(token.image);
                           if (aView != null) {
	                      mds[index] = (Module)aView.getTarget().clone();
                              mds[index].setProperty("view", aView);
                           } else { 
                              String msg = "No view with the name "+
					   token.image+" was found, at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

			   if (! psrc.modName.equals(aView.source.modName)) {
                              String msg = "The view "+ token.image+
					   " is defined from the module "+
				           aView.source.modName+", not "+
					   psrc.modName+", at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

			   if (! ptgt.modName.equals(aView.target.modName)) {
                              String msg = "The view "+ token.image+
					   " is defined to the module "+
				           aView.target.modName+", not "+
					   ptgt.modName+", at line "+
			                   token.beginLine+" column "+
		                           token.beginColumn;
                              throw new ParseException(msg);
                           }

		         }
                     )

		     {
                          vs[index] = (View)mds[index].getProperty("view");
		          views.add(vs[index].copy(""));

                          try {
		             vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());
                             //mds[index] = vs[index].source;
                             mds[index] = vs[index].target;
		             mds[index].setProperty("view", vs[index]);
                          } catch (Exception e) {
                             String msg = e.getMessage()+" at line "+
			             token.beginLine+" column "+
		                     token.beginColumn;
                             throw new ParseException(msg);
	                  }
		          index++;
		      }
               )* 
          "]"
               {
                   try {
                      md = target.instanceBy(mds, ns, getEnv(), false);
                   } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			           token.beginLine+" column "+
		                   token.beginColumn;
                      throw new ParseException(msg);
	           }

		   Module newTarget = md;
		   newTarget.modName = target.modName;
		   newTarget.paraNames.addAll(source.paraNames);
		   newTarget.paraModules.addAll(source.paraModules);
		   newTarget.levels = new int[1];
		   newTarget.levels[0] = source.paraNames.size();

		   target = newTarget;

	       }
         |
           token="[" "]"
               {
                   /*		   
		   try {
		      View[] vs = new View[source.paraNames.size()];
		      Module[] mds = new Module[vs.length];
		      String[] ns = new String[vs.length];
		      views = new ArrayList();

		      for (int index=0; index<vs.length; index++) {

                          Module psrc = target.getParameterAt(index);
                          Module ptgt = source.getParameterAt(index);

                          vs[index] = new View("", psrc, ptgt);
                          vs[index].validate();
                          views.add(vs[index].copy(""));

		          vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());
                          mds[index] = vs[index].target;
		          mds[index].setProperty("view", vs[index]);
                       }
                               
		       Module newTarget =
                           target.instanceBy(mds, ns, getEnv(), false);
		       newTarget.modName = target.modName;
		       newTarget.paraNames.addAll(source.paraNames);
		       newTarget.paraModules.addAll(source.paraModules);
		       newTarget.levels = new int[1];
		       newTarget.levels[0] = source.paraNames.size();

		       target = newTarget;

                   } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			           token.beginLine+" column "+
		                   token.beginColumn;
                      throw new ParseException(msg);
                   }
                   */

	       }
         )
      ]
        {

	    if (force) {

		   try {
		      View[] vs = new View[source.paraNames.size()];
		      Module[] mds = new Module[vs.length];
		      String[] ns = new String[vs.length];
		      views = new ArrayList();

		      for (int index=0; index<vs.length; index++) {

                          Module psrc = target.getParameterAt(index);
                          Module ptgt = source.getParameterAt(index);

                          vs[index] = new View("", psrc, ptgt);
                          vs[index].validate();
                          views.add(vs[index].copy(""));

		          vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
				      target.getParameterNameAt(index),
				      getEnv());
                          mds[index] = vs[index].target;
		          mds[index].setProperty("view", vs[index]);
                       }
                               
		       Module newTarget =
                           target.instanceBy(mds, ns, getEnv(), false);
		       newTarget.modName = target.modName;
		       newTarget.paraNames.addAll(source.paraNames);
		       newTarget.paraModules.addAll(source.paraModules);
		       newTarget.levels = new int[1];
		       newTarget.levels[0] = source.paraNames.size();

		       target = newTarget;

                   } catch (Exception e) {
		      String msg = e.getMessage()+" at line "+
			           token.beginLine+" column "+
		                   token.beginColumn;
                      throw new ParseException(msg);
                   }


            }

	    view = new View(viewName, source, target);
	    if (hasParameter) {
		view.record(pmod);
	    }
        }
   (
        {
	    Vector vnames = new Vector();
        }
      ("vars" | "var")
      (
         (token=<IDENTIFIER>)
            {
	       vnames.addElement(token);
	    }
      )+
      ":" 
      sort=SortReference(source)
      "."
           {

	      for (int i=0; i<vnames.size(); i++) {
		 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
	 	 } catch (ViewException e) {
		    String msg = e.getMessage();
		    msg += " at line "+tmp.beginLine+
			      ", column "+tmp.beginColumn+".";
		    throw new ParseException(msg);
		 }
	      }
           }
    |
      "sort"
	  {
	     token1 = getToken(0);
          }
      sort1=SortReference(source)
      "to"
          {
	     token2 = getToken(0);
          }
      sort2=SortReference(target)
      "."
         {
            try {

	      Sort tmp = view.getTarget(sort1);
	      if (tmp != null && tmp.equals(sort2)) {
                  System.out.println("=================="+
                                     "========================");
		  System.out.println("Warning: duplicate mapping from "+
				     sort1.getName()+" to "+sort2.getName()+
				     " at line "+token1.beginLine);
	      } 

              view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
	       String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
 	       throw new ParseException(msg);
            }
         }
    |
      {
	 String opname1, opname2;
      }
      "op"
          {
	     token1 = getToken(0);
	  }
      (
         (opname1=OpName())
       |
         "(" opname1=Term(view.getEnrichedTarget()) ")"
      )
      "to"
          {
	     token2 = getToken(0);
	  }
      (     
         (opname2=OpName())
       |
         "(" opname2=Term(view.getEnrichedTarget()) ")"
     )
      "."
          {
	     Operation[] ops1 = source.getOperationsWithName(opname1.trim());

             if (ops1.length > 1) {
		String msg = "Multiple operations with the name "+
			      opname1+" in the module "+source.getModuleName()+
			      " at line "+token1.beginLine+" column "+
			      token1.beginColumn+".";
                throw new ParseException(msg);
             }

             Operation op1, op2;

             if (ops1.length == 1) {

	        Operation[] ops2 =target.getOperationsWithName(opname2.trim());

                if (ops2.length > 1) {

                    Vector pool = new Vector();
		    for (int i=0; i<ops2.length; i++) {
		         boolean found = false;
		         for (int j=0; j<pool.size(); j++) {
		              Operation op = (Operation)pool.elementAt(j);
		              if (op.less(target, ops2[i])) {
			           pool.removeElementAt(j);
			           pool.insertElementAt(ops2[i], j);
			           found = true;
		              } else if (ops2[i].less(target, op)) {
			           found = true;
		              }
		         }

		         if (!found) {
		             pool.addElement(ops2[i]);
		         }
		    }

		    if (pool.size() > 1) {

		        String msg = "Multiple operations with the name "+
			             opname2+" in the module "+
                                     target.getModuleName()+
			             " at line "+token2.beginLine+" column "+
			             token2.beginColumn+".";
                        throw new ParseException(msg);
		    } else {
		        ops2 = new Operation[pool.size()];
		        pool.copyInto(ops2);
		    }
                }

                if (ops2.length == 0) {

	             // no operation is found, parse it as a term
	             try {
		          Term term = Term.parse(view.getEnrichedTarget(),
			                         opname2);
			  if (ops1[0].isConstant()) {

			     Term left = new Term(ops1[0]);
		             view.addTransformation(left, term);

	                  } else {
		              String msg = opname1.trim()+
					   " is not a constant in the module "+
					   source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
			     throw new ParseException(msg);
		          }

                     } catch (TermException e) {

                          ops2 =
			    target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

			     try {
                                op1 = ops1[0];
 		                op2 = ops2[0];
			        view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
	                        String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
 	                        throw new ParseException(msg);
		             }

			  } else {

		              String msg = "Unresolvable tokens "+
                                           opname2.trim()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                              throw new ParseException(msg);
                          }
	             }

	        } else {

		   op1 = ops1[0];
 		   op2 = ops2[0];

		   Operation tmp = view.getTarget(op1);
	           if (tmp != null && tmp.equals(op2)) {
                      System.out.println("======================"+
					 "====================");
	              System.out.println("Warning: duplicate mapping from "+
					  op1.getCleanName()+" to "+
				          op2.getCleanName()+
			        	  " at line "+token2.beginLine+
		                          " column "+token2.beginColumn+".");
	           }

		   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
	              String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
 	              throw new ParseException(msg);
		   }
		}

	     } else {

		// no operation is found, try to parse term
                boolean okay = false;
		Term left = null;
                Term right = null;

	        try {
                  StringReader sr = new StringReader(opname1);
		  BOBJ nbobj = new BOBJ(sr);
		  String strLeft = nbobj.Term(view.getEnrichedSource());

                  left =
		     Term.parse(view.getEnrichedSource(),
				strLeft);

		  sr = new StringReader(opname2);
		  nbobj = new BOBJ(sr);
		  String strRight = nbobj.Term(view.getEnrichedTarget());

		  right =
		     Term.parse(view.getEnrichedTarget(),
				strRight);

		  if (left != null && right != null) {
		     view.addTransformation(left, right);
		     okay = true;
		  }

                } catch (TermException e) {
                }

		if (!okay) {

		   Operation lop = null, rop = null;
		   if (left == null) {
                      Operation[] lops =
		          source.getOperationsWithCleanName(opname1.trim());
		      if (lops.length == 1) {
			 lop = lops[0];
                      }
		   }

                   if (right == null) {
                      Operation[] rops =
		          source.getOperationsWithCleanName(opname2.trim());
		      if (rops.length == 1) {
			 rop = rops[0];
                      }
		   }		   

                   // there are 3 cases:
                   try {
		       if (left != null && rop != null) {
			    view.addTransformation(left, new Term(rop));
			    okay = true;
		       } else if (lop != null && right != null) {
		            view.addTransformation(new Term(lop), right);
			    okay = true;
		       } else if (lop != null && rop != null) {
		            view.addOperationMap(lop, rop);
			    okay = true;
                       }
                   } catch (Exception ex) {}
		}


                if (!okay && left == null) {
		   String msg = "No operations with the name \""+
			     opname1.trim()+"\" in the module "+
			     source.getModuleName()+
			     " at line "+token1.beginLine+" column "+
			     token1.beginColumn+".";
                   throw new ParseException(msg);
                } else if (!okay && right == null) {
		   String msg = "No operations with the name \""+
			     opname2.trim()+"\" in the module "+
			     target.getModuleName()+
			     " at line "+token2.beginLine+" column "+
			     token2.beginColumn+".";
                   throw new ParseException(msg);
                } else if (!okay) {
		   String msg = "No parse "+
			        " at line "+token1.beginLine+" column "+
			        token1.beginColumn+".";
                   throw new ParseException(msg);

		}

	     } 

	  }
   )*
      {
         try {

	     if (views != null) {
		view.views = views;
                view.record();
	     }
             view.validate();
	     view.setAsMorphism();

	 } catch (ViewException e) {

	     Token xt = getToken(0);
             String msg = e.getMessage()+
		          " at line "+xt.beginLine+", column "+
			  xt.beginColumn+".";

	     if (detail) {
	        msg = "format:"+format(msg, 0)+"\n"+
		      "the failed view is\n"+e.getView();
             }

             throw new ParseException(msg);
       	 }

	 return view;
      }

}

