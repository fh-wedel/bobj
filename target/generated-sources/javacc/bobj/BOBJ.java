/* Generated By:JavaCC: Do not edit this line. BOBJ.java */
package bobj;

import java.util.*;
import java.io.*;

public class BOBJ implements BOBJConstants {

    final public static int KEYBOARD_INPUT = 0;
    final public static int FILE_INPUT = 1;

    public static BOBJ client;

    private String logo =
            "                     \u005c\u005c|||||||||||||||||/\u005cn"+
            "                   --- Welcome to BOBJ ---\u005cn"+
            "                     /|||||||||||||||||\u005c\u005c\u005cn"+
            "      BOBJ version 0.9.78 built: Tue Sep 18 16:15:05 PDT 2001\u005cn"+
            "               University of California, San Diego\u005cn"+
            "                  "+new java.util.Date()+"\u005cn";

    private String prompt = "BOBJ> ";
    private String pwd;                   // current working directory
    private int mode = KEYBOARD_INPUT;    // wait for input from keyboard
                                          // output is different if using
                                          // FILE_INPUT

    private Module currentModule;         // the lastest defined module 
    private Module dynmaicModule;         // an opening module
    private Cobasis currentCobasis;       // the latest defined cobasis
    private CaseModule localCase;
    private BOBJ root;
    private Term currentTerm;
    private Stack termStack = new Stack();

    private Date time = new Date();
    private boolean timeChecked = false;

    protected Hashtable modPool = new Hashtable();     // all defined modules
    private Module lastModule;
    private Hashtable viewPool = new Hashtable();    // all defined view
    private Hashtable paraPool;
    private Hashtable cobasisPool = new Hashtable(); // add defined cobasis
    private Hashtable casesPool = new Hashtable();
    private RewriteEngine engine;

    private boolean cobasisUpdated = true;
    private boolean trace = false;
    private boolean boolInclude = true;
    private boolean detail = false;
    private boolean lookForParameter = false;

    private Writer writer = new PrintWriter(System.out);

    public String getLogo() {
        return logo;
    }


    public String getPrompt() {
        return prompt;
    }


    public String getPwd() {
        if (pwd == null) {
            pwd = System.getProperty("user.dir");
        }
        return pwd;
    }


    private void setPwd(String pwd) {
        this.pwd = pwd;
    }


    public Module getCurrentModule() {
        return currentModule;
    }


    public Map getEnv() {

        Map map = new HashMap();

        Enumeration enum_ = modPool.keys();
        while (enum_.hasMoreElements()) {
            ModuleName modName = (ModuleName)enum_.nextElement();
            Module module = (Module)modPool.get(modName);
            map.put(modName, new Integer(module.type));
        }

        return map;

    }


    public static void parseFile(String fileName) throws ParseException {
        try {
            BOBJ parser = new BOBJ(new FileInputStream(fileName));
            parser.Command();
        } catch (FileNotFoundException e) {
            throw new ParseException("File " +fileName+" not found");
        } catch (java.io.IOException e) {
            throw new ParseException("io exception during parse "+fileName);
        }
    }


    protected static String format(String txt, int prefix) {

       String result = "";

       int size = prefix;
       StringTokenizer ster = new StringTokenizer(txt, " \u005cn");
       while (ster.hasMoreTokens()) {
          String  tmp = ster.nextToken();
          if (size + tmp .length()< 70) {
             result += tmp+" ";
             size += tmp.length()+1;
          } else {
             result += "\u005cn    "+tmp+" ";
             size = 5+tmp.length();
          }
       }

       return result;
    }


    public void setWriter(Writer writer) {
        this.writer = writer;
    }


    private void saveModule(Module module) {
        Enumeration enum_ = modPool.keys();
        while (enum_.hasMoreElements()) {
            ModuleName modName = (ModuleName)enum_.nextElement();
            if (modName.equals(module.getModuleName())) {
                modPool.remove(modName);
            }
        }
        modPool.put(module.getModuleName(), module);
        lastModule = module;
    }


    private boolean containsModule(ModuleName modName) {
        Enumeration enum_ = modPool.keys();
        while (enum_.hasMoreElements()) {
            ModuleName tmp = (ModuleName)enum_.nextElement();
            if (modName.equals(tmp)) {
                return true;
            }
        }
        return false;
    }


    private Module getModule(String name) {

        Module module = null;

        if (paraPool != null) {
             // find a module from parameter 
             module = (Module)paraPool.get(name);
        }

        if (module == null) {

             // find module from previously defined modules
             ModuleName modName = new ModuleName(name);

             module = null;
             Enumeration enum_ = modPool.keys();
             while (enum_.hasMoreElements()) {
                 ModuleName tmp = (ModuleName)enum_.nextElement();
                 if (tmp.equals(modName)) {
                     module = (Module)modPool.get(tmp);
                     module = (Module)module.clone();
                     break;
                 }
             }

        } else {
             module = (Module)module.clone();
             module.setProperty("parameter", name);
        }

        if (module == null) {

             // find module from system default modules
             module = ModuleFactory.getDefaultModule(name);
        }

        return module;

   }




    public static void main(String args[]) {

        //BOBJ client = new BOBJ(System.in);
        client = new BOBJ(System.in);

        try {

           client.getPwd();
           client.writer.write(client.getLogo());
           client.writer.flush();
           while (true) {
             try {
                client.writer.write(client.getPrompt());
                client.writer.flush();

                client.Command();

                int max = client.jj_input_stream.maxNextCharInd;
                int next = client.jj_input_stream.nextCharInd;

                boolean more = false;
                for (int i=next; i<max; i++){
                  if (client.jj_input_stream.nextCharBuf[i] != ' ' &&
                      client.jj_input_stream.nextCharBuf[i] != '\u005cn' &&
                      client.jj_input_stream.nextCharBuf[i] != '\u005ct' &&
                      client.jj_input_stream.nextCharBuf[i] != '\u005cr') {

                      more = true;
                  }
                }


                while (more) {
                   client.Command();

                   max = client.jj_input_stream.maxNextCharInd;
                   next = client.jj_input_stream.nextCharInd;

                   more = false;
                   for (int i=next; i<max; i++){
                      if (client.jj_input_stream.nextCharBuf[i] != ' ' &&
                          client.jj_input_stream.nextCharBuf[i] != '\u005cn' &&
                          client.jj_input_stream.nextCharBuf[i] != '\u005ct' &&
                          client.jj_input_stream.nextCharBuf[i] != '\u005cr' ) {
                        more = true;

                      }
                   }
                }

                client.ReInit(System.in);

             } catch (Throwable e) {

                // display error message
                String msg = e.getMessage();
                if (msg != null && msg.trim().length() > 0) {
                   client.writer.write(e.getMessage());
                   client.writer.write("\u005cn");
                   client.writer.flush();
                }

                if (client.mode != FILE_INPUT &&
                    msg.indexOf("Encountered \u005c"<EOF>\u005c"") != -1) {
                    System.exit(0);
                }

                // restart the parser
                client.ReInit(System.in);

             }
           }
       } catch (Exception ex) {

          String msg = ex.getMessage();
          if (msg != null && msg.length() > 0) {
              System.err.println(msg);
          }

       }

    }

/*****************************************
 * THE BOBJ LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/
  final public void Command() throws ParseException, IOException {
    Token token = null;
    Module module = null;
    View view = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUIT:
      jj_consume_token(QUIT);
         writer.write("Bye.\u005cn");
         writer.flush();
         System.exit(0);
      break;
    case LONGQUIT:
      jj_consume_token(LONGQUIT);
         writer.write("Bye.\u005cn");
         writer.flush();
         System.exit(0);
      break;
    case PWD:
      jj_consume_token(PWD);
         writer.write(getPwd()+"\u005cn");
         writer.flush();
      break;
    case CD:
      jj_consume_token(CD);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case OP:
      case OPS:
      case OPAS:
      case EQ:
      case CQ:
      case CEQ:
      case ASSOC:
      case COMM:
      case IDEM:
      case PREC:
      case IDR:
      case ID:
      case NONCONG:
      case MEMO:
      case LESS:
      case ARROW:
      case DOT:
      case VARSOF:
      case COLON:
      case DOUBLECOLON:
      case ADD:
      case SUM:
      case TO:
      case STAR:
      case LB:
      case RB:
      case DFN:
      case RED:
      case BRED:
      case SOLVE:
      case OPEN:
      case OPENR:
      case CLOSE:
      case VIEW:
      case ENDV:
      case FROM:
      case LOAD:
      case APPLY:
      case START:
      case AT:
      case WITH:
      case WITHIN:
      case PRINT:
      case PARENS:
      case OF:
      case QUIT:
      case PWD:
      case CD:
      case LS:
      case IN:
      case SHOW:
      case MAKE:
      case ENDM:
      case LET:
      case COMMENT:
      case COBASIS:
      case COB:
      case COV:
      case STOP:
      case SELECT:
      case SET:
      case TRACE:
      case ON:
      case OFF:
      case FULL:
      case PARSE:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case RULES:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case MORPH:
        token = MetaToken();
        break;
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         String dir = token.image;
         File file;
         if (dir.startsWith(File.separator)) {
             file = new File(dir);
         } else {
             file = new File(pwd+File.separator+dir);
         }

         if (file.exists() && file.isDirectory() && file.canRead()) {

             pwd = file.getAbsolutePath();
             StringTokenizer st = new StringTokenizer(pwd, File.separator);
             ArrayList list = new ArrayList();
             while (st.hasMoreTokens()) {
                list.add(st.nextToken());
             }

             pwd = "";
             int count = 0;
             for (int i=list.size()-1; i>-1; i--) {
                String tmp = (String)list.get(i);
                if (tmp.equals(".")) {
                    continue;
                } else if (tmp.equals("..")) {
                    count++;
                } else if (count > 0) {
                    count--;
                } else {
                    pwd = tmp+File.separator+pwd;
                }
             }
             pwd = File.separator+pwd;

           } else {
                writer.write(dir+": No such file or directory\u005cn");
                writer.flush();
           }
      break;
    case LS:
      jj_consume_token(LS);
         String[] files = (new File(getPwd())).list();

         int maxLength = -1;
         for (int i=0; i<files.length; i++) {
            maxLength = Math.max(files[i].length(), maxLength);
         }

         int column = 70/(maxLength+8);
         column++;
         int width = 70/column;

         String line = "";
         int colIndex = 0;
         for (int i=0; i<files.length; i++) {
         if (colIndex < column ) {
            line += files[i];
            for (int j=0; j<(width-files[i].length()); j++)
               line += " ";
            colIndex ++;
         } else {
            writer.write(line+"\u005cn");
            line = files[i];
            for (int j=0; j<(width-files[i].length()); j++)
               line += " ";
               colIndex = 1;
            }
         }
         writer.write(line+"\u005cn");
         writer.flush();
      break;
    case IN:
    case INPUT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
        break;
      case INPUT:
        jj_consume_token(INPUT);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
        break;
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case OP:
      case OPS:
      case OPAS:
      case EQ:
      case CQ:
      case CEQ:
      case ASSOC:
      case COMM:
      case IDEM:
      case PREC:
      case IDR:
      case ID:
      case NONCONG:
      case MEMO:
      case LESS:
      case ARROW:
      case DOT:
      case VARSOF:
      case COLON:
      case DOUBLECOLON:
      case ADD:
      case SUM:
      case TO:
      case STAR:
      case LB:
      case RB:
      case DFN:
      case RED:
      case BRED:
      case SOLVE:
      case OPEN:
      case OPENR:
      case CLOSE:
      case VIEW:
      case ENDV:
      case FROM:
      case LOAD:
      case APPLY:
      case START:
      case AT:
      case WITH:
      case WITHIN:
      case PRINT:
      case PARENS:
      case OF:
      case QUIT:
      case PWD:
      case CD:
      case LS:
      case IN:
      case SHOW:
      case MAKE:
      case ENDM:
      case LET:
      case COMMENT:
      case COBASIS:
      case COB:
      case COV:
      case STOP:
      case SELECT:
      case SET:
      case TRACE:
      case ON:
      case OFF:
      case FULL:
      case PARSE:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case RULES:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case MORPH:
        token = MetaToken();
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          String filename = token.image;
          if (filename.startsWith(File.separator)) {
            // do nothing
          } else {
             String pwd = getPwd();
             if (pwd.endsWith(File.separator)) {
                filename = getPwd() + filename;
             } else {
                filename = getPwd() + File.separator + filename;
             }
          }

          file = new File(filename);
          if (!file.exists() || !file.isFile()) {

            file = new File(filename+".bob");
            if (file.exists() && file.isFile()) {

               filename = filename+".bob";

            } else {

               file = new File(filename+".obj");
               if (file.exists() && file.isFile()) {
                  filename = filename+".obj";
               } else {
                  {if (true) throw new ParseException("can not find "+token.image+
                                           " in "+pwd);}
               }
            }
          }

          if (mode == FILE_INPUT ) {
              writer.write("==========================================\u005cn");
              writer.write("in "+token.image+"\u005cn");
              writer.flush();
          }

          RewriteEngine.cleanCache();

          FileInputStream fis =  new FileInputStream(filename);

          String newline = "\u005cn";
          ByteArrayInputStream bais =
              new ByteArrayInputStream(newline.getBytes());

          SequenceInputStream sis = new SequenceInputStream(fis, bais);

          BOBJ bobj = new BOBJ(sis);
          bobj.mode = FILE_INPUT;

          // give the current environment to new parser
          bobj.root = this;
          bobj.modPool = (Hashtable)modPool.clone();
          bobj.viewPool = (Hashtable)viewPool.clone();
          bobj.currentModule = this.currentModule;
          bobj.dynmaicModule = this.dynmaicModule;
          bobj.lastModule = this.lastModule;
          bobj.cobasisPool = this.cobasisPool;
          bobj.casesPool = this.casesPool;
          bobj.trace = this.trace;
          bobj.boolInclude = this.boolInclude;
          bobj.detail = this.detail;
          bobj.pwd = this.pwd;
          bobj.currentTerm = this.currentTerm;
          bobj.termStack = this.termStack;
          bobj.time = this.time;
          bobj.timeChecked = this.timeChecked;

          client = bobj;

          try {

               bobj.BatchCommand();

               if (this.root != null) {
                  writer.write("==========================================\u005cn");
                  writer.write("exiting "+filename+"\u005cn");
                  writer.flush();
               }

          } catch (Exception e) {

               //e.printStackTrace();

               writer.write("==========================================\u005cn");
               String msg = e.getMessage();
               if (msg != null &&
                   msg.startsWith("multiple parsing results:")) {
                   writer.write(msg+"\u005cn");
               } else if (msg != null &&
                   msg.startsWith("format:")) {
                   writer.write(msg.substring(7)+"\u005cn");
               } else if (msg != null && msg.length() > 0) {
                   if (msg.length() < 500 ||
                       msg.indexOf("Was expecting one of:") == -1) {
                      writer.write(format(msg,0)+"\u005cn");
                   } else {
                      writer.write(format(msg.substring(0, 500)+" ...... ",
                                          0)+
                                   "\u005cn");
                   }
               } else {
                   writer.write("BOBJ system error\u005cn");
                   e.printStackTrace();
               }
               writer.flush();

          } catch (Throwable e) {

                writer.write("==========================================\u005cn");
                String msg = e.getMessage();
                if (msg != null &&
                    msg.endsWith("Encountered: <EOF> after : \u005c"\u005c"")) {
                    writer.write(msg+"\u005cn");
                } else if (msg != null && msg.length() > 0){
                    writer.write(format(msg,0)+".\u005cn");
                } else if (e instanceof StackOverflowError) {
                   writer.write("stack overflow, there might have "+
                                "an infinite reduction.\u005cn");
                } else {
                    writer.write("BOBJ system error\u005cn");
                    //e.printStackTrace();
                }
                writer.flush();

          }

          // copy environment from the new parser
          Enumeration enum_ = bobj.modPool.keys();
          while (enum_.hasMoreElements()) {
              ModuleName modName = (ModuleName)enum_.nextElement();
              module = (Module)bobj.modPool.get(modName);
              //modPool.put(modName, module);
              saveModule(module);
          }

          enum_ = bobj.viewPool.keys();
          while (enum_.hasMoreElements()) {
              String key = (String)enum_.nextElement();
              view = (View)bobj.viewPool.get(key);
              viewPool.put(key, view);
          }

          currentModule = bobj.currentModule;
          dynmaicModule = bobj.dynmaicModule;
          currentCobasis = bobj.currentCobasis;
          lastModule = bobj.lastModule;
          trace = bobj.trace;
          boolInclude = bobj.boolInclude;
          detail = bobj.detail;
          currentTerm = bobj.currentTerm;
          termStack = bobj.termStack;
          time = bobj.time;
          timeChecked = bobj.timeChecked;

          pwd = bobj.pwd;

          if (engine != null) {
              engine.cleanCache();
          }
          cobasisUpdated = true;

          client = this;
      break;
    default:
      jj_la1[57] = jj_gen;
      if (jj_2_8(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(VIEW);
        token = jj_consume_token(IDENTIFIER);
        jj_consume_token(DOT);
               writer.write("==========================================\u005cn");

               view = (View)viewPool.get(token.image);

               if (view == null) {
                   writer.write("No view with the name "+
                                token.image+" is found\u005cn");
                   writer.flush();
               } else {
                   writer.write("\u005cn"+view+"\u005cn");
                   writer.flush();
               }
      } else if (jj_2_9(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(TIME);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
              Date now = new Date();
              writer.write("==========================================\u005cn");
              if (timeChecked) {
                 writer.write("elapsed time since the last time check : "+
                              (now.getTime()-time.getTime())+"ms\u005cn");
              } else {
                 writer.write("elapsed time from the beginning : "+
                              (now.getTime()-time.getTime())+"ms\u005cn");
                 timeChecked = true;
              }
              writer.flush();
      } else if (jj_2_10(2147483647)) {
           boolean all = false;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
                   if (token.image.equals("all")) {
                       all = true;
                   }
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        jj_consume_token(RULES);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
              writer.write("==========================================\u005cn");
              if (dynmaicModule == null) {
                    if (currentModule == null) {
                        writer.write("Warning: no module can be shown\u005cn");
                    } else {
                        writer.write("rules in "+
                                     currentModule.getModuleName()+":\u005cn");
                        writer.write("\u005cn"+currentModule.showRules(all)+"\u005cn");
                    }
               } else {
                    writer.write("rules in the current module:\u005cn");
                    writer.write("\u005cn"+dynmaicModule.showRules(all)+"\u005cn");
               }
               writer.flush();
      } else if (jj_2_11(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(PSORT);
        jj_consume_token(DOT);
              writer.write("==========================================\u005cn");
              if (dynmaicModule == null) {
                    if (currentModule == null) {
                        writer.write("Warning: no module is open\u005cn");
                    } else {
                        writer.write("principal sort in "+
                                     currentModule.getModuleName()+": ");
                        writer.write(currentModule.toString(currentModule.getPrincipalSort())+
                                     "\u005cn");
                    }
               } else {
                    writer.write("principal sort in "+
                                 dynmaicModule.getModuleName()+": ");
                    writer.write(dynmaicModule.toString(dynmaicModule.getPrincipalSort())+
                                 "\u005cn");
               }
               writer.flush();
      } else if (jj_2_12(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        module = ModExpr(null);
        jj_consume_token(DOT);
               writer.write("==========================================\u005cn");
               writer.write("\u005cn"+module+"\u005cn");
               writer.flush();
      } else if (jj_2_13(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SHOW:
          jj_consume_token(SHOW);
          break;
        case SH:
          jj_consume_token(SH);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(DOT);
               writer.write("==========================================\u005cn");
               if (dynmaicModule == null) {
                    if (currentModule == null) {
                        writer.write("Warning: no module can be shown\u005cn");
                    } else {
                        writer.write("\u005cn"+currentModule+"\u005cn");
                    }
               } else {
                    writer.write("\u005cn"+dynmaicModule+"\u005cn");
               }
               writer.flush();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case OBJECT:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OBJ:
            jj_consume_token(OBJ);
            break;
          case OBJECT:
            jj_consume_token(OBJECT);
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
               if (engine != null) {
                  engine.cleanCache();
               }

               dynmaicModule = null;
               paraPool = new Hashtable();
          module = Module(Module.INITIAL);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ENDO:
            jj_consume_token(ENDO);
            break;
          case END:
            jj_consume_token(END);
            break;
          case JBO:
            jj_consume_token(JBO);
            break;
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                if (mode == FILE_INPUT) {
                    writer.write("======================"+
                                 "====================\u005cn");
                    writer.write("obj "+module.getModuleName()+"\u005cn");
                }

                if (containsModule(module.getModuleName())) {
                    writer.write("Warning: redefining module "+
                                 module.getModuleName()+"\u005cn");
                }
                writer.flush();

                //modPool.put(module.getModuleName(), module);
                saveModule(module);
                currentModule = module;
                cobasisUpdated = true;
                paraPool = new Hashtable();
          break;
        case DTH:
          jj_consume_token(DTH);
                if (engine != null) {
                    engine.cleanCache();
                }

                dynmaicModule = null;
                paraPool = new Hashtable();
          module = Module(Module.INITIAL);
          jj_consume_token(END);
                if (mode == FILE_INPUT) {
                    writer.write("===================="+
                                 "======================\u005cn");
                    writer.write("dth "+module.getModuleName()+"\u005cn");
                }

                if (containsModule(module.getModuleName())) {
                    writer.write("Warning: redefining module "+
                                 module.getModuleName()+"\u005cn");
                }
                writer.flush();

                //modPool.put(module.getModuleName(), module);
                saveModule(module);
                currentModule = module;
                cobasisUpdated = true;
                paraPool = new Hashtable();
          break;
        case TH:
        case THEORY:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TH:
            jj_consume_token(TH);
            break;
          case THEORY:
            jj_consume_token(THEORY);
            break;
          default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                 if (engine != null) {
                    engine.cleanCache();
                 }

                 dynmaicModule = null;
                 paraPool = new Hashtable();
          module = Module(Module.LOOSE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ENDTH:
            jj_consume_token(ENDTH);
            break;
          case END:
            jj_consume_token(END);
            break;
          case HT:
            jj_consume_token(HT);
            break;
          default:
            jj_la1[15] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                 if (mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("th "+module.getModuleName()+"\u005cn");
                     writer.flush();
                 }

                 if (containsModule(module.getModuleName())) {
                     writer.write("Warning: redefining module "+
                                  module.getModuleName()+"\u005cn");
                     writer.flush();
                 }
                 writer.flush();

                 //modPool.put(module.getModuleName(), module);
                 saveModule(module);
                 currentModule = module;
                 cobasisUpdated = true;
                 paraPool = new Hashtable();
          break;
        case BTH:
          jj_consume_token(BTH);
                 if (engine != null) {
                    engine.cleanCache();
                 }

                 dynmaicModule = null;
                 paraPool = new Hashtable();
          module = Module(Module.BEHAVORIAL);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ENDB:
            jj_consume_token(ENDB);
            break;
          case END:
            jj_consume_token(END);
            break;
          default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                 if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\u005cn");
                     writer.write("bth "+module.getModuleName()+"\u005cn");
                     writer.flush();
                 }

                 if (modPool.containsKey(module.getModuleName())) {
                      writer.write("Warning: redefining module "+
                                   module.getModuleName()+"\u005cn");
                      writer.flush();
                 }

                 //modPool.put(module.getModuleName(), module);
                 saveModule(module);
                 currentModule = module;
                 cobasisUpdated = true;
                 paraPool = new Hashtable();
          break;
        default:
          jj_la1[58] = jj_gen;
          if (getToken(1).image.equals("cases")) {
            jj_consume_token(IDENTIFIER);
            // cases
                  token = jj_consume_token(IDENTIFIER);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case FOR:
              jj_consume_token(FOR);
              module = ModExpr(null);
                 ModuleName modName = new ModuleName(token.image);
                 CaseModule cm = new CaseModule(modName, module);
              jj_consume_token(IS);
              label_1:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case CONTEXT:
                  ContextDecl(cm);
                  break;
                case VAR:
                case VARS:
                  VarDecl(cm);
                  break;
                case CASE:
                  CaseDecl(cm);
                  break;
                default:
                  jj_la1[17] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case VAR:
                case VARS:
                case CONTEXT:
                case CASE:
                  ;
                  break;
                default:
                  jj_la1[18] = jj_gen;
                  break label_1;
                }
              }
              jj_consume_token(END);
                 if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\u005cn");
                     writer.write("cases "+cm.getModuleName()+"\u005cn");
                     writer.flush();
                 }

                 if (casesPool.containsKey(token.image)) {
                      writer.write("Warning: redefining module "+
                                   token.image+"\u005cn");
                      writer.flush();
                 }

                 casesPool.put(token.image, cm);
              break;
            case IS:
              jj_consume_token(IS);
                     ArrayList cmlist = new ArrayList();
                     modName = new ModuleName(token.image);
              token = jj_consume_token(IDENTIFIER);
                      CaseModule tmp = (CaseModule)casesPool.get(token.image);
                      if (tmp == null) {
                          String msg = "no cases with the name "+
                                       token.image+" at "+
                                       "line "+token.beginLine+", column "+
                                       token.beginColumn;
                          {if (true) throw new ParseException(msg);}
                      }
                      cmlist.add(tmp);
              label_2:
              while (true) {
                jj_consume_token(STAR);
                token = jj_consume_token(IDENTIFIER);
                      tmp = (CaseModule)casesPool.get(token.image);
                      if (tmp == null) {
                          String msg = "no cases with the name "+
                                       token.image+" at "+
                                       "line "+token.beginLine+", column "+
                                       token.beginColumn;
                          {if (true) throw new ParseException(msg);}
                      }
                      cmlist.add(tmp);
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case STAR:
                  ;
                  break;
                default:
                  jj_la1[19] = jj_gen;
                  break label_2;
                }
              }
                      try {
                          cm = new CaseModule(modName, cmlist);
                      } catch (CaseModuleException e) {
                          String msg =  e.getMessage()+" at line "+
                                        token.beginLine+", column "+
                                        token.beginColumn;
                          {if (true) throw new ParseException(msg);}
                      }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case IDENTIFIER:
                token = jj_consume_token(IDENTIFIER);
                        if (!token.image.equals("exclude")) {
                           String msg = "expect \u005c"exclude\u005c" at line "+
                                        token.beginLine+", column "+
                                        token.beginColumn;
                           {if (true) throw new ParseException(msg);}
                        }

                        Token btoken = token;
                label_3:
                while (true) {
                        String label = "";
                  jj_consume_token(144);
                  token = jj_consume_token(INTEGER_LITERAL);
                            label += token.image;
                  label_4:
                  while (true) {
                    jj_consume_token(145);
                    token = jj_consume_token(INTEGER_LITERAL);
                             label += ","+token.image;
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case 145:
                      ;
                      break;
                    default:
                      jj_la1[20] = jj_gen;
                      break label_4;
                    }
                  }
                  jj_consume_token(146);
                              // change case
                              try {
                                 cm.remove(label);
                              } catch (Exception e) {
                                 String msg = e.getMessage()+" at line "+
                                        btoken.beginLine+", column "+
                                        btoken.beginColumn;
                                 {if (true) throw new ParseException(msg);}
                              }
                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                  case 144:
                    ;
                    break;
                  default:
                    jj_la1[21] = jj_gen;
                    break label_3;
                  }
                }
                break;
              default:
                jj_la1[22] = jj_gen;
                ;
              }
              jj_consume_token(END);
                   if (mode == FILE_INPUT) {
                      writer.write("======================"+
                                  "====================\u005cn");
                      writer.write("cases "+cm.getModuleName()+"\u005cn");
                      writer.flush();
                   }

                   if (casesPool.containsKey(cm.getModuleName().toString())) {
                       writer.write("Warning: redefining module "+
                                    cm.getModuleName()+"\u005cn");
                       writer.flush();
                   }

                   casesPool.put(cm.getModuleName().toString(), cm);
              break;
            default:
              jj_la1[23] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case VIEW:
              jj_consume_token(VIEW);
                dynmaicModule = null;
                token = getToken(0);
                paraPool = new Hashtable();
              view = ViewDecl();
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case ENDV:
                jj_consume_token(ENDV);
                break;
              case END:
                jj_consume_token(END);
                break;
              case WEIV:
                jj_consume_token(WEIV);
                break;
              case ENDVIEW:
                jj_consume_token(ENDVIEW);
                break;
              default:
                jj_la1[24] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
                paraPool = new Hashtable();
                try {
                     view.validate();
                } catch (ViewException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+", column "+
                                  token.beginColumn;

                     if (detail) {
                          msg = "format:"+format(msg, 0)+"\u005cn"+
                                "the failed view is\u005cn"+e.getView();
                     }

                     {if (true) throw new ParseException(msg);}
                }

                writer.write("==========================================\u005cn");

                if (viewPool.containsKey(view.getName())) {
                    writer.write("Warning: redefining view "+view.getName()+"\u005cn");
                } else {
                    writer.write("view "+view.getName()+"\u005cn");
                }

                writer.flush();

                viewPool.put(view.getName(), view);
              break;
            case MORPH:
              jj_consume_token(MORPH);
                dynmaicModule = null;
                token = getToken(0);
                paraPool = new Hashtable();
              view = MorphismDecl();
              jj_consume_token(END);
                paraPool = new Hashtable();
                try {
                     view.validate();
                } catch (ViewException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+", column "+
                                  token.beginColumn;

                     if (detail) {
                          msg = "format:"+format(msg, 0)+"\u005cn"+
                                "the failed view is\u005cn"+e.getView();
                     }

                     {if (true) throw new ParseException(msg);}
                }

                writer.write("==========================================\u005cn");
                //writer.write("morph "+view.getName()+"\n");

                if (viewPool.containsKey(view.getName())) {
                    writer.write("Warning: redefining morph "+view.getName()+"\u005cn");
                } else {
                    writer.write("morph "+view.getName()+"\u005cn");
                }

                writer.flush();


                viewPool.put(view.getName(), view);
              break;
            case COBASIS:
            case COB:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COBASIS:
                jj_consume_token(COBASIS);
                break;
              case COB:
                jj_consume_token(COB);
                break;
              default:
                jj_la1[25] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
                Sort[] csorts;
                Operation cop;
                Cobasis cob;
              token = jj_consume_token(IDENTIFIER);
                cob = new Cobasis(token.image);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case FROM:
                jj_consume_token(FROM);
                module = ModExpr(null);
                 cob.setModule(module);
                break;
              default:
                jj_la1[26] = jj_gen;
                ;
              }
              jj_consume_token(IS);
                if (module == null) {
                    writer.write("======================="+
                                 "===================\u005cn");
                    writer.write("No module is specified for "+
                                 "cobasis declaration at line "+
                                  token.beginLine+"\u005cn");
                    writer.write("use the last module instead.\u005cn");
                    if (lastModule != null) {
                        module = lastModule;
                    }
                }
              label_5:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case SORT:
                case SORTS:
                  csorts = CobSortsDecl(module);
                   for (int i=0; i<csorts.length; i++) {
                        try {
                           cob.add(csorts[i]);
                        } catch (CobasisException ex) {
                           Token xt = getToken(0);
                           String msg = ex.getMessage()+" at line "+
                                    xt.beginLine+", column "+xt.endColumn+".";
                           {if (true) throw new ParseException(msg);}
                        }
                    }
                  break;
                case OP:
                  cop = CobOpDecl(module);
                    try {
                         cob.add(cop);
                    } catch (CobasisException ex) {
                        Token xt = getToken(0);
                        String msg = ex.getMessage()+" at line "+
                                     xt.beginLine+", column "+xt.endColumn+".";
                        {if (true) throw new ParseException(msg);}
                     }
                  break;
                default:
                  jj_la1[27] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case SORT:
                case SORTS:
                case OP:
                  ;
                  break;
                default:
                  jj_la1[28] = jj_gen;
                  break label_5;
                }
              }
              jj_consume_token(END);
              cobasisPool.put(token.image, cob);
              break;
            case MAKE:
              jj_consume_token(MAKE);
               if (engine != null) {
                  engine.cleanCache();
               }

               dynmaicModule = null;
               paraPool = new Hashtable();
              token = jj_consume_token(IDENTIFIER);
              jj_consume_token(IS);
              module = ModExpr(null);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case ENDM:
                jj_consume_token(ENDM);
                break;
              case END:
                jj_consume_token(END);
                break;
              default:
                jj_la1[29] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              if (mode == FILE_INPUT) {
                  writer.write("==========================================\u005cn");
                  writer.write("make "+token.image+"\u005cn");
                  writer.flush();
              }

              ModuleName mn = new ModuleName(token.image);
              Module result = new Module(module.getType(), mn);
              try {
                  result.importModule(module);
                  result.protectImportList.addAll(module.protectImportList);
                  result.extendImportList.addAll(module.extendImportList);
                  result.useImportList.addAll(module.useImportList);

                  result.paraNames = (ArrayList)module.paraNames.clone();
                  result.paraModules = (ArrayList)module.paraModules.clone();
                  if (module.bindings != null) {
                      result.bindings = (Hashtable)module.bindings.clone();
                  }
                  result.levels = module.levels;

              } catch (SignatureException e) {}

              //modPool.put(mn, module);

              saveModule(result);
              currentModule = result;

              cobasisUpdated = true;
              dynmaicModule = null;
              break;
            default:
              jj_la1[59] = jj_gen;
              if (jj_2_14(2147483647)) {
                jj_consume_token(OPEN);
               RewriteEngine.cleanCache();
                module = ModExpr(null);
                jj_consume_token(DOT);
              if (mode == FILE_INPUT) {
                  writer.write("==========================================\u005cn");
              }

              if (dynmaicModule != null) {


                  if (mode != FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\u005cn");
                  }

                  if (dynmaicModule.modName.equals(module.modName)) {

                       dynmaicModule = (Module)module.clone();
                       writer.write("Warning: module "+module.modName+
                                    " is closed\u005cn");
                       writer.write("reopen "+module.getModuleName()+"\u005cn");
                       writer.flush();

                  } else {
                       writer.write("Warning: module "+
                                    dynmaicModule.modName+" is closed\u005cn");

                       dynmaicModule = (Module)module.clone();
                       writer.write("open "+module.getModuleName()+"\u005cn");
                       writer.flush();
                  }

              } else {

                  dynmaicModule = (Module)module.clone();

                  if (mode == FILE_INPUT) {
                      writer.write("open "+module.getModuleName()+"\u005cn");
                      writer.flush();
                  }
              }
              } else if (jj_2_15(2147483647)) {
                jj_consume_token(OPENR);
              if (engine != null) {
                  engine.cleanCache();
              }
                module = ModExpr(null);
                jj_consume_token(DOT);
              dynmaicModule = module;
              dynmaicModule.setProperty("save", "");

              if (mode == FILE_INPUT) {
                  writer.write("==========================================\u005cn");
                  writer.write("openr "+module.getModuleName()+"\u005cn");
                  writer.flush();
              }
              } else if (jj_2_16(2147483647)) {
            CaseModule cm;
                cm = CaseExp();
             if (dynmaicModule == null) {
                writer.write("==========================================\u005cn");
                writer.write("Warning: use command only can"+
                             " be used in an open command\u005cn");
                writer.write("use command at line "+getToken(0).beginLine+
                             " is ignored\u005cn");
                writer.flush();
             } else {
                localCase = cm;
             }
              } else if (jj_2_17(2147483647)) {
                token = jj_consume_token(SELECT);
              if (engine != null) {
                  engine.cleanCache();
              }
              cobasisUpdated = true;
                module = ModExpr(null);
                jj_consume_token(DOT);
               if (mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
               }

               if (dynmaicModule != null) {


                   if (mode != FILE_INPUT) {
                        writer.write("====================="+
                                     "=====================\u005cn");
                   }

                   if (dynmaicModule.modName.equals(module.modName)) {
                        writer.write("Warning: select open module "+
                                     module.modName+" at "+
                                     "line "+token.beginLine+"\u005cn");
                        writer.write("select command is ignored\u005cn");
                        writer.flush();
                   }  else {
                        writer.write("Warning: select module "+module.modName+
                                     " when module "+dynmaicModule.modName+
                                     " is open at line "+
                                      token.beginLine+"\u005cn");
                        writer.write("module "+dynmaicModule.modName+
                                     " is closed\u005cn");
                        dynmaicModule = null;
                        currentModule = module;
                        writer.write("select "+module.getModuleName()+"\u005cn");
                        writer.flush();
                   }
               } else {
                   currentModule = module;

                   if (mode == FILE_INPUT) {
                       writer.write("select "+module.getModuleName()+"\u005cn");
                       writer.flush();
                   }
               }
              } else if (jj_2_18(5)) {
                jj_consume_token(OPEN);
                jj_consume_token(DOT);
               if (engine != null) {
                   engine.cleanCache();
               }

               if (currentModule == null) {
                    writer.write("Error: no last module\u005cn");
                    writer.flush();
               } else {
                    dynmaicModule = (Module)currentModule.clone();
               }

               if (mode == FILE_INPUT) {
                    writer.write("======================="+
                                 "===================\u005cn");
                    writer.write("open\u005cn");
                    writer.flush();
               }
              } else if (jj_2_19(5)) {
                jj_consume_token(OPENR);
                jj_consume_token(DOT);
               if (engine != null) {
                   engine.cleanCache();
               }

               if (currentModule == null) {
                    writer.write("Error: no last module\u005cn");
                    writer.flush();
               } else {
                    dynmaicModule = currentModule;
                    dynmaicModule.setProperty("save", "");
               }

               if (mode == FILE_INPUT) {
                    writer.write("======================="+
                                 "===================\u005cn");
                    writer.write("openr\u005cn");
                    writer.flush();
               }
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case CLOSE:
                  jj_consume_token(CLOSE);
               if (dynmaicModule != null) {

                    dynmaicModule.umaskAll();

                    if (dynmaicModule.getProperty("save") != null &&
                        dynmaicModule.modName.op == ModuleName.ATOM) {

                        saveModule(dynmaicModule);
                        dynmaicModule.removeProperty("save");
                        currentModule = dynmaicModule;

                    }

                    dynmaicModule = null;
                    localCase = null;

                    if (mode == FILE_INPUT) {
                         writer.write("======================="+
                                      "===================\u005cn");
                         writer.write("close\u005cn");
                         writer.flush();
                    }

                } else {
                    writer.write("Warning: all modules are closed\u005cn");
                    writer.flush();
                }

                cobasisUpdated = true;
                  break;
                case PARSE:
                  jj_consume_token(PARSE);
                if (dynmaicModule != null) {
                     module = dynmaicModule;
                } else {
                     module = currentModule;
                }

                if (module == null) {
                    writer.write("Warning: no module input yet,"+
                                 " use BOOL instead\u005cn");
                    writer.flush();
                    module = ModuleFactory.createBool();
                }

                String string;
                  string = Term(module);
                  jj_consume_token(DOT);
                 if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\u005cn");
                     writer.write("parse: "+format(string, 13)+"\u005cn");
                 }

                 try {

                     long beginTime = new Date().getTime();
                     Term term = Term.parse(module, string);
                     long parseTime = new Date().getTime() - beginTime;

                     writer.write("time: "+parseTime+"ms\u005cn");
                     writer.write("result:\u005cn");
                     writer.write(term.showStructure(module)+"\u005cn");
                     writer.flush();


                 } catch (TermException e) {
                     token = getToken(0);
                     writer.write("====================="+
                                  "=====================\u005cn");
                     if (e.getCount() > 0) {
                         writer.write(e.getMessage()+"\u005cnat line "+
                                      token.beginLine+".\u005cn");
                     } else {
                         writer.write(e.getMessage()+"at line "+
                                      token.beginLine+".\u005cn");
                     }
                     writer.flush();
                 }
                  break;
                default:
                  jj_la1[60] = jj_gen;
                  if (getToken(1).image.equals("restore")) {
                    jj_consume_token(IDENTIFIER);
                    jj_consume_token(DOT);
              currentModule = null;
              dynmaicModule = null;
              currentCobasis = null;
              currentTerm = null;
              termStack = new Stack();
              modPool = new Hashtable();
              lastModule = null;
              viewPool = new Hashtable();
              paraPool = null;
              cobasisPool = new Hashtable();
              casesPool = new Hashtable();
              cobasisUpdated = false;
              trace = false;
              boolInclude = true;
              detail = false;
                  } else if (getToken(1).image.equals("mask")) {
                    jj_consume_token(IDENTIFIER);
                    label_6:
                    while (true) {
                      token = jj_consume_token(IDENTIFIER);
                String eqName = token.image;

                if (eqName.startsWith(".")) {
                   eqName = eqName.substring(1);

                   if (dynmaicModule == null) {
                       String msg= "no module is open when mask "+
                                   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }

                   Equation eq = dynmaicModule.getEquation(eqName);
                   if (eq == null) {
                       try {
                           int pos = Integer.parseInt(eqName);
                           eq = dynmaicModule.getRule(pos);
                       } catch (Exception e){
                       }

                       if (eq == null) {
                           String msg= "no equation with name "+eqName+
                                " at line "+token.beginLine+
                                ", column "+token.endColumn+".";
                           {if (true) throw new ParseException(msg);}
                        }
                   }

                   dynmaicModule.mask(eq);

                } else if (eqName.equals("all")) {

                   if (dynmaicModule == null) {
                       String msg= "no module is open when mask "+
                                   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }

                   dynmaicModule.maskAll();
                } else {
                   {if (true) throw new ParseException("expect an identifier starting "+
                                            "with \u005c".\u005c" at line "+
                                            token.beginLine+" column "+
                                            token.beginColumn);}
                }
                      if (jj_2_1(10)) {
                        ;
                      } else {
                        break label_6;
                      }
                    }
                    jj_consume_token(DOT);
                  } else if (getToken(1).image.equals("umask")) {
                    jj_consume_token(IDENTIFIER);
                    label_7:
                    while (true) {
                      token = jj_consume_token(IDENTIFIER);
                String eqName = token.image;

                if (eqName.startsWith(".")) {
                   eqName = eqName.substring(1);

                   if (dynmaicModule == null) {
                       String msg= "no module is open when mask "+
                                   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }

                   Equation eq = dynmaicModule.getEquation(eqName);
                   if (eq == null) {
                       try {
                           int pos = Integer.parseInt(eqName);
                           eq = dynmaicModule.getRule(pos);
                       } catch (Exception e){
                       }

                       if (eq == null) {
                           String msg= "no equation with name "+eqName+
                                " at line "+token.beginLine+
                                ", column "+token.endColumn+".";
                           {if (true) throw new ParseException(msg);}
                        }
                   }

                   dynmaicModule.umask(eq);

                } else if (eqName.equals("all")) {

                   if (dynmaicModule == null) {
                       String msg= "no module is open when mask "+
                                   "the equation "+eqName+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }

                   dynmaicModule.umaskAll();
                } else {
                   {if (true) throw new ParseException("expect an identifier starting "+
                                            "with \u005c".\u005c" at line "+
                                            token.beginLine+" column "+
                                            token.beginColumn);}
                }
                      if (jj_2_2(10)) {
                        ;
                      } else {
                        break label_7;
                      }
                    }
                    jj_consume_token(DOT);
                  } else if (getToken(1).image.equals("do")  &&
                                      getToken(2).image.equals("restore")  &&
                                      getToken(3).image.equals("init")) {
                    jj_consume_token(IDENTIFIER);
                    jj_consume_token(IDENTIFIER);
                    jj_consume_token(IDENTIFIER);
                    jj_consume_token(DOT);
              currentModule = null;
              dynmaicModule = null;
              currentCobasis = null;
              currentTerm = null;
              termStack = new Stack();
              modPool = new Hashtable();
              lastModule = null;
              viewPool = new Hashtable();
              paraPool = null;
              cobasisPool = new Hashtable();
              casesPool = new Hashtable();
              cobasisUpdated = false;
              trace = false;
              boolInclude = true;
              detail = false;
                  } else if (getToken(1).image.equals("call-that")) {
                    jj_consume_token(IDENTIFIER);
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case IDENTIFIER:
                      token = jj_consume_token(IDENTIFIER);
                      break;
                    case INTEGER_LITERAL:
                      token = jj_consume_token(INTEGER_LITERAL);
                      break;
                    case OBJ:
                    case TH:
                    case BTH:
                    case DTH:
                    case ENDO:
                    case ENDTH:
                    case ENDB:
                    case ENDD:
                    case END:
                    case PR:
                    case PROTECTING:
                    case EX:
                    case EXTENDING:
                    case US:
                    case USING:
                    case INC:
                    case INCLUDING:
                    case IS:
                    case SORT:
                    case SORTS:
                    case BSORT:
                    case BSORTS:
                    case SUBSORT:
                    case SUBSORTS:
                    case VAR:
                    case VARS:
                    case OP:
                    case OPS:
                    case OPAS:
                    case EQ:
                    case CQ:
                    case CEQ:
                    case ASSOC:
                    case COMM:
                    case IDEM:
                    case PREC:
                    case IDR:
                    case ID:
                    case NONCONG:
                    case MEMO:
                    case LESS:
                    case ARROW:
                    case DOT:
                    case VARSOF:
                    case COLON:
                    case DOUBLECOLON:
                    case ADD:
                    case SUM:
                    case TO:
                    case STAR:
                    case LB:
                    case RB:
                    case DFN:
                    case RED:
                    case BRED:
                    case SOLVE:
                    case OPEN:
                    case OPENR:
                    case CLOSE:
                    case VIEW:
                    case ENDV:
                    case FROM:
                    case LOAD:
                    case APPLY:
                    case START:
                    case AT:
                    case WITH:
                    case WITHIN:
                    case PRINT:
                    case PARENS:
                    case OF:
                    case QUIT:
                    case PWD:
                    case CD:
                    case LS:
                    case IN:
                    case SHOW:
                    case MAKE:
                    case ENDM:
                    case LET:
                    case COMMENT:
                    case COBASIS:
                    case COB:
                    case COV:
                    case STOP:
                    case SELECT:
                    case SET:
                    case TRACE:
                    case ON:
                    case OFF:
                    case FULL:
                    case PARSE:
                    case INCLUDE:
                    case REDUCTION:
                    case REDUCE:
                    case TIME:
                    case RULES:
                    case JBO:
                    case ASSOCIATIVE:
                    case COMMUTATIVE:
                    case HT:
                    case WEIV:
                    case ENDVIEW:
                    case GATHERING:
                    case PRECEDENCE:
                    case THEORY:
                    case SH:
                    case LONGQUIT:
                    case IDEMPOTENT:
                    case OBJECT:
                    case IDENTITY:
                    case DEFINE:
                    case INPUT:
                    case MORPH:
                      token = MetaToken();
                      break;
                    default:
                      jj_la1[30] = jj_gen;
                      jj_consume_token(-1);
                      throw new ParseException();
                    }
                    jj_consume_token(DOT);
                if (currentTerm != null) {

                   if (dynmaicModule != null) {
                      try {
                         Operation op = new Operation(token.image,
                                                      currentTerm.sort);
                         Equation eq = new Equation(new Term(op, new Term[]{}),
                                                    currentTerm);
                         dynmaicModule.addOperation(op);
                         dynmaicModule.addEquation(eq);
                      } catch (Exception e) {
                         String msg = e.getMessage()+
                                      " at line "+token.beginLine+", column "+
                                      token.beginColumn;
                         {if (true) throw new ParseException(msg);}
                      }
                   } else {
                      String msg = "no module is open for \u005c"call-that\u005c""+
                                   " at line "+
                                   token.beginLine+", column "+
                                   token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                   }
                } else {
                   String msg = "no term is define for \u005c"call-that\u005c" at line "+
                                token.beginLine+", column "+
                                token.beginColumn;
                   {if (true) throw new ParseException(msg);}
                }
                  } else {
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case RED:
                    case REDUCE:
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case RED:
                        jj_consume_token(RED);
                        break;
                      case REDUCE:
                        jj_consume_token(REDUCE);
                        break;
                      default:
                        jj_la1[31] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
               module = null;
               if (engine != null) {
                   engine.cleanCache();
               }
                      if (jj_2_4(2147483647)) {
                        jj_consume_token(IN);
              Token modToken = null;
                        if (jj_2_3(2147483647)) {
                          modToken = jj_consume_token(IDENTIFIER);
                          jj_consume_token(IS);
                        } else {
                          ;
                        }
                        module = ModExpr(null);
               if (modToken != null) {
                   ModuleName modName = new ModuleName(modToken.image);
                   Module tmpMod = (Module)module.clone();
                   tmpMod.modName = modName;

                   saveModule(tmpMod);
               }

               if (engine != null) {
                   engine.cleanCache();
               }

               dynmaicModule = module;
                        jj_consume_token(COLON);
                      } else {
                        ;
                      }
                 if (module == null) {
                      module = (dynmaicModule != null) ?
                               dynmaicModule : currentModule;
                 }

                 if (module == null) {
                     writer.write("Warning: no module input yet, "+
                                  "use BOOL instead\u005cn");
                     writer.flush();
                     module = ModuleFactory.createBool();
                 }
                      string = Term(module);
                      jj_consume_token(DOT);
             try {

                 long beginTime = new Date().getTime();
                 Term term = Term.parse(module, string);

                 //term = module.setPerference(term);
                 //System.out.println(term.showStructure());

                 currentTerm = term;
                 long parseTime = new Date().getTime() - beginTime;

                 writer.write("==========================================\u005cn");
                 String modName = module.getModuleName().toString();
                 writer.write("reduce in "+modName+" : "+
                              format(term.toString(), 9+modName.length())+
                              "\u005cn");
                 writer.flush();

                 beginTime = new Date().getTime();
                 try {
                      engine = new RewriteEngine(module);
                      RewriteEngine.nontermination = false;
                      term = engine.reduce(term);
                 } catch (OutOfMemoryError error) {
                      Token xt = getToken(0);
                      writer.write("error: out of memory at line "+
                                   xt.beginLine+".\u005cn");
                      writer.flush();
                      {if (true) return;}
                 }

                 String sortName = term.getSort().getName();

                 int index = sortName.indexOf(".");
                 if (index != -1) {
                     sortName = sortName.substring(0, index);
                 }

                 writer.write("result "+sortName+": "+
                              format(term.toFullString(),
                                     9+term.getSort().getName().length())+
                              "\u005cn");

                 writer.write("rewrite time: "+
                               (new Date().getTime() - beginTime)+"ms");
                 writer.write("       parse time: "+parseTime+"ms\u005cn");

                 if (engine.nontermination) {
                     writer.write("Warning: non-termination corrected\u005cn");
                     engine.nontermination = false;
                 }

                 writer.flush();

             } catch (TermException e) {
                  token = getToken(0);
                  writer.write("==========================================\u005cn");
                  if (e.getCount() > 0) {
                      writer.write(e.getMessage()+"\u005cnat line "+token.beginLine+
                                   ".\u005cn");
                  } else {
                      writer.write(e.getMessage()+"at line "+token.beginLine+
                                   ".\u005cn");
                  }
                  writer.flush();

             }
                      break;
                    case BRED:
                      jj_consume_token(BRED);
           CaseModule cm = null;
                      if (jj_2_6(2147483647)) {
                        jj_consume_token(WITH);
                        token = jj_consume_token(IDENTIFIER);
                cm = (CaseModule)casesPool.get(token.image);
                if (cm == null) {
                    String msg = "no cases with the name "+token.image+" at "+
                                 "line "+token.beginLine+", column "+
                                 token.beginColumn;
                    {if (true) throw new ParseException(msg);}
                }

                ArrayList cmlist = new ArrayList();
                cmlist.add(cm);
                        label_8:
                        while (true) {
                          if (getToken(1).image.equals("*") &&
                                                 casesPool.get(getToken(2).image) != null) {
                            ;
                          } else {
                            break label_8;
                          }
                          jj_consume_token(STAR);
                          token = jj_consume_token(IDENTIFIER);
                   cm = (CaseModule)casesPool.get(token.image);
                   cmlist.add(cm);
                        }
               try {
                   if (cmlist.size() > 1) {
                       String name = "";
                       for (int i=0; i<cmlist.size(); i++) {
                          CaseModule c = (CaseModule)cmlist.get(i);
                          if (i == 0) {
                             name += c.name;
                          } else {
                             name += " * "+c.name;
                          }
                       }
                       ModuleName modName = new ModuleName(name);
                       cm = new CaseModule(modName, cmlist);
                   } else {
                       cm = (CaseModule)cmlist.get(0);
                   }
               } catch (CaseModuleException e) {
                   String msg =  e.getMessage()+" at line "+
                                 token.beginLine+", column "+
                                 token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               }
                        if (getToken(1).image.equals("exclude")) {
                          jj_consume_token(IDENTIFIER);
                        String sum = "exclude";
                          label_9:
                          while (true) {
                        String label = "";
                            jj_consume_token(144);
                            token = jj_consume_token(INTEGER_LITERAL);
                        label += token.image;
                            label_10:
                            while (true) {
                              jj_consume_token(145);
                              token = jj_consume_token(INTEGER_LITERAL);
                         label += ","+token.image;
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case 145:
                                ;
                                break;
                              default:
                                jj_la1[32] = jj_gen;
                                break label_10;
                              }
                            }
                            jj_consume_token(146);
                         // change case
                         try {
                              cm.remove(label);
                              sum += " ("+label+")";
                         } catch (Exception e) {
                              String msg = e.getMessage()+" at line "+
                                           token.beginLine+", column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                         }
                            if (jj_2_5(2)) {
                              ;
                            } else {
                              break label_9;
                            }
                          }
                     cm.name = new ModuleName(cm.name.toString()+" "+sum);
                        } else {
                          ;
                        }
                      } else {
                        ;
                      }
             module = (dynmaicModule != null) ?
                          dynmaicModule : currentModule;

             if (module == null) {
                 writer.write("Warning: no module input yet, "+
                              "use BOOL instead\u005cn");
                 writer.flush();
                 module = ModuleFactory.createBool();
             }

             String tmp;
                      tmp = Term(module);
                      jj_consume_token(DOT);
           // try to get multiple goals
           String target = tmp.trim();

           ArrayList goals = new ArrayList();
           int pCount = 0;   // the number of "("
           String goal = "";
           boolean valid = true;

           while (target.length() > 0) {

              if (target.startsWith("(")) {

                 if (pCount > 0) {
                   goal += target.substring(0, 1);
                 }
                 target = target.substring(1);
                 pCount++;
              } else if (target.startsWith(")")) {

                 if (pCount < 1) {
                     valid = false;
                     break;

                 } else if (pCount == 1) {

                     // find a goal
                     goals.add(goal);
                     goal = "";
                     target = target.substring(1).trim();
                     pCount = 0;

                 } else if (pCount > 1) {
                    pCount--;
                    goal += target.substring(0, 1);
                    target = target.substring(1);
                 }

              } else if (pCount > 0) {
                 goal += target.substring(0, 1);
                 target = target.substring(1);
              } else {
                 valid = false;
                 break;
              }
           }

           if (valid && goal.length() == 0 && goals.size() > 1) {

               // parse goals
               Term[] terms = new Term[goals.size()];
               Term[] cterm = new Term[goals.size()];
               Term[] lefts =  new Term[goals.size()];
               Term[] rights =  new Term[goals.size()];
               ArrayList hsorts = new ArrayList();

               long b1 = new Date().getTime();

               for (int i=0; i<terms.length; i++) {
                  tmp = (String)goals.get(i);

                  try {
                      String cond = null;
                      int index = tmp.indexOf(" if ");
                      if (index != -1) {
                          cond = tmp.substring(index+4).trim();

                          if (cond.indexOf(" then ") != -1 &&
                              cond.indexOf(" else ") != -1) {
                             cond = null;
                          } else {
                             int count = 0;
                             for (int j=0; j<cond.length(); j++) {
                                char c = cond.charAt(j);
                                if (c == '(') {
                                   count++;
                                } else if (c == ')') {
                                   count--;
                                }
                                if (count < 0) {
                                   break;
                                }
                             }

                            if (count != 0) {
                               cond = null;
                            }
                         }
                      }

                      if (cond == null) {
                         terms[i] = Term.parse(module, tmp);
                      } else {
                         terms[i] =
                            Term.parse(module, tmp.substring(0, index));
                         cterm[i] = Term.parse(module, cond);

                         if (!cterm[i].getSort().equals(BoolModule.boolSort)) {
                             {if (true) throw new TermException("expect a boolean term: "+
                                                     cond);}
                         }

                      }

                      Operation op = terms[i].getTopOperation();
                      if (op.getName().equals("_ == _") &&
                          op.getInfo().equals("system-default")) {

                          lefts[i] = terms[i].getSubterms()[0];
                          rights[i] = terms[i].getSubterms()[1];

                          Sort lsort = lefts[i].getSort();
                          if (lsort.isHidden()) {
                              HiddenSort hsort = (HiddenSort)lsort;
                              boolean found = false;
                              for (int j=0; j<hsorts.size(); j++) {
                                HiddenSort htmp = (HiddenSort)hsorts.get(j);
                                found = htmp.equals(hsort);
                                if (found) break;
                              }

                              if (!found) hsorts.add(hsort);
                          }

                      } else {
                          {if (true) throw new TermException("cred can't be used to \u005c""+
                                           ((String)goals.get(i)).trim()+"\u005c"");}
                      }

                  }  catch (TermException e) {

                      writer.write("======================"+
                                   "====================\u005cn");
                      writer.write(e.getMessage()+"\u005cn");
                      writer.write("at line "+getToken(0).beginLine+"\u005cn");
                      writer.flush();

                      {if (true) return;}
                  }

               }
               b1 = new Date().getTime() - b1;

               // display message

               String modName = module.getModuleName().toString();
               writer.write("==========================================\u005cn");
               writer.write("c-reduce in "+modName+" : \u005cn");


               for (int i=0; i<terms.length; i++) {
                  String deco = "";
                  if (cterm[i] != null) deco = " if "+cterm[i].toString();
                  writer.write("   "+format(terms[i].toString()+deco, 0)+"\u005cn");
               }

               if (cm != null) {
                   writer.write("use: "+cm.name+"\u005cn");
               }
               writer.flush();

               if (cm == null && localCase != null) {
                   cm = localCase;
               }

               if (currentCobasis != null) {

                    Vector cops = new Vector();
                    if (currentCobasis.validFor(module, cops)) {

                         Operation[] ops = new Operation[cops.size()];
                         cops.copyInto(ops);

                         if (ops != null && ops.length > 0) {

                              if (currentCobasis.getName().length() > 0) {
                                  writer.write("using cobasis "+
                                               currentCobasis.getName()+
                                               " for "+modName+"\u005cn");
                              } else {
                                  writer.write("using cobasis of "+
                                               currentCobasis.module.modName+
                                               ":\u005cn");
                                  for (int i=0; i<ops.length; i++) {
                                      writer.write("   "+
                                                   module.toString(ops[i])+
                                                   "\u005cn");
                                  }
                                  writer.write("   -------------------"+
                                               "--------------------\u005cn");
                              }

                              long b = new Date().getTime();

                              module.setWriter(writer);


                              boolean res = false;
                              try {
                                  res = module.behavioralMultipleReduce(lefts,
                                                                        rights,
                                                                        cterm,
                                                                        trace,
                                                                        cm);
                              }  catch (BReduceException e) {
                                  writer.write("timeout: BOBJ could not "+
                                               "determine the result\u005cn");
                                  writer.flush();
                              } catch (OutOfMemoryError e) {
                                  Token xt = getToken(0);
                                  writer.write("error: out of memory at line "+
                                               xt.beginLine+".\u005cn");
                                  writer.flush();
                              }

                              if (res) {
                                  writer.write("result: true\u005cn");
                              } else {
                                  writer.write("result: false\u005cn");
                              }
                              writer.write("c-rewrite time: "+
                                               (new Date().getTime() - b)+"ms");
                              writer.write("     parse time: "+b1+"ms\u005cn");
                              writer.flush();
                              {if (true) return;}
                          }
                      } else {
                          writer.write("Warning: cobasis "+
                                       currentCobasis.getName()+
                                       " couldn't be applied\u005cn");
                      }

               }

               if (cobasisUpdated) {

                  boolean init = false;
                  for (int k=0; k<hsorts.size(); k++) {
                      HiddenSort hsort = (HiddenSort)hsorts.get(k);
                      Operation[] ops = module.getCobasisFor(hsort);
                      if (ops != null && ops.length > 0) {

                          if (!init) {
                             writer.write("using cobasis for "+
                                           module.getModuleName()+":\u005cn");
                             init = true;
                          }
                          for (int i=0; i<ops.length; i++) {
                             writer.write("   "+module.toString(ops[i])+"\u005cn");
                          }
                      }

                  }

                  writer.write("   ---------------------------------------\u005cn");
                  cobasisUpdated = false;
               }

               long b = new Date().getTime();

               try {
                   module.setWriter(writer);
                   if (module.behavioralMultipleReduce(lefts, rights, cterm,
                                                   trace, cm)) {
                       writer.write("result: true\u005cn");
                   } else {
                       writer.write("result: false\u005cn");
                   }

                   writer.write("c-rewrite time: "+
                                (new Date().getTime() - b)+"ms");
                   writer.write("     parse time: "+b1+"ms\u005cn");
                   writer.flush();

                   {if (true) return;}
               } catch (BReduceException e) {
                   writer.write("timeout: BOBJ could not "+
                                "determine the result\u005cn");
                   writer.flush();
               } catch (OutOfMemoryError e) {
                  Token xt = getToken(0);
                  writer.write("error: out of memory at line "+
                               xt.beginLine+".\u005cn");
                  writer.flush();
               }

           }

           // end handling multiple goals
           try {

               String cond = null;
               int index = tmp.indexOf(" if ");
               if (index != -1) {
                  cond = tmp.substring(index+4).trim();

                  if (cond.indexOf(" then ") != -1 &&
                      cond.indexOf(" else ") != -1) {
                     cond = null;
                  } else {
                     int count = 0;
                     for (int i=0; i<cond.length(); i++) {
                        char c = cond.charAt(i);
                        if (c == '(') {
                           count++;
                        } else if (c == ')') {
                           count--;
                        }
                        if (count < 0) {
                           break;
                        }
                     }

                     if (count != 0) {
                        cond = null;
                     }
                  }
               }


               long b1 = new Date().getTime();

               Term term, cterm=null;

               if (cond == null) {
                   term = Term.parse(module, tmp);
               } else {
                   term = Term.parse(module, tmp.substring(0, index));
                   cterm = Term.parse(module, cond);
               }
               b1 = new Date().getTime() - b1;

               if (term == null) {
                   writer.write("No parse for "+tmp+"\u005cn");
                   writer.flush();
                   {if (true) return;}
               }

               Operation op = term.getTopOperation();
               if (op.getName().equals("_ == _") &&
                   op.getInfo().equals("system-default")) {

               Term left = term.getSubterms()[0];
               Term right = term.getSubterms()[1];

               String deco = "";
               if (cterm != null) deco = " if "+cterm.toString();

               String modName = module.getModuleName().toString();
               writer.write("==========================================\u005cn");
               writer.write("c-reduce in "+modName+" : "+
                            format(term.toString()+deco,
                                   15+modName.length())+"\u005cn");
               if (cm != null) {
                   writer.write("use: "+cm.name+"\u005cn");
               }
               writer.flush();

               if (cm == null && localCase != null) {
                   cm = localCase;
               }

               //if currentCobasis != null, check whether it can be applied
               //to the current module, it not,the cobasis should be recalcute

               if (currentCobasis != null) {
                    Vector cops = new Vector();
                    if (currentCobasis.validFor(module, cops)) {

                         Operation[] ops = new Operation[cops.size()];
                         cops.copyInto(ops);

                         if (ops != null && ops.length > 0) {

                              if (currentCobasis.getName().length() > 0) {
                                  writer.write("using cobasis "+
                                               currentCobasis.getName()+
                                               " for "+modName+"\u005cn");
                              } else {
                                  writer.write("using cobasis of "+
                                               currentCobasis.module.modName+
                                               ":\u005cn");
                                  for (int i=0; i<ops.length; i++) {
                                      writer.write("   "+
                                                   module.toString(ops[i])+
                                                   "\u005cn");
                                  }
                                  writer.write("   -------------------"+
                                               "--------------------\u005cn");
                              }

                              long b = new Date().getTime();
                              module.setWriter(writer);

                              if (module.behavioralReduce(left,
                                                          right,
                                                          cterm,
                                                          ops,
                                                          trace,
                                                          cm)) {
                                  writer.write("result: true\u005cn");
                              } else {
                                  writer.write("result: false\u005cn");
                              }
                              writer.write("c-rewrite time: "+
                                           (new Date().getTime() - b)+"ms");
                              writer.write("     parse time: "+b1+"ms\u005cn");
                              writer.flush();
                              {if (true) return;}
                          }
                      } else {
                          writer.write("Warning: cobasis "+
                                       currentCobasis.getName()+
                                       " couldn't be applied\u005cn");
                      }
                  }


                  if (cobasisUpdated &&
                      left.getSort().isHidden()){

                       Operation[] ops = module.getCobasisFor(left.getSort());

                       if (ops != null && ops.length > 0) {

                            writer.write("using cobasis for "+
                                          module.getModuleName()+":\u005cn");
                            for (int i=0; i<ops.length; i++) {
                                 writer.write("   "+module.toString(ops[i])+
                                              "\u005cn");
                            }
                            writer.write("   -------------------"+
                                         "--------------------\u005cn");
                       }
                       cobasisUpdated = false;

                  }

                  long b = new Date().getTime();
                  module.setWriter(writer);
                  if (module.behavioralReduce(left, right, cterm, trace, cm)) {
                       writer.write("result: true\u005cn");
                  } else {
                       writer.write("result: false\u005cn");
                  }
                  writer.write("c-rewrite time: "+
                               (new Date().getTime() - b)+"ms");
                  writer.write("     parse time: "+b1+"ms\u005cn");
                  writer.flush();
             } else {
                  {if (true) throw new ParseException("no behavioral rewrite "+
                                           "can be done");}
             }

         } catch (TermException e) {

             writer.write("==========================================\u005cn");
             writer.write(e.getMessage()+"\u005cn");
             writer.write("at line "+getToken(0).beginLine+"\u005cn");
             writer.flush();

         } catch (BReduceException e) {
             writer.write("timeout: BOBJ could not determine the result\u005cn");
             writer.flush();
         } catch (OutOfMemoryError e) {
             Token xt = getToken(0);
             writer.write("error: out of memory at line "+
                          xt.beginLine+".\u005cn");
             writer.flush();
         }
                      break;
                    case PR:
                    case PROTECTING:
                    case EX:
                    case EXTENDING:
                    case US:
                    case USING:
                    case INC:
                    case INCLUDING:
                    case SORT:
                    case SORTS:
                    case BSORT:
                    case BSORTS:
                    case SUBSORT:
                    case SUBSORTS:
                    case VAR:
                    case VARS:
                    case OP:
                    case OPS:
                    case OPAS:
                    case EQ:
                    case CQ:
                    case CEQ:
                    case VARSOF:
                    case LB:
                    case DFN:
                    case LET:
                    case DEFINE:
                    case MB:
         if (dynmaicModule == null)

             if (currentModule != null) {
                 if (mode == FILE_INPUT) {
                      writer.write("======================="+
                                   "===================\u005cn");
                 }
                 Token xt = getToken(0);
                 writer.write("opening module "+
                              currentModule.getModuleName()+".\u005cn");
                 writer.flush();
                 dynmaicModule = (Module)currentModule.clone();

             } else {
                 {if (true) throw new ParseException("No module is open ");}
             }
                      DynamicDecl(dynmaicModule);
                 cobasisUpdated = true;
                      break;
                    default:
                      jj_la1[61] = jj_gen;
                      if (jj_2_20(10)) {
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case SHOW:
                          jj_consume_token(SHOW);
                          break;
                        case SH:
                          jj_consume_token(SH);
                          break;
                        default:
                          jj_la1[33] = jj_gen;
                          jj_consume_token(-1);
                          throw new ParseException();
                        }
                        jj_consume_token(CASE);
                        token = jj_consume_token(IDENTIFIER);
                        jj_consume_token(DOT);
                cm = (CaseModule)casesPool.get(token.image);

                if (mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.flush();
                }

                if (cm == null) {
                    String msg = "no cases with the name "+token.image+" at "+
                                 "line "+token.beginLine+", column "+
                                 token.beginColumn;
                    {if (true) throw new ParseException(msg);}
                }

                writer.write("\u005cn"+cm+"\u005cn");
                writer.flush();
                      } else if (jj_2_21(10)) {
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case SHOW:
                          jj_consume_token(SHOW);
                          break;
                        case SH:
                          jj_consume_token(SH);
                          break;
                        default:
                          jj_la1[34] = jj_gen;
                          jj_consume_token(-1);
                          throw new ParseException();
                        }
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case COB:
                          jj_consume_token(COB);
                          break;
                        case COBASIS:
                          jj_consume_token(COBASIS);
                          break;
                        default:
                          jj_la1[35] = jj_gen;
                          jj_consume_token(-1);
                          throw new ParseException();
                        }
                 token = null;
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case IDENTIFIER:
                          token = jj_consume_token(IDENTIFIER);
                          break;
                        default:
                          jj_la1[36] = jj_gen;
                          ;
                        }
                        jj_consume_token(DOT);
                 module = (dynmaicModule != null) ?
                              dynmaicModule : currentModule;

                 if (module == null) {
                     if (mode == FILE_INPUT)
                         writer.write("====================="+
                                      "=====================\u005cn");
                     writer.write("no input module");
                     writer.flush();
                     {if (true) return;}
                 }

                 Operation[] cobasis = null;
                 Sort sort = null;

                 if (token != null) {
                     Sort[] sorts = module.getHiddenSortsByName(token.image);
                     if (sorts.length == 1) {

                         sort = sorts[0];
                         cobasis = module.getCobasisFor(sort);

                     } else if (sorts.length == 0) {

                         String msg= "No hidden sort "+token.image+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         {if (true) throw new ParseException(msg);}

                     } else {

                         token = getToken(0);
                         String msg= "Multiple hidden "+sort+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         {if (true) throw new ParseException(msg);}

                     }

                 } else {

                     sort = module.getPrincipalSort();
                     if (sort.isHidden()) {

                         cobasis = module.getCobasisFor(sort);

                     } else {
                         token = getToken(0);
                         String msg= "No hidden "+sort+" "+
                                     "in the current module, at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                     }
                 }

                 if (mode == FILE_INPUT) {
                     writer.write("======================"+
                                  "====================\u005cn");
                 }
                 writer.write("The cobasis for "+module.toString(sort)+
                              " is: \u005cn");
                 String msg = "";

                 for (int i=0; i<cobasis.length; i++) {
                     msg += "   "+module.toString(cobasis[i])+"\u005cn";
                 }
                 writer.write(msg);
                 writer.flush();
                      } else {
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case SET:
                          jj_consume_token(SET);
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case TRACE:
                            jj_consume_token(TRACE);
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case ON:
                              jj_consume_token(ON);
                     RewriteEngine.setTrace(true);
                     trace = true;
                              break;
                            case OFF:
                              jj_consume_token(OFF);
                     if (engine != null) {
                         engine.setTrace(false);
                     }
                              break;
                            default:
                              jj_la1[37] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            break;
                          case BRED:
                            jj_consume_token(BRED);
                            jj_consume_token(TRACE);
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case ON:
                              jj_consume_token(ON);
                     trace = true;
                              break;
                            case OFF:
                              jj_consume_token(OFF);
                     trace = false;
                              break;
                            default:
                              jj_la1[38] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            break;
                          case COBASIS:
                          case COB:
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case COBASIS:
                              jj_consume_token(COBASIS);
                              break;
                            case COB:
                              jj_consume_token(COB);
                              break;
                            default:
                              jj_la1[39] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            if (jj_2_7(30)) {
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case IDENTIFIER:
                                token = jj_consume_token(IDENTIFIER);
                      cobasisUpdated = true;
                      currentCobasis = (Cobasis)cobasisPool.get(token.image);
                      if (currentCobasis == null) {
                           if (mode == FILE_INPUT) {
                               writer.write("====================="+
                                            "=====================\u005cn");
                           }
                           writer.write("Warning: cobasis "+
                                        token.image+" not found\u005cn");
                           writer.flush();

                      } else {
                           if (mode == FILE_INPUT) {
                               writer.write("====================="+
                                            "=====================\u005cn");
                               writer.write("set cobasis "+token.image+"\u005cn");
                               writer.flush();
                           }
                      }
                                break;
                              case OF:
                                jj_consume_token(OF);
                     Module md;
                                md = ModExpr(null);
                      cobasisUpdated = true;
                      Operation[] ops  = md.getCobasis();

                      cob = new Cobasis("");
                      cob.setModule(currentModule);

                      try {
                          cob.add(currentModule.getPrincipalSort());
                          for (int i=0; i<ops.length; i++) {
                             cob.add(ops[i]);
                          }
                      } catch (Exception e) {
                         token = getToken(0);
                         String msg= e.getMessage()+" at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      currentCobasis = cob;

                      if (currentCobasis == null) {
                           if (mode == FILE_INPUT) {
                               writer.write("====================="+
                                            "=====================\u005cn");
                           }
                           writer.write("Warning: cobasis of "+
                                        md.modName+" not found\u005cn");
                           writer.flush();

                      } else {
                           if (mode == FILE_INPUT) {
                               writer.write("====================="+
                                            "=====================\u005cn");
                               writer.write("set cobasis of "+md.modName+"\u005cn");
                               writer.flush();
                           }
                      }
                                break;
                              default:
                                jj_la1[40] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                              }
                            } else {
                              ;
                            }
                            break;
                          case PRINT:
                            jj_consume_token(PRINT);
                            jj_consume_token(WITH);
                            jj_consume_token(PARENS);
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case ON:
                              jj_consume_token(ON);
                     if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                     }
                     writer.write("ignore: set print with parens on\u005cn");
                     writer.flush();
                              break;
                            case OFF:
                              jj_consume_token(OFF);
                     if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                     }
                     writer.write("ignore: set print with parens off\u005cn");
                     writer.flush();
                              break;
                            default:
                              jj_la1[41] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            break;
                          case INCLUDE:
                            jj_consume_token(INCLUDE);
                            token = jj_consume_token(IDENTIFIER);
                 if (!token.image.equals("BOOL")) {
                     String msg= "expect BOOL, at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                     {if (true) throw new ParseException(msg);}
                 }
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case ON:
                              jj_consume_token(ON);
                      boolInclude = true;
                      if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                      }
                      writer.write("set include BOOL on\u005cn");
                      writer.flush();
                              break;
                            case OFF:
                              jj_consume_token(OFF);
                      boolInclude = false;
                      if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                      }
                      writer.write("set include BOOL off\u005cn");
                      writer.flush();
                              break;
                            default:
                              jj_la1[42] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            break;
                          case SHOW:
                            jj_consume_token(SHOW);
                            token = jj_consume_token(IDENTIFIER);
                 if (!token.image.equals("details") &&
                     !token.image.equals("detail") &&
                     !token.image.equals("retracts") &&
                     !token.image.equals("retract")) {
                     String msg= "expect detail or retracts, at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                     {if (true) throw new ParseException(msg);}
                 }
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case ON:
                              jj_consume_token(ON);
                      if (token.image.startsWith("detail")) {
                          detail = true;
                      } else {
                          Term.showRetract = true;
                      }

                      if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                          writer.write("set show "+token.image+" on\u005cn");
                          writer.flush();
                      }
                              break;
                            case OFF:
                              jj_consume_token(OFF);
                      if (token.image.startsWith("detail")) {
                          detail = false;
                      } else {
                          Term.showRetract = false;
                      }

                      if (mode == FILE_INPUT) {
                          writer.write("====================="+
                                       "=====================\u005cn");
                        writer.write("set show "+token.image+" off\u005cn");
                        writer.flush();
                      }
                              break;
                            default:
                              jj_la1[43] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            break;
                          default:
                            jj_la1[44] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case DOT:
                            jj_consume_token(DOT);
                            break;
                          default:
                            jj_la1[45] = jj_gen;
                            ;
                          }
                          break;
                        case COMMENT:
                          jj_consume_token(COMMENT);
               boolean found = false;
               String msg = "";
               while (!found) {
                 try {
                    char more = jj_input_stream.readChar();
                    found = more == '\u005cn';
                    msg += more;
                 } catch (IOException e) {
                    found = true;
                    msg += "\u005cn";
                 }
               }
               if (mode == FILE_INPUT)
                  writer.write("====================="+
                               "=====================\u005cn");
               writer.write("***> "+msg);
               writer.flush();
                          break;
                        case APPLY:
                String cmd = null;
                Token nameToken = null;
                TermSelection select;
                Hashtable map = new Hashtable();
                String varname = null;
                Term term = null;
                boolean at = true;
                Map v2t = new HashMap();
                          jj_consume_token(APPLY);
                  cmd = "apply";
                  token = getToken(0);

                  if (currentTerm == null) {
                       msg= "no term is defined by \u005c"start\u005c" command, "+
                            " at line "+token.beginLine+
                            ", column "+token.endColumn+".";
                       {if (true) throw new ParseException(msg);}
                  }

                  if (dynmaicModule != null) {
                      module = dynmaicModule;
                  } else {
                      module = currentModule;
                  }

                  if (module == null) {
                      writer.write("Warning: no module input yet,"+
                                   " use BOOL instead\u005cn");
                      writer.flush();
                      module = ModuleFactory.createBool();
                  }
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case FLOATING_POINT_LITERAL:
                          case IDENTIFIER:
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case IDENTIFIER:
                              nameToken = jj_consume_token(IDENTIFIER);
                              break;
                            case FLOATING_POINT_LITERAL:
                              nameToken = jj_consume_token(FLOATING_POINT_LITERAL);
                              break;
                            default:
                              jj_la1[46] = jj_gen;
                              jj_consume_token(-1);
                              throw new ParseException();
                            }
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case WITH:
                              jj_consume_token(WITH);
                         string = "";
                              token = jj_consume_token(IDENTIFIER);
                         varname = token.image;
                              token = jj_consume_token(IDENTIFIER);
                         if (!token.image.equals("=")) {
                             msg= "expect '=', at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                             {if (true) throw new ParseException(msg);}
                         }
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case 144:
                                jj_consume_token(144);
                                label_11:
                                while (true) {
                                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                  case IDENTIFIER:
                                    token = jj_consume_token(IDENTIFIER);
                                   string += token.image+" ";
                                    break;
                                  case INTEGER_LITERAL:
                                    token = jj_consume_token(INTEGER_LITERAL);
                                   string += token.image+" ";
                                    break;
                                  case STAR:
                                    token = jj_consume_token(STAR);
                                   string += token.image+" ";
                                    break;
                                  default:
                                    jj_la1[47] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                                  }
                                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                  case STAR:
                                  case INTEGER_LITERAL:
                                  case IDENTIFIER:
                                    ;
                                    break;
                                  default:
                                    jj_la1[48] = jj_gen;
                                    break label_11;
                                  }
                                }
                                jj_consume_token(146);
                                break;
                              case IDENTIFIER:
                                token = jj_consume_token(IDENTIFIER);
                             string = token.image;
                                break;
                              case INTEGER_LITERAL:
                                token = jj_consume_token(INTEGER_LITERAL);
                             string = token.image;
                                break;
                              default:
                                jj_la1[49] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                              }
                         try {
                             term = Term.parse(module, string);
                             v2t.put(varname, term);
                         } catch (TermException e) {
                             msg= e.getMessage()+" at line "+
                                  token.beginLine+".\u005cn";
                             {if (true) throw new ParseException(msg);}
                         }
                              label_12:
                              while (true) {
                                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                case 145:
                                  ;
                                  break;
                                default:
                                  jj_la1[50] = jj_gen;
                                  break label_12;
                                }
                                jj_consume_token(145);
                           string = "";
                                token = jj_consume_token(IDENTIFIER);
                             varname = token.image;
                                token = jj_consume_token(IDENTIFIER);
                            if (!token.image.equals("=")) {
                                msg= "expect '=', at line "+
                                     token.beginLine+", column "+
                                     token.endColumn+".";
                                {if (true) throw new ParseException(msg);}
                            }
                                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                case IDENTIFIER:
                                  token = jj_consume_token(IDENTIFIER);
                                string += token.image;
                                  break;
                                case INTEGER_LITERAL:
                                  token = jj_consume_token(INTEGER_LITERAL);
                                string += token.image;
                                  break;
                                case 144:
                                  jj_consume_token(144);
                                  label_13:
                                  while (true) {
                                    token = jj_consume_token(IDENTIFIER);
                                             string += token.image;
                                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                    case IDENTIFIER:
                                      ;
                                      break;
                                    default:
                                      jj_la1[51] = jj_gen;
                                      break label_13;
                                    }
                                  }
                                  jj_consume_token(146);
                                  break;
                                default:
                                  jj_la1[52] = jj_gen;
                                  jj_consume_token(-1);
                                  throw new ParseException();
                                }
                             try {
                                 term = Term.parse(module, string);
                                 v2t.put(varname, term);
                             } catch (TermException e) {
                                 msg= e.getMessage()+" at line "+
                                      token.beginLine+".\u005cn";
                                 {if (true) throw new ParseException(msg);}
                             }
                              }
                              break;
                            default:
                              jj_la1[53] = jj_gen;
                              ;
                            }
                            break;
                          case PRINT:
                            jj_consume_token(PRINT);
                            break;
                          case RED:
                            jj_consume_token(RED);
                   cmd = "red";
                            break;
                          case REDUCTION:
                            jj_consume_token(REDUCTION);
                   cmd = "red";
                            break;
                          case REDUCE:
                            jj_consume_token(REDUCE);
                   cmd = "red";
                            break;
                          default:
                            jj_la1[54] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case AT:
                            jj_consume_token(AT);
                            break;
                          case WITHIN:
                            jj_consume_token(WITHIN);
                 at = false;
                            break;
                          default:
                            jj_la1[55] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                          select = Selection(at);
                          label_14:
                          while (true) {
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case OF:
                              ;
                              break;
                            default:
                              jj_la1[56] = jj_gen;
                              break label_14;
                            }
                            jj_consume_token(OF);
                 TermSelection ts;
                            ts = Selection(at);
                 ts.append(select);
                 select = ts;
                          }
                if (cmd.equals("apply")) {

                   if (nameToken != null) {

                       String name = nameToken.image;
                       String modName = null;

                       boolean reverse = false;
                       if (name.startsWith("-")) {
                          reverse = true;
                          name = name.substring(1);
                       }

                       int index = name.indexOf(".");
                       if (index == 0) {
                            name = name.substring(1);
                       } else {
                            name = name.substring(index+1);
                            modName = name.substring(0, index);
                       }

                       Equation eq = module.getEquation(name);

                       if (eq == null) {

                           eq = module.getGeneralEquation(name);
                           if (eq == null) {

                              try {
                                 int pos = Integer.parseInt(name);
                                 //eq = (Equation)module.equations.get(pos-1);
                                 eq = module.getRule(pos);
                              } catch (Exception e){}

                              if (eq == null) {
                                  msg= "no equation with name "+name+
                                       " at line "+nameToken.beginLine+
                                       ", column "+nameToken.endColumn+".";
                                  {if (true) throw new ParseException(msg);}
                              }
                           }
                       }

                       // create map
                       Iterator itor = v2t.keySet().iterator();
                       string = "";
                       while (itor.hasNext()) {
                           varname = (String)itor.next();
                           term = (Term)v2t.get(varname);

                           if (string.length() == 0) {
                               string += varname+" = "+term;
                           } else {
                               string += ", "+varname+" = "+term;
                           }

                           Variable var;
                           if (reverse) {
                               var = eq.left.getVariableWithName(varname);
                           } else {
                               var = eq.right.getVariableWithName(varname);
                           }

                           if (var == null && eq.condition != null) {
                               var = eq.condition.getVariableWithName(varname);
                           }

                           if (var == null) {
                              msg= "no variable with name "+varname+
                                   " at line "+token.beginLine+
                                   ", column "+token.endColumn+".";
                              {if (true) throw new ParseException(msg);}
                           }

                           map.put(var, term);

                       }


                       writer.write("====================="+
                                "=====================\u005cn");
                       if (reverse) {
                            writer.write("reverse apply: "+
                                         format(eq.toString(), 15)+"\u005cn");
                       } else {
                            writer.write("apply: "+
                                         format(eq.toString(), 15)+"\u005cn");
                       }

                       writer.write("term: "+
                                    format(currentTerm.toString(), 6)+
                                    "\u005cn");

                       if (at) {
                            writer.write("at: "+select+"\u005cn");
                       } else {
                            writer.write("within term\u005cn");
                       }

                       if (string.length() > 0) {
                           writer.write("with: "+string+"\u005cn");
                       }
                       writer.flush();

                       try {

                           engine = new RewriteEngine(module);
                           currentTerm = engine.apply(currentTerm,
                                                      eq,
                                                      reverse,
                                                      select,
                                                      map);

                           Term shift =(Term)currentTerm.getPropertyBy("cond");
                           if (shift != null) {

                               currentTerm.removePropertyBy("cond");
                               termStack.push(currentTerm);
                               currentTerm = shift;

                               writer.write("shifting focus to condition\u005cn");
                               writer.write("condition: "+shift+"\u005cn");
                               writer.flush();

                           } else if (termStack.isEmpty()) {

                               writer.write("result: "+
                                            format(currentTerm.toString(),
                                                   8)+
                                            "\u005cn");
                               writer.flush();

                           } else {
                               if (currentTerm.operation != null &&
                                   currentTerm.operation.equals(
                                                BoolModule.trueOp)){

                                  writer.write("result: true\u005cn");
                                  writer.write("condition is satisfied,"+
                                               " applying rule\u005cn");
                                  writer.write("shifting focus back"+
                                               " to previous context\u005cn");

                                  currentTerm = (Term)termStack.pop();
                                  writer.write("term: "+
                                                format(currentTerm.toString(),
                                                       6)+
                                                "\u005cn");
                                  writer.flush();
                               } else {
                                  writer.write("result: "+
                                               format(currentTerm.toString(),
                                                     8)+
                                               "\u005cn");
                                  writer.flush();
                               }
                           }

                       } catch (Exception e) {
                           token = getToken(0);
                           msg= e.getMessage()+
                                " at line "+token.beginLine+".\u005cn";
                           {if (true) throw new ParseException(msg);}
                       }

                  } else {
                       writer.write("====================="+
                                "=====================\u005cn");
                       writer.write("apply print at "+select+"\u005cn");

                       if (select != null) {
                           engine = new RewriteEngine(module);
                           try {
                               writer.write("result: "+format(
                                   engine.select(currentTerm,
                                                 select).selected.toString(),
                                   8)+
                                            "\u005cn");
                           } catch (Exception e) {
                           }
                       } else {
                           writer.write("result: "+currentTerm+"\u005cn");
                       }
                       writer.flush();
                  }

              } else if (cmd.equals("red")) {

                   writer.write("====================="+
                                "=====================\u005cn");
                   writer.write("apply red at "+select+"\u005cn");
                   writer.flush();

                   try {
                       engine = new RewriteEngine(module);
                       currentTerm = engine.applyReductionAt(currentTerm,
                                                             select);

                       if (termStack.isEmpty()) {
                           writer.write("result: "+currentTerm+"\u005cn");
                           writer.flush();
                       } else {

                           if (currentTerm.operation != null &&
                               currentTerm.operation.equals(
                                              BoolModule.trueOp)){

                                  writer.write("result: true\u005cn");
                                  writer.write("condition is satisfied,"+
                                               " applying rule\u005cn");
                                  writer.write("shifting focus back"+
                                               " to previous context\u005cn");

                                  currentTerm = (Term)termStack.pop();
                                  writer.write("term: "+currentTerm+"\u005cn");
                                  writer.flush();
                           } else {
                                  writer.write("result: "+currentTerm+"\u005cn");
                                  writer.flush();
                           }

                       }

                   } catch (Exception e) {
                       msg= e.getMessage()+
                            " at line "+token.beginLine+".\u005cn";
                       {if (true) throw new ParseException(msg);}
                  }
              }
                          jj_consume_token(DOT);
                          break;
                        case START:
                          jj_consume_token(START);
                if (dynmaicModule != null) {
                     module = dynmaicModule;
                } else {
                     module = currentModule;
                }

                if (module == null) {
                    writer.write("Warning: no module input yet,"+
                                 " use BOOL instead\u005cn");
                    writer.flush();
                    module = ModuleFactory.createBool();
                }
                          string = Term(module);
                 try {

                     long beginTime = new Date().getTime();
                     currentTerm = Term.parse(module, string);
                     long parseTime = new Date().getTime() - beginTime;

                     writer.write("===================="+
                                  "======================\u005cn");
                     writer.write("start: "+
                                  format(currentTerm.toString(), 13)+
                                  "\u005cn");
                     writer.write("parse time: "+parseTime+"ms\u005cn");
                     writer.flush();

                     termStack = new Stack();

                 } catch (TermException e) {

                     writer.write(e.getMessage()+"\u005cn");
                     writer.flush();
                 }
                          jj_consume_token(DOT);
                          break;
                        default:
                          jj_la1[62] = jj_gen;
                          jj_consume_token(-1);
                          throw new ParseException();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  final public TermSelection Selection(boolean at) throws ParseException {
   TermSelection select;
   String msg = "";
   Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LB:
      jj_consume_token(LB);
                  Token token1, token2, token3;
                  int begin=-1, end=-1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        token1 = jj_consume_token(INTEGER_LITERAL);
                              token3 = token1;
                              begin = Integer.parseInt(token1.image);
                              end = begin;

                              if (begin < 0){
                                  msg= "wrong occurance "+" at line "+
                                        token1.beginLine+", column "+
                                        token1.endColumn+".";
                                  {if (true) throw new ParseException(msg);}
                              }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token2 = jj_consume_token(IDENTIFIER);
                               if (!token2.image.equals("..")) {
                                  msg= "expect .. "+" at line "+
                                           token2.beginLine+", column "+
                                           token2.endColumn+".";
                                  {if (true) throw new ParseException(msg);}
                               }
          token3 = jj_consume_token(INTEGER_LITERAL);
                               end = Integer.parseInt(token3.image);
                               if (end < begin){
                                    msg= "wrong occurance "+" at line "+
                                         token3.beginLine+", column "+
                                         token3.endColumn+".";
                                         {if (true) throw new ParseException(msg);}
                                    }
          break;
        default:
          jj_la1[63] = jj_gen;
          ;
        }
                          select = new TermSelection(begin, end);
        break;
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
                        String string = token.image;
                        int index = token.image.indexOf("..");
                        if (index != -1) {

                            String b = token.image.substring(0, index);
                            String a = token.image.substring(index+2);

                            begin = Integer.parseInt(b);
                            end = Integer.parseInt(a);

                            if (begin < 0 || end < begin) {
                                  msg= "wrong subsequence"+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                                  {if (true) throw new ParseException(msg);}
                            }

                            select = new TermSelection(begin, end);
                        } else {
                            msg= "wrong subsequence "+" at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                            {if (true) throw new ParseException(msg);}
                        }
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RB);
      break;
    case 144:
      jj_consume_token(144);
                   List list = new ArrayList();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
          ;
          break;
        default:
          jj_la1[65] = jj_gen;
          break label_15;
        }
        token = jj_consume_token(INTEGER_LITERAL);
                           list.add(token);
      }
                          int[] seq = new int[list.size()];
                          for (int i=0; i<seq.length; i++) {
                              token = (Token)list.get(i);
                              int position = Integer.parseInt(token.image);
                              if (position < 0){
                                  msg= "wrong occurance "+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                                  {if (true) throw new ParseException(msg);}
                              }
                              seq[i] = position;
                           }

                            select = new TermSelection(seq);
      jj_consume_token(146);
      break;
    default:
      jj_la1[67] = jj_gen;
      if (getToken(1).image.startsWith("{") &&
                             getToken(1).image.length() > 1    &&
                             !getToken(1).image.endsWith("}")) {
                 ArrayList slist = new ArrayList();
        token = jj_consume_token(IDENTIFIER);
                  String string = token.image;
                  if (string.startsWith("{")) {
                      string = string.substring(1);

                      int pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      slist.add(new Integer(pos-1));
                  }
        label_16:
        while (true) {
          if (jj_2_22(10)) {
            ;
          } else {
            break label_16;
          }
          jj_consume_token(145);
          token = jj_consume_token(INTEGER_LITERAL);
                      string = token.image;
                      int pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      slist.add(new Integer(pos-1));
        }
        jj_consume_token(145);
        token = jj_consume_token(IDENTIFIER);
                  string = token.image;
                  if (string.endsWith("}")) {
                      string = string.substring(0, string.length()-1);
                      int pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      slist.add(new Integer(pos-1));

                  }

                  select = new TermSelection(slist);
      } else if (getToken(1).image.equals("{")) {
                   ArrayList slist = new ArrayList();
        jj_consume_token(IDENTIFIER);
        token = jj_consume_token(INTEGER_LITERAL);
                      String string = token.image;
                      int pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      slist.add(new Integer(pos-1));
        label_17:
        while (true) {
          if (jj_2_23(2147483647)) {
            ;
          } else {
            break label_17;
          }
          jj_consume_token(145);
          token = jj_consume_token(INTEGER_LITERAL);
                      string = token.image;
                      pos = Integer.parseInt(string);
                      if (pos <= 0) {
                         msg= "wrong selection at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }

                      slist.add(new Integer(pos-1));
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
                      if (!token.image.equals("}")) {
                         msg= "expect '}' at line "+
                              token.beginLine+", column "+
                              token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                      }
          break;
        case 145:
          jj_consume_token(145);
          token = jj_consume_token(IDENTIFIER);
                     string = token.image;
                     if (string.endsWith("}")) {
                          string = string.substring(0, string.length()-1);
                          pos = Integer.parseInt(string);
                          if (pos <= 0) {
                             msg= "wrong selection at line "+
                                  token.beginLine+", column "+
                                  token.endColumn+".";
                             {if (true) throw new ParseException(msg);}
                          }
                          slist.add(new Integer(pos-1));
                      }
          break;
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                    select = new TermSelection(slist);
      } else if (getToken(1).image.startsWith("{")   &&
                            getToken(1).image.endsWith("}")) {
        token = jj_consume_token(IDENTIFIER);
                 String string = token.image;
                 string = string.substring(1);
                 string = string.substring(0, string.length()-1);

                 try {
                     ArrayList slist = new ArrayList();
                     int pos = Integer.parseInt(string);

                     if (pos <= 0) {
                        msg= "expect a natural number at line "+
                             token.beginLine+", column "+
                             token.endColumn+".";
                        {if (true) throw new ParseException(msg);}
                     }

                     slist.add(new Integer(pos-1));
                     select = new TermSelection(slist);
                 } catch (Exception e) {
                     msg= "expect an integer at line "+
                          token.beginLine+", column "+
                          token.endColumn+".";
                     {if (true) throw new ParseException(msg);}
                 }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
                    if (!token.image.equals("term") &&
                        !token.image.equals("top")) {

                        msg= "expect 'term' or 'top'"+
                             " or a selection  at line "+
                             token.beginLine+", column "+
                             token.endColumn+".";
                        {if (true) throw new ParseException(msg);}

                    } else {
                        select = new TermSelection(at);
                    }
          break;
        default:
          jj_la1[68] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
                {if (true) return select;}
    throw new Error("Missing return statement in function");
  }

  final public void BatchCommand() throws ParseException, IOException {
    label_18:
    while (true) {
      if (jj_2_24(1)) {
        Command();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STOP:
          jj_consume_token(STOP);
          {if (true) return;}
          break;
        default:
          jj_la1[69] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      if (jj_2_25(1)) {
        ;
      } else {
        break label_18;
      }
    }
          Token token = getToken(1);
          String string = token.image.trim();
          if (!string.equals("")) {
              String msg= "Unknown token "+string+
                          " at line "+token.beginLine+
                          ", column "+token.endColumn+".";
              {if (true) throw new ParseException(msg);}
          }
  }

  final public void DynamicDecl(Module module) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PR:
    case PROTECTING:
      ProtectedImport(module);
      break;
    case EX:
    case EXTENDING:
      ExtendedImport(module);
      break;
    case US:
    case USING:
    case INC:
    case INCLUDING:
      UsedImport(module);
      break;
    case SORT:
    case SORTS:
    case BSORT:
    case BSORTS:
      SortsDecl(module);
      break;
    case SUBSORT:
    case SUBSORTS:
      SubsortDecl(module);
      break;
    case VAR:
    case VARS:
      VarDecl(module);
      break;
    case VARSOF:
      VarImport(module);
      break;
    case OP:
    case OPS:
    case OPAS:
      OperationDecl(module);
      break;
    case EQ:
    case CQ:
    case CEQ:
    case LB:
          RewriteEngine.cleanCache();
      EquationDecl(module);
      break;
    case DFN:
    case DEFINE:
      DefDecl(module);
      break;
    case LET:
      LetDecl(module);
      break;
    case MB:
      MembershipDecl(module);
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Module[] Start() throws ParseException {
    Module module;
    Vector vec = new Vector();
    View view;
    Token token;
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case OBJECT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
          jj_consume_token(OBJ);
          break;
        case OBJECT:
          jj_consume_token(OBJECT);
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               paraPool = new Hashtable();
        module = Module(Module.INITIAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENDO:
          jj_consume_token(ENDO);
          break;
        case END:
          jj_consume_token(END);
          break;
        case JBO:
          jj_consume_token(JBO);
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                //modPool.put(module.getModuleName(), module);
                saveModule(module);
                vec.addElement(module);
                paraPool = new Hashtable();
        break;
      case DTH:
        jj_consume_token(DTH);
               paraPool = new Hashtable();
        module = Module(Module.INITIAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENDD:
          jj_consume_token(ENDD);
          break;
        case END:
          jj_consume_token(END);
          break;
        default:
          jj_la1[73] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               //modPool.put(module.getModuleName(), module);
               saveModule(module);
               vec.addElement(module);
               paraPool = new Hashtable();
        break;
      case TH:
      case THEORY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TH:
          jj_consume_token(TH);
          break;
        case THEORY:
          jj_consume_token(THEORY);
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               paraPool = new Hashtable();
        module = Module(Module.LOOSE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENDTH:
          jj_consume_token(ENDTH);
          break;
        case END:
          jj_consume_token(END);
          break;
        case HT:
          jj_consume_token(HT);
          break;
        default:
          jj_la1[75] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               //modPool.put(module.getModuleName(), module);
               saveModule(module);
               vec.addElement(module);
               paraPool = new Hashtable();
        break;
      case BTH:
        jj_consume_token(BTH);
               paraPool = new Hashtable();
        module = Module(Module.BEHAVORIAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENDB:
          jj_consume_token(ENDB);
          break;
        case END:
          jj_consume_token(END);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               //modPool.put(module.getModuleName(), module);
               saveModule(module);
               vec.addElement(module);
               paraPool = new Hashtable();
        break;
      case VIEW:
        jj_consume_token(VIEW);
               paraPool = new Hashtable();
        view = ViewDecl();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENDV:
          jj_consume_token(ENDV);
          break;
        case END:
          jj_consume_token(END);
          break;
        default:
          jj_la1[77] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               viewPool.put(view.getName(), view);
               paraPool = new Hashtable();
        break;
      case MORPH:
        jj_consume_token(MORPH);
               paraPool = new Hashtable();
        view = MorphismDecl();
        jj_consume_token(END);
               viewPool.put(view.getName(), view);
               paraPool = new Hashtable();
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case VIEW:
      case THEORY:
      case OBJECT:
      case MORPH:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_19;
      }
    }
           Module[] result = new Module[vec.size()];
           vec.copyInto(result);

           token = getToken(1);
           String string = token.image.trim();
           if (!token.equals("")) {
               String msg="Unknown token "+string+
                          " at line "+token.beginLine+
                          ", column "+token.endColumn+".";
               {if (true) throw new ParseException(msg);}
           }

           {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Module Module(int type) throws ParseException {
  Module module;
    module = Interface(type);
    jj_consume_token(IS);
    label_20:
    while (true) {
      ModElt(module);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case OP:
      case OPS:
      case OPAS:
      case EQ:
      case CQ:
      case CEQ:
      case VARSOF:
      case LB:
      case DFN:
      case LET:
      case COMMENT:
      case DEFINE:
      case MB:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_20;
      }
    }
         {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public Module Interface(int type) throws ParseException {
    String name;
    Module module = null;
    name = ModId();
          try {

             ModuleName modName = new ModuleName(name);
             module = new Module(type, modName);
             if (boolInclude) {
                 module.importModule(ModuleFactory.createBool());
             }
          } catch (SignatureException e) {}

          ArrayList list = new ArrayList();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LB:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_21;
      }
      jj_consume_token(LB);
      ParametersDeclaration(module);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 145:
          ;
          break;
        default:
          jj_la1[82] = jj_gen;
          break label_22;
        }
        jj_consume_token(145);
        ParametersDeclaration(module);
      }
      jj_consume_token(RB);
             list.add(new Integer(module.paraNames.size()));
    }
         if (list.size() > 0) {
             int[] levels = new int[list.size()];
             for (int i=0; i<list.size(); i++) {
                Integer aInt = (Integer)list.get(i);
                levels[i] = aInt.intValue();
             }
             module.setParametersLevel(levels);
         }

         if (module.isSecondOrder()) {
             module.bindings = (Hashtable)modPool.clone();
         }

         {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public void ParametersDeclaration(Module module) throws ParseException {
    List parameterNames = new ArrayList();
    List parameterTokens = new ArrayList();
    Module parameter;
    Token token;
    String name;
    label_23:
    while (true) {
      name = ModId();
              token = getToken(0);
              parameterNames.add(name);
              parameterTokens.add(token);
              lookForParameter = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_23;
      }
    }
    jj_consume_token(DOUBLECOLON);
    parameter = ModExpr(module);
               for (int i=0; i<parameterNames.size(); i++) {
                    name = (String)parameterNames.get(i);
                    token = (Token)parameterTokens.get(i);

                    // if parameter is a higher order module
                    // then change its parameter name

                    Module theModule = parameter;
                    if (parameter.isParameterized()) {
                        //theModule = parameter.rename();

                        /*
		        System.out.println("------ before rename ------");
		        System.out.println(parameter);
		        System.out.println("------ after rename ------");
                        System.out.println(theModule);
                        System.exit(0);
			*/

                    }

                    try {
                        module.addParameter(name, theModule, getEnv());
                        paraPool.put(name, theModule);
                    } catch (SignatureException e) {

                        String msg = e.getMessage()+
                                     " at line "+token.beginLine+
                                     ", column "+token.endColumn+".";
                        {if (true) throw new ParseException(msg);}

                    } catch (ModuleParameterException e) {

                        String msg = e.getMessage()+
                                     " at line "+token.beginLine+
                                     ", column "+token.endColumn+".";
                        {if (true) throw new ParseException(msg);}
                    }
               }

               lookForParameter = false;
  }

  final public Module ModExpr(Module mod) throws ParseException {
   Module module, module1, module2;
   ModuleName modName;
   Token token;
    module1 = ModSumExpTerm(mod);
            module = module1;

            String notation = (String)module1.getProperty("notation");

            if (notation != null) {
                try {
                    module = module.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);
                   String msg = e.getMessage()+
                                " at line "+token.beginLine+".";
                   {if (true) throw new ParseException(msg);}
                }
            }
    label_24:
    while (true) {
      if (jj_2_26(2)) {
        ;
      } else {
        break label_24;
      }
      jj_consume_token(ADD);
            if (module1.isParameterized()  &&
                lookForParameter) {
                token = getToken(0);
                String msg = "Parameterized module "+module1.modName+
                             " must be used directly "+
                             "as parameter at line "+token.beginLine+".";
                {if (true) throw new ParseException(msg);}
            }
      module2 = ModExpr(mod);
            if (module2.isParameterized()  &&
                lookForParameter) {
                token = getToken(0);
                String msg = "Parameterized module "+module2.modName+
                             " must be used directly "+
                             "as parameter at line "+token.beginLine+".";
                {if (true) throw new ParseException(msg);}
            }

            notation = (String)module2.getProperty("notation");
            if (notation != null) {
                try {
                    module2 = module2.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);
                   String msg = e.getMessage()+
                                " at line "+token.beginLine+".";
                   {if (true) throw new ParseException(msg);}
                }
            }

            int type = module1.getType();
            if (module2.getType() > type) {
                type = module2.getType();
            }

            modName = module1.getModuleName().sum(module2.getModuleName());
            module = new Module(type, modName);

            try {

                module.protectedImport(module1);
                module.protectedImport(module2);
                module1 = module;

            } catch (SignatureException e) {
                token = getToken(0);
                String msg = e.getMessage()+" at line "+token.beginLine+".";
                {if (true) throw new ParseException(msg);}
            }
    }
            {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public Module ModSumExpTerm(Module mod) throws ParseException {
     Module module;
     List list = new ArrayList();
    module = ModExpTerm(mod);
            String notation = (String)module.getProperty("notation");

            if (notation != null) {
                ModuleName nname = module.modName.addAnnotation(notation);
                try {
                    module = module.addAnnotation(notation, getEnv());
                } catch (Exception e) {
                   token = getToken(0);
                   String msg = e.getMessage()+
                                " at line "+token.beginLine+".";
                   {if (true) throw new ParseException(msg);}
                }
            }

            list.add(module);
    label_25:
    while (true) {
      if (jj_2_27(10)) {
        ;
      } else {
        break label_25;
      }
      jj_consume_token(SUM);
            if (module.isParameterized()  &&
                lookForParameter) {
                token = getToken(0);
                String msg = "Parameterized module "+module.modName+
                             " must be used directly "+
                             "as parameter at line "+token.beginLine+".";
                {if (true) throw new ParseException(msg);}
            }
      module = ModExpTerm(mod);
              if (module.isParameterized()  &&
                  lookForParameter) {
                  token = getToken(0);
                  String msg = "Parameterized module "+module.modName+
                               " must be used directly "+
                               "as parameter at line "+token.beginLine+".";
                  {if (true) throw new ParseException(msg);}
              }

              notation = (String)module.getProperty("notation");
              if (notation != null) {
                  try {
                     module = module.addAnnotation(notation, getEnv());
                  } catch (Exception e) {
                     token = getToken(0);
                     String msg = e.getMessage()+
                                  " at line "+token.beginLine+".";
                     {if (true) throw new ParseException(msg);}
                  }
              }
              list.add(module);
    }
            if (list.size() > 1) {
               try {
                    module = Module.makeTuple(mod.getModuleName(), list);
               } catch (Exception e) {

                    token = getToken(0);
                    String msg = e.getMessage()+" at line "+
                                 token.beginLine+".";
                    {if (true) throw new ParseException(msg);}
               }
            }

            {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public Module ModExpTerm(Module mod) throws ParseException {
    Module module;
    String mname;
    Module mtmp;
    Token token;

    String name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case IDENTIFIER:
      name = ModId();
             module = null;

             if (mod != null) {

                if (paraPool != null) {
                     // find a module from parameter 
                     module = (Module)paraPool.get(name);
                     if (module != null) {
                        module.setProperty("notation", name);
                     }
                }
             }

             if (module == null) {

                 // find module from previously defined modules
                 ModuleName modName = new ModuleName(name);

                 module = null;
                 Enumeration enum_ = modPool.keys();
                 while (enum_.hasMoreElements()) {
                    ModuleName tmp = (ModuleName)enum_.nextElement();
                    if (tmp.equals(modName)) {
                        module = (Module)modPool.get(tmp);
                        module = (Module)module.clone();
                        break;
                    }
                 }

             } else {
                 module = (Module)module.clone();
                 module.setProperty("parameter", name);
             }

             if (module == null) {

                 // find module from system default modules
                 module = ModuleFactory.getDefaultModule(name);
             }


             if (module == null) {

                 // find module from previously defined view
                 View view = (View)viewPool.get(name);
                 if (view != null) {
                     module = (Module)view.getTarget().clone();
                     module.setProperty("view", view);
                 }
             }

             if (mod != null && module == null) {
                  Sort[] sorts = mod.getSortsByName(name);
                  if (sorts.length == 1) {

                      //ModuleName modName = sorts[0].getModuleName();
                      ModuleName modName = new ModuleName(name);
                      if (sorts[0].isInitial()) {
                          module = new Module(Module.INITIAL, modName);
                      } else if (sorts[0].isHidden()) {
                          module = new Module(Module.BEHAVORIAL, modName);
                      } else {
                          module = new Module(Module.LOOSE, modName);
                      }

                     try {
                          module.protectedImport(ModuleFactory.createBool());
                          module.addSort(sorts[0]);
                      } catch (Exception e) {}
                  }

             }

             if (module == null) {
                 module = ModuleFactory.getDefaultModule(name);
             }

             if (module == null)  {
                 token = getToken(0);
                 String msg = "Unknown module: "+name+" at line "+
                              token.beginLine+", column "+token.endColumn+".";
                 {if (true) throw new ParseException(msg);}
             }
      break;
    case 144:
      jj_consume_token(144);
      module = ModExpr(mod);
      jj_consume_token(146);
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_26:
    while (true) {
      if (jj_2_28(2147483647)) {
        ;
      } else {
        break label_26;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
                if (module.isParameterized()  &&
                    lookForParameter) {
                    token = getToken(0);
                    String msg = "Parameterized module "+module.modName+
                                 " must be used directly "+
                                 "as parameter at line "+token.beginLine+".";
                    {if (true) throw new ParseException(msg);}
                }

                Map map = new HashMap();
        jj_consume_token(144);
        module = RenameElt(module.getModuleName(), module, map);
        label_27:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 145:
            ;
            break;
          default:
            jj_la1[85] = jj_gen;
            break label_27;
          }
          jj_consume_token(145);
          module = RenameElt(module.getModuleName(), module, map);
        }
        jj_consume_token(146);
                 ModuleName oldName = module.getModuleName();
                 ModuleName newName = oldName.renaming(map);

                 try {
                     module = module.changeModuleName(oldName,
                                                      newName,
                                                      newName);
                 } catch (SignatureException e) {

                    token = getToken(0);
                    String msg = e.getMessage()+" at line "+
                                 token.beginLine+", column "+
                                 token.endColumn+".";
                    {if (true) throw new ParseException(msg);}
                 }
        break;
      case LB:
        jj_consume_token(LB);
                Vector referViews = new Vector();

                Module mainMod = (Module)module.clone();
                ModuleName modName = mainMod.getModuleName();
                Vector modules = new Vector();
                Vector flags = new Vector();
                String parameterName;

                token = getToken(0);
                int index = 0;         // indicate the parameter's position

                Vector views = new Vector();

                String notation = (String)mainMod.getProperty("notation");
                if (notation != null) {
                    try {
                        mainMod = mainMod.addAnnotation(notation, getEnv());
                        modName = modName.addAnnotation(notation);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
        if (jj_2_29(2147483647)) {
                    String string;
          jj_consume_token(144);
          string = OpName();
          jj_consume_token(146);
          jj_consume_token(DOT);
          token = jj_consume_token(144);
          module = ModExpr(mod);
          jj_consume_token(146);
                     if (module == null) {
                         String msg = "unknown module at line "+
                                      token.beginLine+", column "+
                                      token.beginLine;
                         {if (true) throw new ParseException(msg);}
                     }

                     try {

                          // setup source module
                          Module source;
                          View vi = (View)mainMod.getProperty("view");
                          if (vi != null && vi.main != null) {
                              source = vi.main.getParameterAt(index);
                          } else {
                              source = mainMod.getParameterAt(index);
                          }

                          // setup target module
                          Module target = module;

                          // get operations defined in source
                          Operation[] sops = source.getOperationsIn(
                                                 source.getModuleName());
                          if (sops.length != 1) {
                              String msg = "module "+
                                           source.getModuleName()+
                                           " doesn't have a single "+
                                           "operator";
                              {if (true) throw new ParseException(msg);}
                          }

                          // get operations form target
                          Operation[] tops =
                              target.getOperationsWithName(
                                  Operation.normalize(string));

                          boolean useOp = true;
                          Term term = null;

                          if (tops.length > 1) {

                              String msg = "module "+
                                           target.getModuleName()+
                                           " has no unique "+
                                           "operator "+string+".";
                              {if (true) throw new ParseException(msg);}

                          } else if (tops.length == 0) {

                              try {
                                  // need to tokenize opName
                                  StringTokenizer st =
                                      new StringTokenizer(string);
                                  String str = "";
                                  while (st.hasMoreTokens()) {
                                      String s = st.nextToken();
                                      if (target.containsToken(s)) {
                                          str += s+" ";
                                      } else {
                                          String ss =
                                              target.decomposeToken(s);
                                          if (ss == null) {
                                              str += s+" ";
                                          } else {
                                              str += ss+" ";
                                          }
                                       }
                                  }

                                  term = Term.parse(target, str);
                                  useOp = false;

                              } catch (TermException ex) {

                                  if (string.indexOf("_") == -1) {
                                       tops =target.getOperationsWithCleanName(
                                                string.trim());
                                       if (tops.length != 1) {
                                             String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no unique "+
                                                       "operator "+string;
                                             {if (true) throw new ParseException(msg);}
                                       }
                                  } else {
                                       String msg = "module "+
                                            target.getModuleName()+
                                            " has no operator "+string;
                                          {if (true) throw new ParseException(msg);}
                                  }
                               }
                           }

                           String viewName = "("+string.trim()+")"+".("+
                                          module.modName+")";
                           if (!useOp && sops[0].isConstant()) {
                                viewName = "("+term+")"+".("+
                                           module.modName+")";
                           }

                           View view = new View(viewName, source, target);
                           if (useOp) {
                               view.addOperationMap(sops[0], tops[0]);
                           } else if (sops[0].isConstant()) {
                               Term left = new Term(sops[0]);
                               view.addTransformation(left, term);
                           } else {
                               String msg = string+" is not a constant";
                               {if (true) throw new ParseException(msg);}
                           }

                           view.validate();
                           target.setProperty("view", view);

                           flags.addElement(null);
                           modules.addElement(module);

                           views.addElement(view);

                      }  catch (ViewException e) {
                           String msg = e.getMessage()+"  at line "+
                                        token.beginLine+", column "+
                                        token.beginColumn;

                           if (detail) {
                                msg = "format:"+format(msg, 0)+"\u005cn"+
                                      "the failed view is\u005cn"+e.getView();
                           }

                           {if (true) throw new ParseException(msg);}
                      } catch (Exception e) {
                            String msg = e.getMessage()+"  at line "+
                                         token.beginLine+", column "+
                                         token.beginColumn;
                            {if (true) throw new ParseException(msg);}
                      }
        } else if (jj_2_30(2147483647)) {
                        String opName = null;
                        String stModName = null;
                        String tmp;
          jj_consume_token(144);
          label_28:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              token = jj_consume_token(IDENTIFIER);
                                if (opName == null) {
                                    opName = token.image;
                                } else {
                                    opName += " "+token.image;
                                }
              break;
            case INTEGER_LITERAL:
              token = jj_consume_token(INTEGER_LITERAL);
                                if (opName == null) {
                                    opName = token.image;
                                } else {
                                    opName += " "+token.image;
                                }
              break;
            case SYMBOL:
              token = jj_consume_token(SYMBOL);
                                if (opName == null) {
                                    opName = token.image;
                                } else {
                                    opName += " "+token.image;
                                }
              break;
            case OBJ:
            case TH:
            case BTH:
            case DTH:
            case ENDO:
            case ENDTH:
            case ENDB:
            case ENDD:
            case END:
            case PR:
            case PROTECTING:
            case EX:
            case EXTENDING:
            case US:
            case USING:
            case INC:
            case INCLUDING:
            case IS:
            case SORT:
            case SORTS:
            case BSORT:
            case BSORTS:
            case SUBSORT:
            case SUBSORTS:
            case VAR:
            case VARS:
            case OP:
            case OPS:
            case OPAS:
            case EQ:
            case CQ:
            case CEQ:
            case ASSOC:
            case COMM:
            case IDEM:
            case PREC:
            case IDR:
            case ID:
            case NONCONG:
            case MEMO:
            case LESS:
            case ARROW:
            case DOT:
            case VARSOF:
            case COLON:
            case DOUBLECOLON:
            case ADD:
            case SUM:
            case TO:
            case STAR:
            case LB:
            case RB:
            case DFN:
            case RED:
            case BRED:
            case SOLVE:
            case OPEN:
            case OPENR:
            case CLOSE:
            case VIEW:
            case ENDV:
            case FROM:
            case LOAD:
            case APPLY:
            case START:
            case AT:
            case WITH:
            case WITHIN:
            case PRINT:
            case PARENS:
            case OF:
            case QUIT:
            case PWD:
            case CD:
            case LS:
            case IN:
            case SHOW:
            case MAKE:
            case ENDM:
            case LET:
            case COMMENT:
            case COBASIS:
            case COB:
            case COV:
            case STOP:
            case SELECT:
            case SET:
            case TRACE:
            case ON:
            case OFF:
            case FULL:
            case PARSE:
            case INCLUDE:
            case REDUCTION:
            case REDUCE:
            case TIME:
            case RULES:
            case JBO:
            case ASSOCIATIVE:
            case COMMUTATIVE:
            case HT:
            case WEIV:
            case ENDVIEW:
            case GATHERING:
            case PRECEDENCE:
            case THEORY:
            case SH:
            case LONGQUIT:
            case IDEMPOTENT:
            case OBJECT:
            case IDENTITY:
            case DEFINE:
            case INPUT:
            case MORPH:
              token = MetaToken();
                                if (opName == null) {
                                    opName = token.image;
                                } else {
                                    opName += " "+token.image;
                                }
              break;
            case 144:
              jj_consume_token(144);
              tmp = OpName();
              jj_consume_token(146);
                                if (opName == null) {
                                    opName = "( "+tmp+" ) ";
                                } else {
                                    opName += " ( "+tmp+" ) ";
                                }
              break;
            default:
              jj_la1[86] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case OBJ:
            case TH:
            case BTH:
            case DTH:
            case ENDO:
            case ENDTH:
            case ENDB:
            case ENDD:
            case END:
            case PR:
            case PROTECTING:
            case EX:
            case EXTENDING:
            case US:
            case USING:
            case INC:
            case INCLUDING:
            case IS:
            case SORT:
            case SORTS:
            case BSORT:
            case BSORTS:
            case SUBSORT:
            case SUBSORTS:
            case VAR:
            case VARS:
            case OP:
            case OPS:
            case OPAS:
            case EQ:
            case CQ:
            case CEQ:
            case ASSOC:
            case COMM:
            case IDEM:
            case PREC:
            case IDR:
            case ID:
            case NONCONG:
            case MEMO:
            case LESS:
            case ARROW:
            case DOT:
            case VARSOF:
            case COLON:
            case DOUBLECOLON:
            case ADD:
            case SUM:
            case TO:
            case STAR:
            case LB:
            case RB:
            case DFN:
            case RED:
            case BRED:
            case SOLVE:
            case OPEN:
            case OPENR:
            case CLOSE:
            case VIEW:
            case ENDV:
            case FROM:
            case LOAD:
            case APPLY:
            case START:
            case AT:
            case WITH:
            case WITHIN:
            case PRINT:
            case PARENS:
            case OF:
            case QUIT:
            case PWD:
            case CD:
            case LS:
            case IN:
            case SHOW:
            case MAKE:
            case ENDM:
            case LET:
            case COMMENT:
            case COBASIS:
            case COB:
            case COV:
            case STOP:
            case SELECT:
            case SET:
            case TRACE:
            case ON:
            case OFF:
            case FULL:
            case PARSE:
            case INCLUDE:
            case REDUCTION:
            case REDUCE:
            case TIME:
            case RULES:
            case JBO:
            case ASSOCIATIVE:
            case COMMUTATIVE:
            case HT:
            case WEIV:
            case ENDVIEW:
            case GATHERING:
            case PRECEDENCE:
            case THEORY:
            case SH:
            case LONGQUIT:
            case IDEMPOTENT:
            case OBJECT:
            case IDENTITY:
            case DEFINE:
            case INPUT:
            case MORPH:
            case INTEGER_LITERAL:
            case IDENTIFIER:
            case SYMBOL:
            case 144:
              ;
              break;
            default:
              jj_la1[87] = jj_gen;
              break label_28;
            }
          }
          jj_consume_token(146);
          token = jj_consume_token(IDENTIFIER);
                        stModName = token.image;
                        if (stModName.startsWith(".")) {
                            stModName = stModName.substring(1);

                            module = getModule(stModName);
                            if (module == null) {
                                String msg = "No module has the name "+
                                              stModName+"  at line "+
                                              token.beginLine+", column "+
                                              token.beginColumn;
                                {if (true) throw new ParseException(msg);}
                            }

                            // in this case, make sure
                            // formal parameter is a  single operator modules

                            try {

                                Module source;

                                View vi = (View)mainMod.getProperty("view");
                                if (vi != null && vi.main != null) {
                                    source = vi.main.getParameterAt(index);
                                } else {
                                    source = mainMod.getParameterAt(index);
                                }

                                Module target = module;

                                Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
                                if (sops.length != 1) {
                                    String msg = "module "+
                                                 source.getModuleName()+
                                                 " doesn't have a single "+
                                                 "operator";
                                    {if (true) throw new ParseException(msg);}
                                }

                                Operation[] tops =
                                    target.getOperationsWithName(
                                        Operation.normalize(opName));

                                boolean useOp = true;
                                Term term = null;

                                if (tops.length > 1) {
                                    String msg = "module "+
                                                 target.getModuleName()+
                                                 " has no unique "+
                                                 "operator "+opName+".";
                                    {if (true) throw new ParseException(msg);}
                                } else if (tops.length == 0) {

                                    try {

                                       // need to tokenize opName
                                       StringTokenizer st =
                                           new StringTokenizer(opName);
                                       String str = "";
                                       while (st.hasMoreTokens()) {
                                          String s = st.nextToken();
                                          if (target.containsToken(s)) {
                                             str += s+" ";
                                          } else {
                                             String ss =
                                                target.decomposeToken(s);
                                             if (ss == null) {
                                                str += s+" ";
                                             } else {
                                                str += ss+" ";
                                             }
                                          }
                                       }
                                       //opName = str;
                                       term = Term.parse(target, str);
                                       useOp = false;
                                    } catch (TermException ex) {

                                       if (opName.indexOf("_") == -1) {
                                          tops =
                                             target.getOperationsWithCleanName(
                                                opName.trim());
                                          if (tops.length != 1) {
                                             String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no unique "+
                                                       "operator "+opName;
                                             {if (true) throw new ParseException(msg);}
                                          }
                                       } else {

                                          String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no "+
                                                       "operator "+opName;
                                          {if (true) throw new ParseException(msg);}
                                       }

                                    }
                                }

                                String viewName = "("+opName.trim()+")"+"."+
                                                  stModName;
                                if (!useOp && sops[0].isConstant()) {
                                    viewName = "("+term+")"+"."+
                                                  stModName;
                                }

                                View view = new View(viewName, source, target);
                                if (useOp) {
                                   view.addOperationMap(sops[0], tops[0]);
                                } else if (sops[0].isConstant()) {
                                   Term left = new Term(sops[0]);
                                   view.addTransformation(left, term);
                                } else {
                                   String msg = opName+" is not a constant";
                                   {if (true) throw new ParseException(msg);}
                                }

                                view.validate();
                                target.setProperty("view", view);

                                flags.addElement(null);
                                modules.addElement(module);

                                views.addElement(view);

                            }  catch (ViewException e) {
                                String msg = e.getMessage()+"  at line "+
                                             token.beginLine+", column "+
                                             token.beginColumn;

                                if (detail) {
                                    msg = "format:"+format(msg, 0)+"\u005cn"+
                                          "the failed view is\u005cn"+e.getView();
                                }

                                {if (true) throw new ParseException(msg);}
                            } catch (Exception e) {
                                String msg = e.getMessage()+"  at line "+
                                             token.beginLine+", column "+
                                             token.beginColumn;
                                {if (true) throw new ParseException(msg);}
                            }

                        } else {
                            String msg = "expect \u005c".\u005c" at line "+
                                         token.beginLine+", column "+
                                         token.beginColumn;
                            {if (true) throw new ParseException(msg);}
                        }
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER_LITERAL:
          case IDENTIFIER:
          case 144:
            module = ModExpr(mod);
                     modules.addElement(module);
                     String flag = (String)module.getProperty("parameter");
                     flags.addElement(flag);

                     if (flag != null) {
                         module.removeProperty("parameter");
                     }

                     // handle dependent type
                     try {
                        Module parameter;
                        View vi = (View)mainMod.getProperty("view");
                        String paraName;
                        if (vi != null && vi.main != null) {
                            parameter = vi.main.getParameterAt(index);
                            paraName = vi.main.getParameterNameAt(index);
                        } else {
                            parameter = mainMod.getParameterAt(index);
                            paraName = mainMod.getParameterNameAt(index);
                        }

                        View view = (View)module.getProperty("view");

                        if (view == null) {
                            view = module.getViewFor(parameter);
                            module.setProperty("view", view);

                            if (view == null) {
                                 String msg = module.getModuleName()+
                                              " is not an instance of "+
                                              parameter.getModuleName();
                                 {if (true) throw new ParseException(msg);}
                            }
                        } else if (!view.source.modName.equals(
                                       parameter.modName)){
                            String msg = "the view is defined on "+
                                         view.source.modName+", "+
                                         "not on "+parameter.modName;
                            {if (true) throw new ParseException(msg);}
                        }

                        view = view.addNotation(paraName, null, getEnv());

                        views.addElement(view);
                        view.validate();

                     } catch (Exception e) {

                        String msg = e.getMessage()+" at line "+
                                     token.beginLine+", column "+
                                     token.beginColumn;
                        {if (true) throw new ParseException(msg);}
                     }

                     // end handling

            break;
          case VIEW:
                     Module source = null;
                     try {
                         source = mainMod.getParameterAt(index);

                         // for dependent type, source is not correct

                     } catch (ModuleParameterException e) {
                         token = getToken(0);
                         String msg = e.getMessage()+" at line "+
                                      token.beginLine+", column "+
                                      token.endColumn+".";
                         {if (true) throw new ParseException(msg);}
                     }
            module = LocalViewDecl(mod, source, views);
                    flags.addElement(null);
                    modules.addElement(module);

                    // handle dependent type
                    views.addElement(module.getProperty("view"));
            break;
          default:
            jj_la1[88] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
                  index++;
        label_29:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 145:
            ;
            break;
          default:
            jj_la1[89] = jj_gen;
            break label_29;
          }
          jj_consume_token(145);
          if (jj_2_31(2147483647)) {
                    String string;
            jj_consume_token(144);
            string = OpName();
            jj_consume_token(146);
            jj_consume_token(DOT);
            token = jj_consume_token(144);
            module = ModExpr(mod);
            jj_consume_token(146);
                     if (module == null) {
                         String msg = "unknown module at line "+
                                      token.beginLine+", column "+
                                      token.beginLine;
                         {if (true) throw new ParseException(msg);}
                     }

                     try {

                          // setup source module
                          Module source;
                          View vi = (View)mainMod.getProperty("view");
                          if (vi != null && vi.main != null) {
                              source = vi.main.getParameterAt(index);
                          } else {
                              source = mainMod.getParameterAt(index);
                          }

                          // get operations defined in source
                          Operation[] sops = source.getOperationsIn(
                                                 source.getModuleName());
                          if (sops.length != 1) {
                              String msg = "module "+
                                           source.getModuleName()+
                                           " doesn't have a single "+
                                           "operator";
                              {if (true) throw new ParseException(msg);}
                          }

                          // handle depentdent type
                          if (!source.isParameterized()) {
                              Module m = source;
                              for (int i=0; i<views.size(); i++) {
                                  vi = (View)views.elementAt(i);
                                  String paraName = mainMod.getParameterNameAt(i);
                                  vi = vi.addNotation(paraName, null, getEnv());

                                  if (m.containsAnnotation(paraName)) {
                                     m.importModule(vi.target);
                                     m = vi.getImage(m);

                                     m = m.changeModuleName(vi.source.modName,
                                                            vi.target.modName,
                                                            m.modName);

                                     sops[0] = vi.getImage(sops[0]);
                                     sops[0] = sops[0].changeModuleName(
                                                   vi.source.modName,
                                                   vi.target.modName);
                                  }
                               }
                               source = m;
                          }

                          // setup target module
                          Module target = module;

                          // get operations form target
                          Operation[] tops =
                              target.getOperationsWithName(
                                  Operation.normalize(string));

                          boolean useOp = true;
                          Term term = null;

                          if (tops.length > 1) {

                              String msg = "module "+
                                           target.getModuleName()+
                                           " has no unique "+
                                           "operator "+string+".";
                              {if (true) throw new ParseException(msg);}

                          } else if (tops.length == 0) {

                              try {
                                  // need to tokenize opName
                                  StringTokenizer st =
                                      new StringTokenizer(string);
                                  String str = "";
                                  while (st.hasMoreTokens()) {
                                      String s = st.nextToken();
                                      if (target.containsToken(s)) {
                                          str += s+" ";
                                      } else {
                                          String ss =
                                              target.decomposeToken(s);
                                          if (ss == null) {
                                              str += s+" ";
                                          } else {
                                              str += ss+" ";
                                          }
                                       }
                                  }

                                  term = Term.parse(target, str);
                                  useOp = false;

                              } catch (TermException ex) {

                                  if (string.indexOf("_") == -1) {
                                       tops = target.getOperationsWithCleanName(
                                                string.trim());
                                       if (tops.length != 1) {
                                             String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no unique "+
                                                       "operator "+string;
                                             {if (true) throw new ParseException(msg);}
                                       }
                                  } else {
                                       String msg = "module "+
                                            target.getModuleName()+
                                            " has no operator "+string;
                                          {if (true) throw new ParseException(msg);}
                                  }
                               }
                           }

                           String viewName = "("+string.trim()+")"+".("+
                                          module.modName+")";
                           if (!useOp && sops[0].isConstant()) {
                                viewName = "("+term+")"+".("+
                                           module.modName+")";
                           }

                           View view = new View(viewName, source, target);
                           if (useOp) {
                               view.addOperationMap(sops[0], tops[0]);
                           } else if (sops[0].isConstant()) {
                               Term left = new Term(sops[0]);
                               view.addTransformation(left, term);
                           } else {
                               String msg = string+" is not a constant";
                               {if (true) throw new ParseException(msg);}
                           }

                           view.validate();
                           target.setProperty("view", view);

                           flags.addElement(null);
                           modules.addElement(module);

                           views.addElement(view);

                      }  catch (ViewException e) {
                           String msg = e.getMessage()+"  at line "+
                                        token.beginLine+", column "+
                                        token.beginColumn;

                           if (detail) {
                                msg = "format:"+format(msg, 0)+"\u005cn"+
                                      "the failed view is\u005cn"+e.getView();
                           }

                           {if (true) throw new ParseException(msg);}
                      } catch (Exception e) {
                            String msg = e.getMessage()+"  at line "+
                                         token.beginLine+", column "+
                                         token.beginColumn;
                            {if (true) throw new ParseException(msg);}
                      }
          } else if (jj_2_32(2147483647)) {
                        String opName = null;
                        String stModName = null;
                        String tmp;
            jj_consume_token(144);
            label_30:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case IDENTIFIER:
                token = jj_consume_token(IDENTIFIER);
                                if (opName == null) {
                                   opName = token.image;
                                } else {
                                   opName += " "+token.image;
                                }
                break;
              case INTEGER_LITERAL:
                token = jj_consume_token(INTEGER_LITERAL);
                                if (opName == null) {
                                   opName = token.image;
                                } else {
                                   opName += " "+token.image;
                                }
                break;
              case SYMBOL:
                token = jj_consume_token(SYMBOL);
                                if (opName == null) {
                                   opName = token.image;
                                } else {
                                   opName += " "+token.image;
                                }
                break;
              case OBJ:
              case TH:
              case BTH:
              case DTH:
              case ENDO:
              case ENDTH:
              case ENDB:
              case ENDD:
              case END:
              case PR:
              case PROTECTING:
              case EX:
              case EXTENDING:
              case US:
              case USING:
              case INC:
              case INCLUDING:
              case IS:
              case SORT:
              case SORTS:
              case BSORT:
              case BSORTS:
              case SUBSORT:
              case SUBSORTS:
              case VAR:
              case VARS:
              case OP:
              case OPS:
              case OPAS:
              case EQ:
              case CQ:
              case CEQ:
              case ASSOC:
              case COMM:
              case IDEM:
              case PREC:
              case IDR:
              case ID:
              case NONCONG:
              case MEMO:
              case LESS:
              case ARROW:
              case DOT:
              case VARSOF:
              case COLON:
              case DOUBLECOLON:
              case ADD:
              case SUM:
              case TO:
              case STAR:
              case LB:
              case RB:
              case DFN:
              case RED:
              case BRED:
              case SOLVE:
              case OPEN:
              case OPENR:
              case CLOSE:
              case VIEW:
              case ENDV:
              case FROM:
              case LOAD:
              case APPLY:
              case START:
              case AT:
              case WITH:
              case WITHIN:
              case PRINT:
              case PARENS:
              case OF:
              case QUIT:
              case PWD:
              case CD:
              case LS:
              case IN:
              case SHOW:
              case MAKE:
              case ENDM:
              case LET:
              case COMMENT:
              case COBASIS:
              case COB:
              case COV:
              case STOP:
              case SELECT:
              case SET:
              case TRACE:
              case ON:
              case OFF:
              case FULL:
              case PARSE:
              case INCLUDE:
              case REDUCTION:
              case REDUCE:
              case TIME:
              case RULES:
              case JBO:
              case ASSOCIATIVE:
              case COMMUTATIVE:
              case HT:
              case WEIV:
              case ENDVIEW:
              case GATHERING:
              case PRECEDENCE:
              case THEORY:
              case SH:
              case LONGQUIT:
              case IDEMPOTENT:
              case OBJECT:
              case IDENTITY:
              case DEFINE:
              case INPUT:
              case MORPH:
                token = MetaToken();
                                if (opName == null) {
                                   opName = token.image;
                                } else {
                                   opName += " "+token.image;
                                }
                break;
              case 144:
                jj_consume_token(144);
                tmp = OpName();
                                  if (opName == null) {
                                      opName = " ( "+tmp+" ) ";
                                  } else {
                                      opName += " ( "+tmp+" ) ";
                                  }
                jj_consume_token(146);
                break;
              default:
                jj_la1[90] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case OBJ:
              case TH:
              case BTH:
              case DTH:
              case ENDO:
              case ENDTH:
              case ENDB:
              case ENDD:
              case END:
              case PR:
              case PROTECTING:
              case EX:
              case EXTENDING:
              case US:
              case USING:
              case INC:
              case INCLUDING:
              case IS:
              case SORT:
              case SORTS:
              case BSORT:
              case BSORTS:
              case SUBSORT:
              case SUBSORTS:
              case VAR:
              case VARS:
              case OP:
              case OPS:
              case OPAS:
              case EQ:
              case CQ:
              case CEQ:
              case ASSOC:
              case COMM:
              case IDEM:
              case PREC:
              case IDR:
              case ID:
              case NONCONG:
              case MEMO:
              case LESS:
              case ARROW:
              case DOT:
              case VARSOF:
              case COLON:
              case DOUBLECOLON:
              case ADD:
              case SUM:
              case TO:
              case STAR:
              case LB:
              case RB:
              case DFN:
              case RED:
              case BRED:
              case SOLVE:
              case OPEN:
              case OPENR:
              case CLOSE:
              case VIEW:
              case ENDV:
              case FROM:
              case LOAD:
              case APPLY:
              case START:
              case AT:
              case WITH:
              case WITHIN:
              case PRINT:
              case PARENS:
              case OF:
              case QUIT:
              case PWD:
              case CD:
              case LS:
              case IN:
              case SHOW:
              case MAKE:
              case ENDM:
              case LET:
              case COMMENT:
              case COBASIS:
              case COB:
              case COV:
              case STOP:
              case SELECT:
              case SET:
              case TRACE:
              case ON:
              case OFF:
              case FULL:
              case PARSE:
              case INCLUDE:
              case REDUCTION:
              case REDUCE:
              case TIME:
              case RULES:
              case JBO:
              case ASSOCIATIVE:
              case COMMUTATIVE:
              case HT:
              case WEIV:
              case ENDVIEW:
              case GATHERING:
              case PRECEDENCE:
              case THEORY:
              case SH:
              case LONGQUIT:
              case IDEMPOTENT:
              case OBJECT:
              case IDENTITY:
              case DEFINE:
              case INPUT:
              case MORPH:
              case INTEGER_LITERAL:
              case IDENTIFIER:
              case SYMBOL:
              case 144:
                ;
                break;
              default:
                jj_la1[91] = jj_gen;
                break label_30;
              }
            }
            jj_consume_token(146);
            token = jj_consume_token(IDENTIFIER);
                        stModName = token.image;
                        if (stModName.startsWith(".")) {
                            stModName = stModName.substring(1);

                            module = getModule(stModName);
                            if (module == null) {
                                String msg = "No module has the name "+
                                              stModName+"  at line "+
                                              token.beginLine+", column "+
                                              token.beginColumn;
                                {if (true) throw new ParseException(msg);}
                            }


                            // in this case, make sure
                            // formal parameter is a single operator modules

                            try {

                                Module source;

                                View vi = (View)mainMod.getProperty("view");
                                if (vi != null && vi.main != null) {
                                    source = vi.main.getParameterAt(index);
                                } else {
                                    source = mainMod.getParameterAt(index);
                                }


                                Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
                                if (sops.length != 1) {
                                    String msg = "module "+
                                                 source.getModuleName()+
                                                 " doesn't have a single "+
                                                 "operator";
                                    {if (true) throw new ParseException(msg);}
                                }
                                if (!source.isParameterized()) {
                                    Module m = source;
                                    for (int i=0; i<views.size(); i++) {
                                        vi = (View)views.elementAt(i);

                                        String paraName =
                                            mainMod.getParameterNameAt(i);
                                        vi = vi.addNotation(paraName,
                                                            null,
                                                            getEnv());

                                        if (m.containsAnnotation(paraName)) {
                                            m.importModule(vi.target);
                                            m = vi.getImage(m);

                                            m = m.changeModuleName(
                                                  vi.source.modName,
                                                  vi.target.modName,
                                                  m.modName);

                                            sops[0] = vi.getImage(sops[0]);
                                            sops[0] =
                                               sops[0].changeModuleName(
                                                      vi.source.modName,
                                                      vi.target.modName);
                                        }
                                    }

                                    source = m;
                                }

                                Module target = module;

                                boolean useOp = true;
                                Term term = null;

                                Operation[] tops =
                                    target.getOperationsWithName(
                                        Operation.normalize(opName));

                                if (tops.length > 1) {

                                    ArrayList list = new ArrayList();
                                    for (int i=0; i<tops.length; i++) {
                                       if (tops[i].hasSameSignature(sops[0])) {
                                          list.add(tops[i]);
                                       }
                                    }

                                    if (list.size() != 1) {
                                       String msg = "module "+
                                                    target.getModuleName()+
                                                    " has multiple "+
                                                    "operator "+opName ;
                                       {if (true) throw new ParseException(msg);}
                                    } else {
                                       tops[0] = (Operation)list.get(0);
                                    }
                                } else if (tops.length == 0) {

                                    try {

                                       // need to tokenize opName
                                       StringTokenizer st =
                                           new StringTokenizer(opName);
                                       String str = "";
                                       while (st.hasMoreTokens()) {
                                          String s = st.nextToken();
                                          if (target.containsToken(s)) {
                                             str += s+" ";
                                          } else {
                                             String ss =
                                                target.decomposeToken(s);
                                             if (ss == null) {
                                                str += s+" ";
                                             } else {
                                                str += ss+" ";
                                             }
                                          }
                                       }
                                       opName = str;

                                       term = Term.parse(target, opName);
                                       useOp = false;
                                    } catch (TermException ex) {

                                       if (opName.indexOf("_") == -1) {
                                          tops =
                                             target.getOperationsWithCleanName(
                                                opName.trim());
                                          if (tops.length != 1) {
                                             String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no unique "+
                                                       "operator "+opName;
                                             {if (true) throw new ParseException(msg);}
                                          }
                                       } else {

                                          String msg = "module "+
                                                       target.getModuleName()+
                                                       " has no "+
                                                       "operator "+opName;
                                          {if (true) throw new ParseException(msg);}
                                       }
                                    }
                                }

                                /*
			        Operation[] sops = source.getOperationsIn(
                                                      source.getModuleName());
				if (sops.length != 1) {
                                    String msg = "module "+
						 source.getModuleName()+
						 " doesn't have a single "+
                                                 "operator";
			            throw new ParseException(msg);
			        }
                                */

                                String viewName = "("+opName.trim()+")"+"."+
                                                  stModName;
                                if (!useOp && sops[0].isConstant()) {
                                    viewName = "("+term+")"+"."+
                                                  stModName;
                                }

                                View view = new View(viewName, source, target);

                                if (useOp) {
                                   view.addOperationMap(sops[0], tops[0]);
                                } else if (sops[0].isConstant()) {
                                   Term left = new Term(sops[0]);
                                   view.addTransformation(left, term);
                                } else {
                                   String msg = opName+" is not a constant";
                                   {if (true) throw new ParseException(msg);}
                                }

                                view.validate();
                                target.setProperty("view", view);

                                flags.addElement(null);
                                modules.addElement(module);

                                views.addElement(view);

                                index++;

                            } catch (ViewException e) {

                                String msg = e.getMessage()+" at line "+
                                             token.beginLine+", column "+
                                             token.beginColumn;

                                if (detail) {
                                    msg = "format:"+format(msg, 0)+"\u005cn"+
                                          "the failed view is\u005cn"+e.getView();
                                }
                                {if (true) throw new ParseException(msg);}
                            } catch (Exception e) {
                                String msg = e.getMessage()+" at line "+
                                             token.beginLine+", column "+
                                             token.beginColumn;
                                {if (true) throw new ParseException(msg);}
                            }

                   } else {
                            String msg = "expect \u005c".\u005c" at line "+
                                         token.beginLine+", column "+
                                         token.beginColumn;
                            {if (true) throw new ParseException(msg);}
                        }
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INTEGER_LITERAL:
            case IDENTIFIER:
            case 144:
              module = ModExpr(mod);
                      modules.addElement(module);
                      String flag = (String)module.getProperty("parameter");
                      flags.addElement(flag);

                      if (flag != null) {
                         module.removeProperty("parameter");
                      }

                      // handle dependent type
                      try {

                        Module parameter;
                        View vi = (View)mainMod.getProperty("view");
                        if (vi != null && vi.main != null) {
                            parameter = vi.main.getParameterAt(index);
                        } else {
                            parameter = mainMod.getParameterAt(index);

                            // this parameter maybe not right
                            // should check it at first

                            if (!parameter.isParameterized()) {
                                Module tmp = parameter;

                                for (int i=0; i<views.size(); i++) {
                                    vi = (View)views.elementAt(i);

                                    String paraName =
                                        mainMod.getParameterNameAt(i);
                                    vi = vi.addNotation(paraName,
                                                        null,
                                                        getEnv());

                                    if (tmp.containsAnnotation(paraName)) {
                                        tmp.importModule(vi.target);
                                        tmp = vi.getImage(tmp);

                                        ModuleName tmpName = tmp.modName;
                                        tmpName = tmpName.changeModuleName(
                                                    vi.source.modName,
                                                    vi.target.modName);

                                        tmp = tmp.changeModuleName(
                                               vi.source.modName,
                                               vi.target.modName,
                                               tmpName);

                                    }
                                }

                                parameter = tmp;
                            }
                        }

                        View view = (View)module.getProperty("view");

                        if (view == null) {
                            view = module.getViewFor(parameter);
                            if (view == null) {
                                 String msg = module.getModuleName()+
                                              " is not an instance of "+
                                              parameter.getModuleName();
                                 {if (true) throw new ParseException(msg);}
                            }
                        }

                        views.addElement(view);
                        module.setProperty("view", view);

                      } catch (Exception e) {
                        String msg = e.getMessage()+"  at line "+
                                     token.beginLine+", column "+
                                     token.beginColumn;
                        {if (true) throw new ParseException(msg);}
                      }

                      // end handling

                      index++;
              break;
            case VIEW:
                       Module source = null;
                       try {
                           source = mainMod.getParameterAt(index);

                           if (!source.isParameterized()) {
                               Module tmp = source;

                               for (int i=0; i<views.size(); i++) {
                                    View vi = (View)views.elementAt(i);
                                    String paraName =
                                        mainMod.getParameterNameAt(i);
                                    vi = vi.addNotation(paraName,
                                                        null,
                                                        getEnv());

                                    if (tmp.containsAnnotation(paraName)) {

                                        tmp.importModule(vi.target);
                                        tmp = vi.getImage(tmp);

                                        /*
			                tmp = tmp.changeModuleName(
				                 new ModuleName(paraName),
				                 vi.target.modName,
					         tmp.modName);
				        */

                                        ModuleName tmpName = tmp.modName;
                                        tmpName = tmpName.changeModuleName(
                                                    vi.source.modName,
                                                    vi.target.modName);

                                        tmp = tmp.changeModuleName(
                                                  vi.source.modName,
                                                  vi.target.modName,
                                                  tmpName);

                                    }

                               }

                               source = tmp;

                            } else {

                                // bug fix: 2002 6 6

                                // handle dependent type

                                // this parameter maybe not right
                                // should check it at first

                                // create correct module name
                                Module tmp = source;
                                for (int i=0; i<views.size(); i++) {
                                   View vi = (View)views.elementAt(i);

                                   String paraName =
                                        mainMod.getParameterNameAt(i);
                                   vi = vi.addNotation(paraName,
                                                       null,
                                                       getEnv());
                                   tmp.importModule(vi.target);
                                   tmp = vi.getImage(tmp);

                                   ModuleName tmpName = tmp.modName;
                                   tmpName = tmpName.changeModuleName(
                                          vi.source.modName,
                                          new ModuleName(vi.name));

                                   tmp = tmp.changeModuleName(vi.source.modName,
                                                              new ModuleName(vi.name),
                                                              tmpName);

                                }

                                source = tmp;
                                // end handling

                            }


                       } catch (Exception e) {
                           token = getToken(0);
                           String msg = e.getMessage()+" at line "+
                                        token.beginLine+", column "+
                                        token.endColumn+".";
                           {if (true) throw new ParseException(msg);}
                       }
              module = LocalViewDecl(mod, source, views);
                       flags.addElement(null);
                       modules.addElement(module);
                       index++;

                       views.addElement(module.getProperty("view"));
              break;
            default:
              jj_la1[92] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(RB);
                module = mainMod;

                // setup actual parameters
                Module[] parameters = new Module[modules.size()];
                modules.copyInto(parameters);

                // setup flags for the actual parameters
                String[] notations = new String[flags.size()];
                flags.copyInto(notations);

                // handle parameterized view
                View view = (View)module.getProperty("view");
                if (view != null && view.main != null) {

                    try {
                        view = view.instanceBy(parameters,
                                               notations,
                                               getEnv());

                    } catch (Exception e) {
                        String msg = e.getMessage();
                        msg += " at line "+token.beginLine+", column "+
                               token.endColumn+".";
                        {if (true) throw new ParseException(msg);}
                    }
                    module = view.target;
                    module.setProperty("view", view);

                } else {

                   try {
                        boolean highOrder = false;
                        if (mod != null) {
                            highOrder = mod.isSecondOrder();
                        }

                        module = module.instanceBy(parameters,
                                                   notations,
                                                   getEnv(),
                                                   highOrder);


                   } catch (ModuleInstanceException e) {

                        //e.printStackTrace();

                        String msg = e.getMessage();
                        msg += " at line "+token.beginLine+", column "+
                               token.endColumn+".";
                        {if (true) throw new ParseException(msg);}
                   }
                }
        break;
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
           {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public Module RenameElt(ModuleName modName, Module mod, Map map) throws ParseException {
    Token token;
    Sort sourceSort, targetSort;
    String source, target;
    Module module = null ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SORT:
      jj_consume_token(SORT);
      sourceSort = SortReference(mod);
             if (sourceSort == null) {
                   String msg = sourceSort+" "+
                                "is not found in the "+
                                "module "+mod.getModuleName()+
                                "at line "+getToken(0).beginLine;
                   {if (true) throw new ParseException(msg);}
             }
      jj_consume_token(TO);
      token = jj_consume_token(IDENTIFIER);
            try {
                if (sourceSort.isHidden()) {
                    targetSort =
                       new HiddenSort(token.image, mod.getModuleName());
                } else if (sourceSort.isInitial()) {
                    targetSort =
                       new InitialSort(token.image, mod.getModuleName());
                } else {
                    targetSort = new Sort(token.image, mod.getModuleName());
                }

                module = mod.changeSort(modName, sourceSort, targetSort);
                map.put(sourceSort, targetSort);

            } catch (SignatureException e) {

                String msg = e.getMessage()+
                             "at line "+getToken(0).beginLine;
                {if (true) throw new ParseException(msg);}
            }
      break;
    case OP:
      jj_consume_token(OP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case LESS:
      case ARROW:
      case ADD:
      case SUM:
      case STAR:
      case LB:
      case PARENS:
      case QUIT:
      case LET:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        source = OpNameNoComma();
        break;
      case 144:
        jj_consume_token(144);
        source = OpNameNoComma();
        jj_consume_token(146);
        break;
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              Operation[] ops = mod.getOperationsWithName(source.trim());
              if (ops.length == 0) {

                   String msg = "op "+source.trim()+" "+
                                "is not found in the "+
                                "module "+mod.getModuleName()+
                                " at line "+getToken(0).beginLine;
                   {if (true) throw new ParseException(msg);}

              }
      jj_consume_token(TO);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case LESS:
      case ARROW:
      case ADD:
      case SUM:
      case STAR:
      case LB:
      case PARENS:
      case QUIT:
      case LET:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        target = OpNameNoComma();
        break;
      case 144:
        jj_consume_token(144);
        target = OpNameNoComma();
        jj_consume_token(146);
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
             try {


                 for (int i=0; i<ops.length; i++) {

                     Operation sourceOp = ops[i];
                     Operation targetOp =sourceOp.replaceOperationName(target);

                     if (i == 0) {
                         module = mod.replaceOperation(modName,
                                                       sourceOp,
                                                       targetOp);
                     } else {
                         module = module.replaceOperation(modName,
                                                          sourceOp,
                                                          targetOp);
                     }

                      map.put(sourceOp, targetOp);
                  }
             } catch (SignatureException e) {
                String msg = e.getMessage()+
                             "at line "+getToken(0).beginLine;
                {if (true) throw new ParseException(msg);}
            }
      break;
    default:
      jj_la1[96] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return module;}
    throw new Error("Missing return statement in function");
  }

  final public Sort SortReference(Module module) throws ParseException {
    Token token;
    ModuleName modName = null;
    Module mod = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      token = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          boolean okay = false;
          try {
             Token t1 = getToken(1);
             if (t1.next != null &&
                 t1.next.beginLine == t1.beginLine &&
                 t1.endColumn + 1 == t1.next.beginLine) {
                okay = true;
             }
          } catch (Exception e) {

          }
    if (okay) {
      jj_consume_token(DOT);
      mod = ModExpr(module);
    } else {
      ;
    }
            int index = token.image.indexOf(".");
            if (index != -1) {

                String modRef = token.image.substring(index+1);
                modName = new ModuleName(modRef);
                Sort sort = new Sort(token.image.substring(0, index),
                                     modName);
                sort = module.getSort(sort);

                if (sort == null && paraPool.containsKey(modRef)) {
                    Module para = (Module)paraPool.get(modRef);
                    modName = para.getModuleName().addAnnotation(modRef);
                    sort = new Sort(token.image.substring(0, index),
                                    modName);
                    sort = module.getSort(sort);

                }

                if (sort == null) {

                     String msg = "No sort with name "+token.image+
                                  " was found in the module "+
                                  module.getModuleName()+" "+
                                  "at line "+token.beginLine+", column "+
                                  token.endColumn+".";

                     {if (true) throw new ParseException(msg);}


                } else {
                    {if (true) return sort;}
                }

            } else if (mod != null) {

                Sort sort = new Sort(token.image,
                                     mod.getModuleName());
                sort = module.getSort(sort);

                if (sort == null) {

                     String msg = "No sort with name "+token.image+
                                  " was found in the module "+
                                  module.getModuleName()+" "+
                                  "at line "+token.beginLine+", column "+
                                  token.endColumn+".";

                     {if (true) throw new ParseException(msg);}


                } else {
                    {if (true) return sort;}
                }

            } else {

                Sort[] sorts = module.getSortsByName(token.image);
                if (sorts.length == 0) {

                     String msg = "No sort with name "+token.image+
                                  " was found in the module "+
                                  module.getModuleName()+" "+
                                  "at line "+token.beginLine+", column "+
                                  token.endColumn+".";
                     {if (true) throw new ParseException(msg);}

                } else if (sorts.length == 1) {

                     {if (true) return sorts[0];}

                } else {
                      String msg = sorts.length+" sorts with name "+
                                   token.image+" was found in the module "+
                                   module.getModuleName()+" at line "+
                                   token.beginLine+", column "+
                                   token.endColumn+".";
                      {if (true) throw new ParseException(msg);}
                 }
           }
    throw new Error("Missing return statement in function");
  }

  final public ModuleName ModuleReference(Module module) throws ParseException {
    Token token;
    token = jj_consume_token(IDENTIFIER);
             {if (true) return new ModuleName(token.image);}
    throw new Error("Missing return statement in function");
  }

  final public String ModId() throws ParseException {
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      token = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  final public void ModElt(Module module) throws ParseException {
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PR:
      case PROTECTING:
        ProtectedImport(module);
        break;
      case EX:
      case EXTENDING:
        ExtendedImport(module);
        break;
      case US:
      case USING:
      case INC:
      case INCLUDING:
        UsedImport(module);
        break;
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
        SortsDecl(module);
        break;
      case SUBSORT:
      case SUBSORTS:
        SubsortDecl(module);
        break;
      case VAR:
      case VARS:
        VarDecl(module);
        break;
      case VARSOF:
        VarImport(module);
        break;
      case OP:
      case OPS:
      case OPAS:
        OperationDecl(module);
        break;
      case EQ:
      case CQ:
      case CEQ:
      case LB:
        EquationDecl(module);
        break;
      case DFN:
      case DEFINE:
        DefDecl(module);
        break;
      case MB:
        MembershipDecl(module);
        break;
      case LET:
        LetDecl(module);
        break;
      case COMMENT:
        jj_consume_token(COMMENT);
               boolean found = false;
               String msg = "";
               while (!found) {
                 try {
                    char more = jj_input_stream.readChar();
                    found = more == '\u005cn';
                    msg += more;
                 } catch (IOException e) {
                    found = true;
                    msg += "\u005cn";
                 }
               }

               try {
                  if (mode == FILE_INPUT)
                      writer.write("====================="+
                                   "=====================\u005cn");
                  writer.write("***> "+msg);
                  writer.flush();
               } catch (IOException e) {
                  {if (true) throw new ParseException(e.getMessage()+" at line "+
                                           getToken(0).beginLine+".");}
               }
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              cobasisUpdated = true;
      if (jj_2_33(2)) {
        ;
      } else {
        break label_31;
      }
    }
  }

  final public void ProtectedImport(Module module) throws ParseException {
  Module mod;
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PR:
      jj_consume_token(PR);
      break;
    case PROTECTING:
      jj_consume_token(PROTECTING);
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_34(2147483647)) {
      token = jj_consume_token(IDENTIFIER);
      jj_consume_token(IS);
      mod = ModExpr(module);
               try {

                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\u005cn");
                       writer.write("protecting "+token.image+" is "+
                                    mod.getModuleName()+"\u005cn");
                       writer.flush();
                   }

                   String notation = (String)mod.getProperty("notation");
                   if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
                       mod = mod.changeModuleName(mod.modName, nname, nname);
                   }

                   ModuleName nname = new ModuleName(token.image);
                   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
                   module.protectedImport(mod);

                   saveModule(mod);

               } catch (Exception e) {
                   Token xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   {if (true) throw new ParseException(msg);}
               }
    } else {
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 144:
          ;
          break;
        default:
          jj_la1[101] = jj_gen;
          break label_32;
        }
        mod = ModExpr(module);
             try {

                 String notation = (String)mod.getProperty("notation");
                 if (notation != null) {
                     mod = mod.addAnnotation(notation, getEnv());
                 }

                 module.protectedImport(mod);

                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("protecting "+mod.getModuleName()+"\u005cn");
                     writer.flush();
                 }

             } catch (Exception e) {
                 Token xt = getToken(0);
                 String msg = e.getMessage();
                 msg +=" at line "+xt.beginLine+".";
                 {if (true) throw new ParseException(msg);}
             }
      }
    }
    jj_consume_token(DOT);
  }

  final public void ExtendedImport(Module module) throws ParseException {
  Module mod;
  Token token, xt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EX:
      xt = jj_consume_token(EX);
      break;
    case EXTENDING:
      xt = jj_consume_token(EXTENDING);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_35(2147483647)) {
      token = jj_consume_token(IDENTIFIER);
      jj_consume_token(IS);
      mod = ModExpr(module);
               try {

                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\u005cn");
                       writer.write("using "+token.image+" is "+
                                    mod.getModuleName()+"\u005cn");
                       writer.flush();
                   }


                   String notation = (String)mod.getProperty("notation");
                   if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
                       mod = mod.changeModuleName(mod.modName, nname, nname);
                   }

                   ModuleName nname = new ModuleName(token.image);
                   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
                   //module.usedImport(mod);
                   module.protectedImport(mod);

                   saveModule(mod);

               } catch (Exception e) {
                   xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   {if (true) throw new ParseException(msg);}
               }
    } else {
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 144:
          ;
          break;
        default:
          jj_la1[103] = jj_gen;
          break label_33;
        }
        mod = ModExpr(module);
             try {

                 String notation = (String)mod.getProperty("notation");
                 if (notation != null) {
                     mod = mod.addAnnotation(notation, getEnv());
                 }

                 module.extendedImport(mod);
                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("extending "+mod.getModuleName()+"\u005cn");
                     writer.flush();
                 }


             } catch (Exception e) {
                 String msg = e.getMessage();
                 msg +=" at line "+xt.beginLine+".";

                 {if (true) throw new ParseException(msg);}
             }
      }
    }
    jj_consume_token(DOT);
  }

  final public void UsedImport(Module module) throws ParseException {
  Module mod;
  Token token, xt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case US:
      xt = jj_consume_token(US);
      break;
    case USING:
      xt = jj_consume_token(USING);
      break;
    case INC:
      xt = jj_consume_token(INC);
      break;
    case INCLUDING:
      xt = jj_consume_token(INCLUDING);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_36(2147483647)) {
      token = jj_consume_token(IDENTIFIER);
      jj_consume_token(IS);
      mod = ModExpr(module);
               try {

                   if (dynmaicModule != null && mode == FILE_INPUT) {
                       writer.write("====================="+
                                    "=====================\u005cn");
                       writer.write("using "+token.image+" is "+
                                    mod.getModuleName()+"\u005cn");
                       writer.flush();
                   }


                   String notation = (String)mod.getProperty("notation");
                   if (notation != null) {
                       ModuleName nname = mod.modName.addAnnotation(notation);
                       mod = mod.changeModuleName(mod.modName, nname, nname);
                   }

                   ModuleName nname = new ModuleName(token.image);
                   nname.subexps.add(mod.modName);

                   mod = mod.changeModuleName(mod.modName, nname, nname);
                   //module.usedImport(mod);
                   module.protectedImport(mod);

                   saveModule(mod);



               } catch (Exception e) {
                   xt = getToken(0);
                   String msg = e.getMessage();
                   msg +=" at line "+xt.beginLine+".";
                   {if (true) throw new ParseException(msg);}
               }
    } else {
      label_34:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 144:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_34;
        }
        mod = ModExpr(module);
             try {

                 String notation = (String)mod.getProperty("notation");
                 if (notation != null) {
                     mod = mod.addAnnotation(notation, getEnv());
                 }

                 module.usedImport(mod);
                 if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("including "+mod.getModuleName()+"\u005cn");
                     writer.flush();
                 }

              } catch (Exception e) {
                  String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  {if (true) throw new ParseException(msg);}
              }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITH:
        jj_consume_token(WITH);
        label_35:
        while (true) {
          jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[106] = jj_gen;
            break label_35;
          }
        }
        break;
      default:
        jj_la1[107] = jj_gen;
        ;
      }
    }
    jj_consume_token(DOT);
  }

  final public void SortsDecl(Module module) throws ParseException {
  Token token;
  Sort sort = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SORT:
    case SORTS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SORT:
        jj_consume_token(SORT);
        break;
      case SORTS:
        jj_consume_token(SORTS);
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
          break;
        case INTEGER_LITERAL:
          token = jj_consume_token(INTEGER_LITERAL);
          break;
        default:
          jj_la1[109] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                  if (module.isBehavorial()) {
                      sort = new HiddenSort(token.image,
                                            module.getModuleName());
                  } else if (module.isInitial()) {
                      sort = new InitialSort(token.image,
                                            module.getModuleName());
                  } else {
                      sort = new Sort(token.image,
                                      module.getModuleName());
                  }

                  module.addSort(sort);

                  // make sort is a subsort of Universal
                  try {
                      module.addSubsort(BoolModule.univSort, sort);
                  } catch (Exception e) {}
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[110] = jj_gen;
          break label_36;
        }
      }
      jj_consume_token(DOT);
      break;
    case BSORT:
    case BSORTS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSORT:
        jj_consume_token(BSORT);
        break;
      case BSORTS:
        jj_consume_token(BSORTS);
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                if (!module.isBehavorial()) {
                     Token xt = getToken(0);
                     String msg = "\u005c"dsort\u005c" only can be used in bth,";
                     msg += " at line "+xt.beginLine+", column "+
                            xt.beginColumn+".";
                     {if (true) throw new ParseException(msg);}
                }
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[112] = jj_gen;
          break label_37;
        }
        token = jj_consume_token(IDENTIFIER);
                 sort = new Sort(token.image, module.getModuleName());
                 module.addSort(sort);
      }
      jj_consume_token(DOT);
      break;
    default:
      jj_la1[113] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SubsortDecl(Module module) throws ParseException {
     List small = new ArrayList();
     List big = new ArrayList();
     Sort sort;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBSORTS:
      jj_consume_token(SUBSORTS);
      break;
    case SUBSORT:
      jj_consume_token(SUBSORT);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
             Token token = getToken(0);
    label_38:
    while (true) {
      sort = SortReference(module);
               small.add(sort);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_38;
      }
    }
    label_39:
    while (true) {
      jj_consume_token(LESS);
      label_40:
      while (true) {
        sort = SortReference(module);
                big.add(sort);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[116] = jj_gen;
          break label_40;
        }
      }
         try {
             for (int i=0; i<small.size(); i++) {
                Sort s = (Sort)small.get(i);
                for (int j=0; j<big.size(); j++) {
                    Sort b = (Sort)big.get(j);
                    module.addSubsort(b,s);
                }
             }

             small = big;
             big = new ArrayList();

         } catch (SignatureException e) {
             String msg =" at line "+token.beginLine+".";
             {if (true) throw new ParseException(e.getMessage()+msg);}
         }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        ;
        break;
      default:
        jj_la1[117] = jj_gen;
        break label_39;
      }
    }
    jj_consume_token(DOT);
  }

  final public void VarImport(Module module) throws ParseException {
    String name = null;
    Token token;
    jj_consume_token(VARSOF);
            token = getToken(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case IDENTIFIER:
      name = ModId();
      break;
    default:
      jj_la1[118] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
          try {

             Module tmp = null;

             if (name != null) {

                ModuleName modName = new ModuleName(name);

                Enumeration enum_ = modPool.keys();
                while (enum_.hasMoreElements()) {
                    ModuleName key = (ModuleName)enum_.nextElement();

                    if (key.equals(modName)) {
                        tmp = (Module)modPool.get(key);
                        break;
                    }
                }

                if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("vars-of "+name+"\u005cn");
                     writer.flush();
                }

             } else {
                tmp = dynmaicModule != null ? dynmaicModule : lastModule ;

                if (dynmaicModule != null && mode == FILE_INPUT) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("vars-of\u005cn");
                     writer.flush();
                }
             }

             if (tmp == null) {
                String msg = "no module "+name+" is found";
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                {if (true) throw new ParseException(msg);}
             }

             Variable[] vars = tmp.getVariables();

             try {

                for (int i=0; i<vars.length; i++) {
                    module.addVariable(vars[i]);
                }

             } catch (SignatureException e) {
                String msg = e.getMessage();
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                {if (true) throw new ParseException(msg);}
             }

          } catch (IOException e) {
                String msg = e.getMessage();
                msg += " at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                {if (true) throw new ParseException(msg);}
          }
  }

  final public void VarDecl(Module module) throws ParseException {
    List varNames = new ArrayList();
    List tokens = new ArrayList();
    Token token;
    Sort sort;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      jj_consume_token(VAR);
      break;
    case VARS:
      jj_consume_token(VARS);
      break;
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
             varNames.add(token.image);
             tokens.add(token);
        break;
      case QUIT:
        token = jj_consume_token(QUIT);
             varNames.add(token.image);
             tokens.add(token);
        break;
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUIT:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[121] = jj_gen;
        break label_41;
      }
    }
    jj_consume_token(COLON);
    sort = SortReference(module);
    jj_consume_token(DOT);
              for (int i=0; i<varNames.size(); i++) {
                   String name = (String)varNames.get(i);
                   token = (Token)tokens.get(i);

                   try {
                        Variable var = new Variable(name, sort);
                        module.addVariable(var);
                   } catch (SignatureException e) {
                        String msg = e.getMessage();
                        msg +=" at line "+token.beginLine+
                              ", column "+token.beginColumn+".";
                        {if (true) throw new ParseException(msg);}
                   }
               }

               try {
                   if (dynmaicModule != null && mode == FILE_INPUT) {
                        writer.write("======================="+
                                     "===================\u005cn");
                        if (varNames.size() > 1) {
                             writer.write("vars ");
                             for (int i=0; i<varNames.size(); i++) {
                                 writer.write(varNames.get(i)+" ");
                             }
                             writer.write(": "+sort.getName()+"\u005cn");
                             writer.flush();
                         } else {
                             writer.write("var "+varNames.get(0)+" : "+
                                          sort.getName()+"\u005cn");
                             writer.flush();
                         }
                    }
               } catch (Exception e) {
                    String msg = e.getMessage();
                    msg += " at line "+token.beginLine+
                           ", column "+token.beginColumn+".";
                           {if (true) throw new ParseException(msg);}
               }
  }

  final public Operation[] OperationDecl(Module module) throws ParseException {
      String opName = "";
      Sort sort;
      Vector argSorts = new Vector();
      Sort resSort = null;
      Vector opVt = new Vector();
      Operation op = null;
      Vector ops = new Vector();

      boolean behaviorial = false;

      Token token, xt;
      int beginLine = 0;
      ModuleName modName = module.getModuleName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP:
      xt = jj_consume_token(OP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case EQ:
      case LESS:
      case ARROW:
      case ADD:
      case SUM:
      case STAR:
      case LB:
      case RB:
      case FROM:
      case APPLY:
      case START:
      case AT:
      case WITHIN:
      case PRINT:
      case PARENS:
      case OF:
      case QUIT:
      case IN:
      case SHOW:
      case MAKE:
      case LET:
      case STOP:
      case SELECT:
      case SET:
      case TRACE:
      case ON:
      case OFF:
      case FULL:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
      case 145:
        opName = OpName();
        break;
      case 144:
        jj_consume_token(144);
        opName = OpName();
        jj_consume_token(146);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(COLON);
      label_42:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[123] = jj_gen;
          break label_42;
        }
        sort = SortReference(module);
               argSorts.addElement(sort);
      }
      jj_consume_token(ARROW);
      resSort = SortReference(module);
               Sort[] args = new Sort[argSorts.size()];
               argSorts.copyInto(args);

               if (module.hasOperation(opName, args, resSort)) {
                   try {
                      writer.write("======================="+
                                   "===================\u005cn");
                      writer.write("Warning: operation "+opName.trim()+
                                   " is already defined at line "+
                                   xt.beginLine+"\u005cn");
                      writer.flush();

                      op = new Operation(opName, args, resSort, modName);
                      opVt.addElement(op);

                   } catch (IOException e) {
                      {if (true) throw new ParseException(e.getMessage());}
                   } catch (SignatureException e) {
                      String msg = e.getMessage();
                      msg +=" at line "+xt.beginLine+".";
                      {if (true) throw new ParseException(msg);}
                   }


               } else {

                  try {
                      op = new Operation(opName, args, resSort, modName);

                      /*
	              if (module.hasCompatibleOperation(op)) {

                          writer.write("======================="+
                                       "===================\n");
                          writer.write(format("Warning: operation "+
				       op.getCleanName().trim()+
				       " overwrites some opeartions"+
				       " from other modules at line "+
				       xt.beginLine, 0)+"\n");
                          writer.flush();

	              }
	              */

                      opVt.addElement(op);

                  } catch (SignatureException e) {
                      String msg = e.getMessage();
                      msg +=" at line "+xt.beginLine+".";
                      {if (true) throw new ParseException(msg);}
                  }
               }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LB:
        jj_consume_token(LB);
        label_43:
        while (true) {
          OpProperty(opVt, module);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSOC:
          case COMM:
          case IDEM:
          case PREC:
          case IDR:
          case ID:
          case NONCONG:
          case MEMO:
          case ASSOCIATIVE:
          case COMMUTATIVE:
          case PRECEDENCE:
          case IDEMPOTENT:
          case IDENTITY:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[124] = jj_gen;
            break label_43;
          }
        }
        jj_consume_token(RB);
        break;
      default:
        jj_la1[125] = jj_gen;
        ;
      }
      jj_consume_token(DOT);
             try {
                  for (int i=0; i<opVt.size(); i++) {
                     op = (Operation)opVt.elementAt(i);
                     module.add(op);
                  }

                  if (dynmaicModule != null && mode == FILE_INPUT) {
                      writer.write("======================="+
                                   "===================\u005cn");
                      writer.write(module.toString(op)+"\u005cn");
                      writer.flush();
                  }

              } catch (Exception e) {
                  String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  {if (true) throw new ParseException(msg);}
              }

              Operation[] result = new Operation[opVt.size()];
              for (int i=0; i<opVt.size(); i++) {
                  result[i] = (Operation)opVt.elementAt(i);
              }
              {if (true) return result;}
      break;
    case OPAS:
      xt = jj_consume_token(OPAS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJ:
      case TH:
      case BTH:
      case DTH:
      case ENDO:
      case ENDTH:
      case ENDB:
      case ENDD:
      case END:
      case PR:
      case PROTECTING:
      case EX:
      case EXTENDING:
      case US:
      case USING:
      case INC:
      case INCLUDING:
      case IS:
      case SORT:
      case SORTS:
      case BSORT:
      case BSORTS:
      case SUBSORT:
      case SUBSORTS:
      case VAR:
      case VARS:
      case EQ:
      case LESS:
      case ARROW:
      case ADD:
      case SUM:
      case STAR:
      case LB:
      case RB:
      case FROM:
      case APPLY:
      case START:
      case AT:
      case WITHIN:
      case PRINT:
      case PARENS:
      case OF:
      case QUIT:
      case IN:
      case SHOW:
      case MAKE:
      case LET:
      case STOP:
      case SELECT:
      case SET:
      case TRACE:
      case ON:
      case OFF:
      case FULL:
      case INCLUDE:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
      case 145:
        opName = OpName();
        break;
      case 144:
        jj_consume_token(144);
        opName = OpName();
        jj_consume_token(146);
                  opName = "( "+opName+" ) ";
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(COLON);
      label_44:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[127] = jj_gen;
          break label_44;
        }
          xt = getToken(0);
          beginLine = xt.beginLine;
        sort = SortReference(module);
                argSorts.addElement(sort);
      }
      jj_consume_token(ARROW);
      resSort = SortReference(module);
             try {
                  args = new Sort[argSorts.size()];
                  argSorts.copyInto(args);

                  if (module.hasOperation(opName, args, resSort)) {
                      try {
                          writer.write("======================="+
                                       "===================\u005cn");
                          writer.write("Warning: operation "+opName+
                                       " is already defined at line "+
                                       xt.beginLine+"\u005cn");
                          writer.flush();
                      } catch (IOException e) {
                          {if (true) throw new ParseException(e.getMessage());}
                      }
                  } else {
                      op = new Operation(opName,args, resSort, modName);
                      opVt.addElement(op);
                  }

             } catch (SignatureException e) {
                  xt = getToken(0);
                  String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  {if (true) throw new ParseException(msg);}
             }
      label_45:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case SYMBOL:
          jj_consume_token(SYMBOL);
          break;
        case OF:
          jj_consume_token(OF);
          break;
        case 144:
          jj_consume_token(144);
          break;
        case 146:
          jj_consume_token(146);
          break;
        case IN:
          jj_consume_token(IN);
          break;
        case 145:
          jj_consume_token(145);
          break;
        default:
          jj_la1[128] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OF:
        case IN:
        case IDENTIFIER:
        case SYMBOL:
        case 144:
        case 145:
        case 146:
          ;
          break;
        default:
          jj_la1[129] = jj_gen;
          break label_45;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LB:
        jj_consume_token(LB);
        label_46:
        while (true) {
          OpProperty(opVt, module);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSOC:
          case COMM:
          case IDEM:
          case PREC:
          case IDR:
          case ID:
          case NONCONG:
          case MEMO:
          case ASSOCIATIVE:
          case COMMUTATIVE:
          case PRECEDENCE:
          case IDEMPOTENT:
          case IDENTITY:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[130] = jj_gen;
            break label_46;
          }
        }
        jj_consume_token(RB);
        break;
      default:
        jj_la1[131] = jj_gen;
        ;
      }
      jj_consume_token(DOT);
         try {
            for (int i=0; i<opVt.size(); i++) {
                op = (Operation)opVt.elementAt(i);
                module.add(op);
            }
         } catch (SignatureException e) {
            String msg = e.getMessage();
            msg +=" at line "+beginLine+".";
            {if (true) throw new ParseException(msg);}
         }

         Operation[] result1 = new Operation[opVt.size()];
         for (int i=0; i<opVt.size(); i++) {
             result1[i] = (Operation)opVt.elementAt(i);
         }
         {if (true) return result1;}
      break;
    case OPS:
      jj_consume_token(OPS);
          xt = getToken(0);
          beginLine = xt.beginLine;
      label_47:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 144:
          jj_consume_token(144);
          opName = OpName();
                 ops.addElement(opName);
          jj_consume_token(146);
          break;
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opName = OpName();
                 StringTokenizer st = new StringTokenizer(opName, " ");
                 while (st.hasMoreTokens()) {
                     ops.addElement(st.nextToken());
                 }
          break;
        default:
          jj_la1[132] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 144:
        case 145:
          ;
          break;
        default:
          jj_la1[133] = jj_gen;
          break label_47;
        }
      }
      jj_consume_token(COLON);
      label_48:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[134] = jj_gen;
          break label_48;
        }
        sort = SortReference(module);
               argSorts.addElement(sort);
      }
      jj_consume_token(ARROW);
      resSort = SortReference(module);
              args = new Sort[argSorts.size()];
              argSorts.copyInto(args);

              try {
                   for (int i=0; i<ops.size(); i++) {
                       opName = (String)ops.elementAt(i);


                       if (module.hasOperation(opName, args, resSort)) {
                          try {
                             writer.write("======================="+
                                          "===================\u005cn");
                             writer.write("Warning: operation "+opName+
                                          " is already defined at line "+
                                          xt.beginLine+"\u005cn");
                             writer.flush();
                          } catch (IOException e) {
                             {if (true) throw new ParseException(e.getMessage());}
                          }
                      } else {

                         op = new Operation(opName, args, resSort, modName);
                         opVt.addElement(op);

                      }
                   }
              } catch (SignatureException e) {
                  String msg = e.getMessage();
                  msg +=" at line "+xt.beginLine+".";
                  {if (true) throw new ParseException(msg);}
              }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LB:
        jj_consume_token(LB);
        label_49:
        while (true) {
          OpProperty(opVt, module);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSOC:
          case COMM:
          case IDEM:
          case PREC:
          case IDR:
          case ID:
          case NONCONG:
          case MEMO:
          case ASSOCIATIVE:
          case COMMUTATIVE:
          case PRECEDENCE:
          case IDEMPOTENT:
          case IDENTITY:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[135] = jj_gen;
            break label_49;
          }
        }
        jj_consume_token(RB);
        break;
      default:
        jj_la1[136] = jj_gen;
        ;
      }
      jj_consume_token(DOT);
         try {

             for (int i=0; i<opVt.size(); i++) {
                 op = (Operation)opVt.elementAt(i);
                 module.add(op);
             }

             if (dynmaicModule != null && mode == FILE_INPUT) {
                 writer.write("==========================================\u005cn");
                 writer.write("ops ");
                 for (int i=0; i<opVt.size(); i++) {
                     op = (Operation)opVt.elementAt(i);
                     if (i != opVt.size()-1) {
                         writer.write(op.name+" ");
                     } else {
                         writer.write(module.toString(op).substring(3)+"\u005cn");
                     }
                 }
                 writer.flush();
             }

         } catch (Exception e) {
             String msg = e.getMessage();
             msg +=" at line "+beginLine+".";
             {if (true) throw new ParseException(msg);}
         }

         Operation[] result2 = new Operation[opVt.size()];
         for (int i=0; i<opVt.size(); i++) {
             result2[i] = (Operation)opVt.elementAt(i);
         }
         {if (true) return result2;}
      break;
    default:
      jj_la1[137] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpName() throws ParseException {
   String result = "";
   String tmp;
   Token token;
    label_50:
    while (true) {
      Token tk = getToken(0);
      int endLine = tk.endLine;
      int endColumn = tk.endColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
            result = result.trim();
          }
          result += token.image +" ";
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
            result = result.trim();
          }
          result += token.image+" ";
        break;
      case OBJ:
        token = jj_consume_token(OBJ);
          result += token.image+" ";
        break;
      case TH:
        token = jj_consume_token(TH);
          result += token.image+" ";
        break;
      case BTH:
        token = jj_consume_token(BTH);
          result += token.image+" ";
        break;
      case DTH:
        token = jj_consume_token(DTH);
          result += token.image+" ";
        break;
      case ENDO:
        token = jj_consume_token(ENDO);
          result += token.image+" ";
        break;
      case ENDTH:
        token = jj_consume_token(ENDTH);
          result += token.image+" ";
        break;
      case ENDB:
        token = jj_consume_token(ENDB);
          result += token.image+" ";
        break;
      case ENDD:
        token = jj_consume_token(ENDD);
          result += token.image+" ";
        break;
      case END:
        token = jj_consume_token(END);
          result += token.image+" ";
        break;
      case PR:
        token = jj_consume_token(PR);
          result += token.image+" ";
        break;
      case PROTECTING:
        token = jj_consume_token(PROTECTING);
          result += token.image+" ";
        break;
      case EX:
        token = jj_consume_token(EX);
          result += token.image+" ";
        break;
      case EXTENDING:
        token = jj_consume_token(EXTENDING);
          result += token.image+" ";
        break;
      case US:
        token = jj_consume_token(US);
          result += token.image+" ";
        break;
      case USING:
        token = jj_consume_token(USING);
          result += token.image+" ";
        break;
      case BSORT:
        token = jj_consume_token(BSORT);
          result += token.image+" ";
        break;
      case BSORTS:
        token = jj_consume_token(BSORTS);
          result += token.image+" ";
        break;
      case SUBSORT:
        token = jj_consume_token(SUBSORT);
          result += token.image+" ";
        break;
      case SUBSORTS:
        token = jj_consume_token(SUBSORTS);
          result += token.image+" ";
        break;
      case LESS:
        token = jj_consume_token(LESS);
          result += token.image+" ";
        break;
      case ARROW:
        token = jj_consume_token(ARROW);
          result += token.image+" ";
        break;
      case VAR:
        token = jj_consume_token(VAR);
          result += token.image+" ";
        break;
      case VARS:
        token = jj_consume_token(VARS);
          result += token.image+" ";
        break;
      case SORT:
        token = jj_consume_token(SORT);
          result += token.image+" ";
        break;
      case SORTS:
        token = jj_consume_token(SORTS);
          result += token.image+" ";
        break;
      case MAKE:
        token = jj_consume_token(MAKE);
          result += token.image+" ";
        break;
      case IS:
        jj_consume_token(IS);
          result += "is ";
        break;
      case LET:
        jj_consume_token(LET);
          result += "let ";
        break;
      case SUM:
        jj_consume_token(SUM);
          result += "|| ";
        break;
      case PARENS:
        jj_consume_token(PARENS);
          result += "parens ";
        break;
      case INCLUDE:
        jj_consume_token(INCLUDE);
          result += "include ";
        break;
      case REDUCTION:
        jj_consume_token(REDUCTION);
          result += "result ";
        break;
      case INC:
        jj_consume_token(INC);
          result += "inc ";
        break;
      case INCLUDING:
        jj_consume_token(INCLUDING);
          result += "including ";
        break;
      case REDUCE:
        jj_consume_token(REDUCE);
          result += "reduce ";
        break;
      case TIME:
        jj_consume_token(TIME);
          result += "time ";
        break;
      case JBO:
        jj_consume_token(JBO);
          result += "jbo ";
        break;
      case ASSOCIATIVE:
        jj_consume_token(ASSOCIATIVE);
          result += "associative ";
        break;
      case COMMUTATIVE:
        jj_consume_token(COMMUTATIVE);
          result += "commutative ";
        break;
      case IDEMPOTENT:
        jj_consume_token(IDEMPOTENT);
          result += "idempotent ";
        break;
      case HT:
        jj_consume_token(HT);
          result += "ht ";
        break;
      case WEIV:
        jj_consume_token(WEIV);
          result += "weiv ";
        break;
      case ENDVIEW:
        jj_consume_token(ENDVIEW);
          result += "endview ";
        break;
      case GATHERING:
        jj_consume_token(GATHERING);
          result += "gathering ";
        break;
      case PRECEDENCE:
        jj_consume_token(PRECEDENCE);
          result += "precedence ";
        break;
      case THEORY:
        jj_consume_token(THEORY);
          result += "theory ";
        break;
      case SH:
        jj_consume_token(SH);
          result += "sh ";
        break;
      case LONGQUIT:
        jj_consume_token(LONGQUIT);
          result += "quit ";
        break;
      case OBJECT:
        jj_consume_token(OBJECT);
          result += "quit ";
        break;
      case DEFINE:
        jj_consume_token(DEFINE);
          result += "define ";
        break;
      case IDENTITY:
        jj_consume_token(IDENTITY);
          result += "identity ";
        break;
      case INPUT:
        jj_consume_token(INPUT);
          result += "input ";
        break;
      case 145:
        jj_consume_token(145);
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
            result = result.trim();
          }
          result += ", ";
        break;
      case ADD:
        jj_consume_token(ADD);
          result += "+ ";
        break;
      case STAR:
        jj_consume_token(STAR);
          result += "* ";
        break;
      case EQ:
        jj_consume_token(EQ);
          result += "eq ";
        break;
      case QUIT:
        jj_consume_token(QUIT);
          result += "q ";
        break;
      case STOP:
        jj_consume_token(STOP);
          result += "eof ";
        break;
      case SELECT:
        jj_consume_token(SELECT);
          result += "select ";
        break;
      case SHOW:
        jj_consume_token(SHOW);
          result += "show ";
        break;
      case SET:
        jj_consume_token(SET);
          result += "set ";
        break;
      case TRACE:
        jj_consume_token(TRACE);
          result += "trace ";
        break;
      case ON:
        jj_consume_token(ON);
          result += "on ";
        break;
      case OFF:
        jj_consume_token(OFF);
          result += "off ";
        break;
      case FULL:
        jj_consume_token(FULL);
          result += "full ";
        break;
      case FROM:
        jj_consume_token(FROM);
          result += "from ";
        break;
      case OF:
        jj_consume_token(OF);
          result += "of ";
        break;
      case IN:
        jj_consume_token(IN);
          result += "in ";
        break;
      case APPLY:
        jj_consume_token(APPLY);
          result += "apply";
        break;
      case WITHIN:
        jj_consume_token(WITHIN);
          result += "within";
        break;
      case AT:
        jj_consume_token(AT);
          result += "at";
        break;
      case PRINT:
        jj_consume_token(PRINT);
          result += "print";
        break;
      case START:
        jj_consume_token(START);
          result += "start";
        break;
      case LB:
        jj_consume_token(LB);
               char c = ' ';
               String str = result.trim();
               boolean alphanum = false;
               if (str.length() > 0) {
                   c = str.charAt(str.length()-1);
                   alphanum = (c >= 'a' && c <= 'z') ||
                              (c >= 'A' && c <= 'Z');
               }

               tk = getToken(0);
               if (!alphanum &&
                   tk.endLine == endLine &&
                   tk.beginColumn == endColumn+1) {
                   result = result.trim()+"[ ";
               } else {
                   result = result+"[ ";
               }
        break;
      case RB:
        jj_consume_token(RB);
              tk = getToken(0);
              if (tk.endLine == endLine && tk.beginColumn == endColumn+1) {
                  result = result.trim()+"] ";
              } else {
                  result = result+"] ";
              }
        break;
      default:
        jj_la1[138] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_37(30)) {
        jj_consume_token(144);
        tmp = OpName();
               result += "( "+tmp.trim()+" ) ";
        jj_consume_token(146);
      } else {
        ;
      }
      if (jj_2_38(20)) {
        ;
      } else {
        break label_50;
      }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String SimpleOpName() throws ParseException {
   String result = "";
   String tmp;
   Token token;
    label_51:
    while (true) {
      Token tk = getToken(0);
      int endLine = tk.endLine;
      int endColumn = tk.endColumn;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
            result = result.trim();
          }
          result += token.image +" ";
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
          result += token.image+" ";
        break;
      case OBJ:
        token = jj_consume_token(OBJ);
          result += token.image+" ";
        break;
      case TH:
        token = jj_consume_token(TH);
          result += token.image+" ";
        break;
      case BTH:
        token = jj_consume_token(BTH);
          result += token.image+" ";
        break;
      case DTH:
        token = jj_consume_token(DTH);
          result += token.image+" ";
        break;
      case ENDO:
        token = jj_consume_token(ENDO);
          result += token.image+" ";
        break;
      case ENDTH:
        token = jj_consume_token(ENDTH);
          result += token.image+" ";
        break;
      case ENDB:
        token = jj_consume_token(ENDB);
          result += token.image+" ";
        break;
      case ENDD:
        token = jj_consume_token(ENDD);
          result += token.image+" ";
        break;
      case END:
        token = jj_consume_token(END);
          result += token.image+" ";
        break;
      case PR:
        token = jj_consume_token(PR);
          result += token.image+" ";
        break;
      case PROTECTING:
        token = jj_consume_token(PROTECTING);
          result += token.image+" ";
        break;
      case EX:
        token = jj_consume_token(EX);
          result += token.image+" ";
        break;
      case EXTENDING:
        token = jj_consume_token(EXTENDING);
          result += token.image+" ";
        break;
      case US:
        token = jj_consume_token(US);
          result += token.image+" ";
        break;
      case USING:
        token = jj_consume_token(USING);
          result += token.image+" ";
        break;
      case BSORT:
        token = jj_consume_token(BSORT);
          result += token.image+" ";
        break;
      case BSORTS:
        token = jj_consume_token(BSORTS);
          result += token.image+" ";
        break;
      case SUBSORT:
        token = jj_consume_token(SUBSORT);
          result += token.image+" ";
        break;
      case SUBSORTS:
        token = jj_consume_token(SUBSORTS);
          result += token.image+" ";
        break;
      case LESS:
        token = jj_consume_token(LESS);
          result += token.image+" ";
        break;
      case ARROW:
        token = jj_consume_token(ARROW);
          result += token.image+" ";
        break;
      case VAR:
        token = jj_consume_token(VAR);
          result += token.image+" ";
        break;
      case VARS:
        token = jj_consume_token(VARS);
          result += token.image+" ";
        break;
      case IS:
        jj_consume_token(IS);
          result += "is ";
        break;
      case LET:
        jj_consume_token(LET);
          result += "let ";
        break;
      case SUM:
        jj_consume_token(SUM);
          result += "|| ";
        break;
      case JBO:
        jj_consume_token(JBO);
          result += "jbo ";
        break;
      case HT:
        jj_consume_token(HT);
          result += "ht ";
        break;
      case WEIV:
        jj_consume_token(WEIV);
          result += "weiv ";
        break;
      case ENDVIEW:
        jj_consume_token(ENDVIEW);
          result += "endview ";
        break;
      case THEORY:
        jj_consume_token(THEORY);
          result += "theory ";
        break;
      case SH:
        jj_consume_token(SH);
          result += "sh ";
        break;
      case LONGQUIT:
        jj_consume_token(LONGQUIT);
          result += "quit ";
        break;
      case OBJECT:
        jj_consume_token(OBJECT);
          result += "object ";
        break;
      case DEFINE:
        jj_consume_token(DEFINE);
          result += "define ";
        break;
      case INPUT:
        jj_consume_token(INPUT);
          result += "input ";
        break;
      case 145:
        jj_consume_token(145);
          tk = getToken(0);
          if (endLine == tk.beginLine && endColumn+1 == tk.beginColumn) {
            result = result.trim();
          }
          result += ", ";
        break;
      case ADD:
        jj_consume_token(ADD);
          result += "+ ";
        break;
      case STAR:
        jj_consume_token(STAR);
          result += "* ";
        break;
      case EQ:
        jj_consume_token(EQ);
          result += "eq ";
        break;
      case QUIT:
        jj_consume_token(QUIT);
          result += "q ";
        break;
      case STOP:
        jj_consume_token(STOP);
          result += "eof ";
        break;
      case SELECT:
        jj_consume_token(SELECT);
          result += "select ";
        break;
      case SHOW:
        jj_consume_token(SHOW);
          result += "show ";
        break;
      case SET:
        jj_consume_token(SET);
          result += "set ";
        break;
      case TRACE:
        jj_consume_token(TRACE);
          result += "trace ";
        break;
      case ON:
        jj_consume_token(ON);
          result += "on ";
        break;
      case OFF:
        jj_consume_token(OFF);
          result += "off ";
        break;
      case FULL:
        jj_consume_token(FULL);
          result += "full ";
        break;
      case FROM:
        jj_consume_token(FROM);
          result += "from ";
        break;
      case OF:
        jj_consume_token(OF);
          result += "of ";
        break;
      case IN:
        jj_consume_token(IN);
          result += "in ";
        break;
      case APPLY:
        jj_consume_token(APPLY);
          result += "apply";
        break;
      case WITHIN:
        jj_consume_token(WITHIN);
          result += "within";
        break;
      case AT:
        jj_consume_token(AT);
          result += "at";
        break;
      case PRINT:
        jj_consume_token(PRINT);
          result += "print";
        break;
      case START:
        jj_consume_token(START);
          result += "start";
        break;
      default:
        jj_la1[139] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 144:
        jj_consume_token(144);
        tmp = OpName();
               result += "( "+tmp.trim()+" ) ";
        jj_consume_token(146);
        break;
      default:
        jj_la1[140] = jj_gen;
        ;
      }
      if (!getToken(1).image.equals("strat") &&
                     !getToken(1).image.equals("strategy") &&
                     !getToken(1).image.equals("gather") &&
                     !getToken(1).image.equals("gathering") &&
                     !getToken(1).image.equals("]") &&
                     !getToken(1).image.equals("prec") &&
                     !getToken(1).image.equals("precedence") &&
                     !getToken(1).image.equals("assoc") &&
                     !getToken(1).image.equals("associative") &&
                     !getToken(1).image.equals("comm") &&
                     !getToken(1).image.equals("commutative") &&
                     !getToken(1).image.equals("idem") &&
                     !getToken(1).image.equals("idempotent") &&
                     !getToken(1).image.equals("ncong") &&
                     !getToken(1).image.equals(")")) {
        ;
      } else {
        break label_51;
      }
    }
         {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void OpProperty(Vector ops, Module module) throws ParseException {
  Token token, xt;
  String opname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NONCONG:
      jj_consume_token(NONCONG);
          for (int i=0; i<ops.size(); i++) {
              Operation op = (Operation)ops.elementAt(i);
              op.setBehavorial(false);
          }
      break;
    case ASSOC:
    case ASSOCIATIVE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSOC:
        jj_consume_token(ASSOC);
        break;
      case ASSOCIATIVE:
        jj_consume_token(ASSOCIATIVE);
        break;
      default:
        jj_la1[141] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
           try {
              for (int i=0; i<ops.size(); i++) {
                 Operation op = (Operation)ops.elementAt(i);
                 op.setAssociativity(module);
              }
           } catch (SignatureException e) {
               xt = getToken(0);
               String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+
                     ", column "+xt.beginColumn+".";
               {if (true) throw new ParseException(msg);}
           }
      break;
    case COMM:
    case COMMUTATIVE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMM:
        jj_consume_token(COMM);
        break;
      case COMMUTATIVE:
        jj_consume_token(COMMUTATIVE);
        break;
      default:
        jj_la1[142] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
           try {
              for (int i=0; i<ops.size(); i++) {
                Operation op = (Operation)ops.elementAt(i);
                op.setCommutativity(module);
              }
           } catch (SignatureException e) {
               xt = getToken(0);
               String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+", column "+
                     xt.beginColumn+".";
               {if (true) throw new ParseException(msg);}
           }
      break;
    case IDEM:
    case IDEMPOTENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDEM:
        jj_consume_token(IDEM);
        break;
      case IDEMPOTENT:
        jj_consume_token(IDEMPOTENT);
        break;
      default:
        jj_la1[143] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
           try {
               for (int i=0; i<ops.size(); i++) {
                   Operation op = (Operation)ops.elementAt(i);
                   op.setIdempotence();
               }
           } catch (SignatureException e) {
               xt = getToken(0);
               String msg = e.getMessage();
               msg +=" at line "+xt.beginLine+", column "+
                     xt.beginColumn+".";
               {if (true) throw new ParseException(msg);}
           }
      break;
    case IDR:
    case ID:
    case IDENTITY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDR:
        jj_consume_token(IDR);
        break;
      case ID:
        jj_consume_token(ID);
        break;
      case IDENTITY:
        jj_consume_token(IDENTITY);
        break;
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_39(1)) {
        opname = SimpleOpName();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 144:
          jj_consume_token(144);
          opname = SimpleOpName();
          jj_consume_token(146);
          break;
        default:
          jj_la1[145] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
           Operation[] id = module.getConstants(opname.trim());
           for (int i=0; i<ops.size(); i++) {
               Operation op = (Operation)ops.elementAt(i);
               boolean found = false;
               for (int j=0; j<id.length && !found; j++) {
                   try {
                       op.setIdentity(id[j], module);
                       found = true;
                   } catch (SignatureException e) {}
               }

               if (!found) {
                   xt = getToken(0);
                   String msg = "Can't set identity for the operation "+
                                op.getName();
                   msg += " at line "+xt.beginLine+
                          ", column "+xt.beginColumn+".";
                   {if (true) throw new ParseException(msg);}
               }
           }
      break;
    case PREC:
    case PRECEDENCE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PREC:
        jj_consume_token(PREC);
        break;
      case PRECEDENCE:
        jj_consume_token(PRECEDENCE);
        break;
      default:
        jj_la1[146] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      token = jj_consume_token(INTEGER_LITERAL);
            int prec = Integer.parseInt(token.image);
            for (int i=0; i<ops.size(); i++) {
                 Operation op = (Operation)ops.elementAt(i);
                 op.setPriority(prec);
            }
      break;
    case MEMO:
      jj_consume_token(MEMO);
      break;
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
             int kind = 0;

             if (token.image.equals("gather") ||
                 token.image.equals("gathering")) {
                 kind = 1;
             } else if (token.image.equals("strat") ||
                        token.image.equals("strategy") ) {
                 kind = 2;
             } else {
                 String msg = "expect gather or gathering "+
                              "or strat or strategy";
                 msg +=" at line "+token.beginLine+
                       ", column "+token.beginColumn+".";
                 {if (true) throw new ParseException(msg);}
              }
      jj_consume_token(144);
               List list = new ArrayList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
                      if (kind == 2) {

                          try {
                            int aInt = Integer.parseInt(token.image);
                            list.add(token.image);
                          } catch (Exception e) {

                            String msg = "expect a natural number ";
                            msg +=" at line "+token.beginLine+
                                ", column "+token.beginColumn+".";
                            {if (true) throw new ParseException(msg);}
                          }
                      } else {

                         if (!token.image.equals("E") &&
                             !token.image.equals("e") &&
                             !token.image.equals("&")) {

                             String msg = "expect E e &";
                             msg +=" at line "+token.beginLine+
                                   ", column "+token.beginColumn+".";
                             {if (true) throw new ParseException(msg);}
                         }

                         list.add(token.image);

                      }
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
                         if (kind == 1) {
                            String msg = "expect E e &";
                            msg +=" at line "+token.beginLine+
                                  ", column "+token.beginColumn+".";
                            {if (true) throw new ParseException(msg);}
                         }

                         list.add(token.image);
        break;
      default:
        jj_la1[147] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_52:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[148] = jj_gen;
          break label_52;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
                      if (kind == 2) {


                          try {
                            int aInt = Integer.parseInt(token.image);
                            list.add(token.image);
                          } catch (Exception e) {

                            String msg = "expect a natural number ";
                            msg +=" at line "+token.beginLine+
                                  ", column "+token.beginColumn+".";
                            {if (true) throw new ParseException(msg);}
                          }
                      } else {

                         if (!token.image.equals("E") &&
                             !token.image.equals("e") &&
                             !token.image.equals("&")) {

                             String msg = "expect E e &";
                             msg +=" at line "+token.beginLine+
                                   ", column "+token.beginColumn+".";
                             {if (true) throw new ParseException(msg);}
                         }

                         list.add(token.image);

                      }
          break;
        case INTEGER_LITERAL:
          token = jj_consume_token(INTEGER_LITERAL);
                         if (kind == 1) {
                            String msg = "expect E e &";
                            msg +=" at line "+token.beginLine+
                                  ", column "+token.beginColumn+".";
                            {if (true) throw new ParseException(msg);}
                         }

                         if (list.contains(token.image)) {
                            String msg = token.image+" is defined in the "+
                                         "strategy";
                            msg +=" at line "+token.beginLine+
                                  ", column "+token.beginColumn+".";
                            {if (true) throw new ParseException(msg);}
                         }

                         list.add(token.image);
          break;
        default:
          jj_la1[149] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                    if (kind == 1) {

                        String[] gather = new String[list.size()];
                        for (int i=0; i<gather.length; i++) {
                            gather[i] = (String)list.get(i);
                        }

                        for (int i=0; i<ops.size(); i++) {
                             Operation op = (Operation)ops.elementAt(i);
                             try {
                                 op.setGather(gather);
                             } catch (SignatureException e) {
                                 String msg = e.getMessage();
                                 msg +=" at line "+token.beginLine+
                                       ", column "+token.beginColumn+".";
                                 {if (true) throw new ParseException(msg);}
                             }
                        }

                    } else {

                        int[] strategy = new int[list.size()];
                        for (int i=0; i<strategy.length; i++) {
                           strategy[i] = Integer.parseInt((String)list.get(i));
                        }

                        for (int i=0; i<ops.size(); i++) {
                             Operation op = (Operation)ops.elementAt(i);
                             op.setStrategy(strategy);
                        }

                    }
      jj_consume_token(146);
      break;
    default:
      jj_la1[150] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void LetDecl(Module module) throws ParseException {
   Token t1, t2;
   String st;
    jj_consume_token(LET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t1 = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      t1 = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[151] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t2 = jj_consume_token(IDENTIFIER);
          if (!t2.image.equals("=")) {
              String msg = "Expect \u005c"=\u005c"  at line "+t2.beginLine+
                           ", column "+t2.beginColumn+".";
              {if (true) throw new ParseException(msg);}
          }
    st = Term(module);
       try {

           FastTermParser.debug = true;

           Term term = Term.parse(module, st);
           Operation op = new Operation( t1.image,
                                         new Sort[0],
                                         term.getSort(),
                                         module.getModuleName());
           module.addOperation(op);
           module.addEquation(new Equation(new Term(module, op, new Term[0]),
                              term));

           if (dynmaicModule != null && mode == FILE_INPUT) {
               writer.write("======================="+
                            "===================\u005cn");
               writer.write("let "+t1.image+" = "+st+"\u005cn");
               writer.flush();
           }

       } catch (Exception e) {
           String msg = e.getMessage();
           if (e instanceof TermException) {
              msg += "\u005cn";
           }
           msg +="at line "+t2.beginLine+".";
           {if (true) throw new ParseException(msg);}
       }
    jj_consume_token(DOT);
  }

  final public void MembershipDecl(Module module) throws ParseException {
   String string = null;
   Token token;
    jj_consume_token(MB);
           token = getToken(0);
    string = Term(module);
           String termStr=null, sortName=null, cond=null;

           int l = -1;
           int r = -1;

           int count = 0;
           String tmp = string;
           while (!tmp.equals("")) {

               if (tmp.startsWith("(")) {
                   count++;
                   tmp = tmp.substring(1);
               } else if (tmp.startsWith(")")) {
                   count--;
                   tmp = tmp.substring(1);
               } else if (tmp.startsWith(" : ")) {

                   if (count == 0) {
                       l = string.length()-tmp.length();
                       termStr = string.substring(0, l);
                       tmp = tmp.substring(3);
                   } else {
                       tmp = tmp.substring(3);
                   }

               } else if (tmp.startsWith(" if ")) {

                   int k = tmp.indexOf(" then ");
                   if (count == 0 && k == -1) {

                        r = string.length()-tmp.length();
                        sortName = string.substring(l+3,r);
                        cond = tmp.substring(4);
                        tmp = "";

                   } else {
                        tmp = tmp.substring(4);
                   }

                } else {
                   tmp = tmp.substring(1);
                }
            }

            if (cond == null) {
                sortName = string.substring(l+2).trim();
            }


            Term term = null, cterm = null;
            try {
                term = Term.parse(module, termStr);

                if (cond != null) {
                   cterm = Term.parse(module, cond);
                }

            } catch (TermException e) {

                String eMsg = e.getMessage();
                if (eMsg.startsWith("multiple parsing results")) {

                    int index = eMsg.indexOf("\u005cn");
                    eMsg = eMsg.substring(index);

                    String msg = "format:There are "+e.getCount()+" parses"+
                                 " for the term at line "+
                                 token.beginLine+":\u005cn";
                    msg += "   mb "+string;
                    msg += "\u005cnThe first 2 parse trees are:";
                    msg += eMsg;
                    {if (true) throw new ParseException(msg);}

                } else {

                    String msg = "format:no parse "+
                            "for the term at line "+token.beginLine+":\u005cn";
                    msg += "   mb "+string;
                    {if (true) throw new ParseException(msg);}
                }

            }

            Sort[] sorts = module.getSortsByName(sortName);
            if (sorts.length == 0) {

                 String msg = "No sort with name "+token.image+
                              " was found in the module "+
                              module.getModuleName()+" "+
                              "at line "+token.beginLine+".";
                 {if (true) throw new ParseException(msg);}

            } else if (sorts.length == 1) {

            } else {
                  String msg = sorts.length+" sorts with name "+
                               token.image+" was found in the module "+
                               module.getModuleName()+" at line "+
                               token.beginLine+".";
                  {if (true) throw new ParseException(msg);}
            }

            // check var(cterm) \subset var(term)

            boolean wrong = false;
            if (cond != null) {
               Variable[] cvars = cterm.getVariables();

               for (int i=0; i<cvars.length; i++) {
                   if (!term.contains(cvars[i])) {
                      System.out.println("Warning at line "+
                                      token.beginLine+": \u005cn"+
                                      "The condition has variables "+
                                      "not in the term. \u005cn"+
                                      "The membership definition"+
                                      " will be ignored for rewriting.");
                      wrong = true;
                   }
                }
            }

            // check subSort < superSort

            Sort superSort = term.getSort();
            Sort subSort = sorts[0];

            if (!wrong && !module.less(subSort, superSort) &&
                 !subSort.equals(superSort)) {
                  String msg = subSort.getName()+" is not a subsort of "+
                               superSort.getName()+" at line "+
                               token.beginLine+".";
                  {if (true) throw new ParseException(msg);}
            }


            Term left = null, right = null;
            try {

                if (!wrong && term.var == null) {
                   Operation sortOp = new Operation(sortName,
                                                 new Sort[]{},
                                                 BoolModule.univSort,
                                                 BOBJModule.getModuleName());
                   Term term2 = new Term(sortOp);
                   Operation op = BOBJModule.getSetsortOperation();
                   right = new Term(module,
                                    op,
                                    new Term[]{term2, term});

                   Equation eq = (cond == null) ?
                                  new Equation(term, right) :
                                  new Equation(cterm, term, right);
                   module.addEquation(eq);

                } else if (!wrong) {

                   Sort[] args = new Sort[] { superSort };
                   Sort res = subSort;
                   Operation retOp = new Operation("r:"+superSort.getName()+
                                                   ">"+subSort.getName()+
                                                   "(_)",
                                                   args,
                                                   res,
                                                   BOBJModule.getModuleName());
                   retOp.info = "system-retract";

                   left = new Term(module,
                                   retOp,
                                   new Term[] {term});

                   Operation sortOp = new Operation(sortName,
                                                    new Sort[]{},
                                                    BoolModule.univSort,
                                                   BOBJModule.getModuleName());
                   Term term2 = new Term(sortOp);
                   Operation op = BOBJModule.getSetsortOperation();
                   right = new Term(module,
                                    op,
                                    new Term[]{term2, term});

                   Equation eq = (cond == null) ?
                                 new Equation(left, right) :
                                 new Equation(cterm, left, right);
                   module.addEquation(eq);

                }

            } catch (Exception e){

            }
    jj_consume_token(DOT);
  }

  final public Equation EquationDecl(Module module) throws ParseException {
    String eq, name=null;
    Token xt;
    boolean conditional = false;
    Equation equat = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LB:
      jj_consume_token(LB);
      xt = jj_consume_token(IDENTIFIER);
               name = xt.image;
      jj_consume_token(RB);
      break;
    default:
      jj_la1[152] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
      break;
    case CQ:
      jj_consume_token(CQ);
             conditional = true;
      break;
    case CEQ:
      jj_consume_token(CEQ);
             conditional = true;
      break;
    default:
      jj_la1[153] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
           xt = getToken(0);
    eq = Term(module);
        String left = "";
        String right = "";
        String cond = "";

        int l = -1;
        int r = -1;

        int count = 0;
        String tmp = eq;
        while (!tmp.equals("")) {

          if (tmp.startsWith("(")) {

             count++;
             tmp = tmp.substring(1);

          } else if (tmp.startsWith(")")) {

             count--;
             tmp = tmp.substring(1);

          } else if (tmp.startsWith(" = ")) {

             if (count == 0) {
                l = eq.length()-tmp.length();
                left = eq.substring(0, l);
                tmp = tmp.substring(3);
             } else {
                tmp = tmp.substring(3);
             }

          } else if (tmp.startsWith(" if ")) {

             int k = tmp.indexOf(" then ");
             if (count == 0 && k == -1) {

                r = eq.length()-tmp.length();
                right = eq.substring(l+3,r);
                cond = tmp.substring(4);
                tmp = "";

             } else {
                tmp = tmp.substring(4);
             }

          } else {

             tmp = tmp.substring(1);
          }
        }

        if (right.equals("")) {
            right = eq.substring(l+3);
        }

        /*
        System.out.println("----------------------------");
	System.out.println("eq: "+eq);
        System.out.println("left: "+left);
        System.out.println("right: "+right);
        System.out.println("cond: "+cond);
        */

        if (left.equals("") || right.equals("")) {
            String msg = "format:No parse for the equation ";
            msg +="at line "+xt.beginLine+":\u005cn";

            if (conditional) {
                msg += "   cq "+eq;
            } else {
                msg += "   eq "+eq;
            }
            {if (true) throw new ParseException(msg);}
        }

        Term lterm, rterm, cterm=null;

        try {
           lterm = Term.parse(module, left);
        } catch (TermException e) {

            String eMsg = e.getMessage();
            if (eMsg.startsWith("multiple parsing results")) {
               int index = eMsg.indexOf("\u005cn");
               eMsg = eMsg.substring(index);

               String msg = "format:There are "+e.getCount()+" parses"+
                            " for LHS of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }
               msg += "\u005cnThe first 2 parse trees are:";
               msg += eMsg;
               {if (true) throw new ParseException(msg);}
            } else {
               String msg = "format:no parse "+
                            "for LHS of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }

               {if (true) throw new ParseException(msg);}
            }
        }

        try {
           rterm = Term.parse(module, right, lterm.getSort());
        } catch (TermException e) {

            String eMsg = e.getMessage();
            if (eMsg.startsWith("multiple parsing results")) {
               int index = eMsg.indexOf("\u005cn");
               eMsg = eMsg.substring(index);

               String msg = "format:There are "+e.getCount()+" parses"+
                            " for RHS of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }
               msg += "\u005cnThe first 2 parse trees are:";
               msg += eMsg;
               {if (true) throw new ParseException(msg);}

            } else {
               String msg = "format:no parse "+
                            "for RHS of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }

               {if (true) throw new ParseException(msg);}
            }
        }

        try {
           cterm = null;
           if (!cond.equals("")) {
              cterm = Term.parse(module, cond);
           }
        } catch (TermException e) {

            String eMsg = e.getMessage();
            if (eMsg.startsWith("multiple parsing results")) {
               int index = eMsg.indexOf("\u005cn");
               eMsg = eMsg.substring(index);

               String msg = "format:There are "+e.getCount()+" parses"+
                            " for the condition of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }
               msg += "\u005cnThe first 2 parse trees are:";
               msg += eMsg;
               {if (true) throw new ParseException(msg);}

            } else {
               String msg = "format:no parse "+
                            "for the condition of equation "+
                            "at line "+xt.beginLine+":\u005cn";
               if (conditional) {
                  msg += "   cq "+eq;
               } else {
                  msg += "   eq "+eq;
               }

               {if (true) throw new ParseException(msg);}
            }
        }

        try {
           Equation equ;
           if (cterm != null) {
              equ = new Equation(cterm, lterm, rterm);
           } else {
              equ = new Equation(lterm, rterm);
           }
           equ.info = module.modName.toString();

           if (name != null) {
               equ.setName(name);
           }

           equat = equ;

           boolean wrong = false;
           if (lterm.getVariable() != null ) {

              if (cterm != null) {

                  // check variables in rterm
                  Variable[] rvars = rterm.getVariables();
                  for (int i=0; i<rvars.length; i++) {
                      if (!lterm.contains(rvars[i])) {
                          System.out.println("====================="+
                                             "=====================");
                          System.out.println(
                                "Warning at line "+xt.beginLine+": \u005cn"+
                                "The RHS has variables "+
                                "not in the LHS. \u005cn"+
                                "The equation will be ignored for rewriting.");
                          wrong = true;
                          module.addGeneralEquation(equ);
                          break;
                       }
                  }

                  // check variable in cterm
                  if (!wrong && cterm != null) {

                      Variable[] vars = cterm.getVariables();
                      for (int i=0; i<vars.length; i++) {
                          if (!lterm.contains(vars[i])) {
                             System.out.println("====================="+
                                                "=====================");
                             System.out.println(
                                "Warning at line "+xt.beginLine+": \u005cn"+
                                "The condition has variables "+
                                "not in the LHS. \u005cn"+
                                "The equation will be ignored for rewriting.");
                            wrong = true;
                            module.addGeneralEquation(equ);
                            break;
                       }
                    }
                 }
                 if (!wrong)
                     module.addEquation(equat);

              } else {

                  if (module instanceof CaseModule) {

                  } else {

                      System.out.println("====================="+
                                         "=====================");
                      System.out.println("Warning at line "+xt.beginLine+":\u005cn"+
                                         "The left term is a variable. "+
                                         "The equation will be ignored "+
                                         "for rewriting.");
                  }

                  wrong = true;
                  module.addGeneralEquation(equ);
              }
           } else {
              Variable[] rvars = rterm.getVariables();
              for (int i=0; i<rvars.length; i++) {
                 if (!lterm.contains(rvars[i])) {
                     System.out.println("====================="+
                                        "=====================");
                     System.out.println(
                       "Warning at line "+xt.beginLine+": \u005cn"+
                       "The RHS has variables "+
                       "not in the LHS. \u005cn"+
                       "The equation will be ignored for rewriting.");
                    wrong = true;
                    module.addGeneralEquation(equ);
                    break;

                 }
              }

              if (!wrong && cterm != null) {
                 boolean wrongEq = false;
                 boolean wrongRule = false;
                 Variable[] vars = cterm.getVariables();
                 for (int i=0; i<vars.length; i++) {
                    if (!lterm.contains(vars[i])) {
                       wrongRule = true;

                       if (!rterm.contains(vars[i])) {
                           wrongEq = true;
                           break;
                       }
                    }

                 }

                 if (wrongEq) {

                     System.out.println("====================="+
                                        "=====================");
                     System.out.println(
                       "Warning at line "+xt.beginLine+":\u005cn"+
                       "The condition has variables "+
                       "not in the LHS. \u005cn"+
                       "The equation will be ignored for rewriting.");

                     module.addGeneralEquation(equ);


                 } else if (wrongRule) {

                     System.out.println("====================="+
                                        "=====================");
                     System.out.println(
                       "Warning at line "+xt.beginLine+":\u005cn"+
                       "The condition has variables "+
                       "not in the LHS. \u005cn"+
                       "The equation will be ignored for rewriting.");
                     module.addGeneralEquation(equ);

                 } else {

                      Equation equation = new Equation(cterm,lterm,rterm);
                      if (name != null) {
                          equation.setName(name);
                      }
                      equation.info = module.modName.toString();
                      module.addEquation(equation);
                      equat = equation;

                      if (dynmaicModule != null && mode == FILE_INPUT) {
                           writer.write("====================="+
                                        "=====================\u005cn");
                           writer.write(format(equation.toString(), 0)+"\u005cn");
                      }

                 }

              } else if (!wrong) {
                 Equation equation = new Equation(lterm,rterm);
                 if (name != null) {
                      equation.setName(name);
                 }
                 equation.info = module.modName.toString();
                 module.addEquation(equation);
                 equat = equation;

                 if (conditional) {
                     writer.write("====================="+
                                  "=====================\u005cn");
                     writer.write("Warning at line "+xt.beginLine+
                                  ":\u005cnuse \u005c"cq\u005c" for an unconditional"+
                                  " equation.\u005cn");
                     writer.write("   "+equation.toString()+"\u005cn");
                     writer.flush();
                 } else {

                      if (dynmaicModule != null && mode == FILE_INPUT) {
                           writer.write("====================="+
                                        "=====================\u005cn");
                           writer.write(format(equation.toString(), 0)+"\u005cn");
                           writer.flush();
                      }

                 }
              }
           }

         } catch (IOException e) {

            String msg = e.getMessage();
            msg +="at line "+xt.beginLine+".";
            {if (true) throw new ParseException(msg);}

         }
    jj_consume_token(DOT);
          {if (true) return equat;}
    throw new Error("Missing return statement in function");
  }

  final public String Term(Module module) throws ParseException {
    String result = "";
    String mid = "";
    String tmp;
    label_53:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DTH:
      case END:
      case INC:
      case INCLUDING:
      case IS:
      case SORT:
      case SORTS:
      case VAR:
      case VARS:
      case OP:
      case EQ:
      case LESS:
      case ARROW:
      case COLON:
      case ADD:
      case SUM:
      case STAR:
      case LB:
      case RB:
      case FROM:
      case APPLY:
      case WITH:
      case WITHIN:
      case PRINT:
      case OF:
      case QUIT:
      case IN:
      case SHOW:
      case MAKE:
      case LET:
      case STOP:
      case SELECT:
      case SET:
      case TRACE:
      case ON:
      case OFF:
      case FULL:
      case REDUCTION:
      case REDUCE:
      case TIME:
      case RULES:
      case JBO:
      case ASSOCIATIVE:
      case COMMUTATIVE:
      case HT:
      case WEIV:
      case ENDVIEW:
      case GATHERING:
      case PRECEDENCE:
      case THEORY:
      case SH:
      case LONGQUIT:
      case IDEMPOTENT:
      case OBJECT:
      case IDENTITY:
      case DEFINE:
      case INPUT:
      case FOR:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case IDENTIFIER:
      case 145:
        tmp = TermTokens(module);
            tmp = tmp.trim();
            result += tmp+" ";
        break;
      case 144:
        token = jj_consume_token(144);
             mid = "( ";
        label_54:
        while (true) {
          if (jj_2_40(1)) {
            tmp = Term(module);
                    mid += tmp;
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DOT:
              token = jj_consume_token(DOT);
                     Token token = getToken(0);
                     if (!module.containsToken(".")) {
                          String msg = "Unknown token: "+token.image+
                                " at line "+token.beginLine+", column "+
                                token.beginColumn+".";
                          {if (true) throw new ParseException(msg);}
                     }
                     mid += ". ";
              break;
            default:
              jj_la1[154] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          if (jj_2_41(1)) {
            ;
          } else {
            break label_54;
          }
        }
        token = jj_consume_token(146);
                result += mid+") ";
        break;
      default:
        jj_la1[155] = jj_gen;
        if (mode == FILE_INPUT &&
                                 getToken(1).image.equals(".") &&
                                 getToken(2).image.equals("(")) {
          token = jj_consume_token(DOT);
                    result += ". ";
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      if (jj_2_42(30)) {
        ;
      } else {
        break label_53;
      }
    }
           {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String TermTokens(Module module) throws ParseException {
    String result = "";
    String tmp;
    Token token, last = null;
    boolean defined = false;
    label_55:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
         if (!module.containsToken(token.image)) {

             boolean isNum = false;
             try {
                int num = Integer.parseInt(token.image);

                ModuleName nat = new ModuleName("NAT");
                ModuleName imt = new ModuleName("INT");
                if ((num >= 0 &&
                     module.containsSystemSort(new Sort("Nat", nat))) ||
                    (num < 0  &&
                     module.containsSystemSort(new Sort("Int", imt)))) {

                    isNum = true;

                }
             } catch (Exception e) {}

             if (isNum) {
                  result += token.image+" ";
             } else {

                  Sort[] sorts = module.getSortsByName(token.image);
                  if (sorts.length > 0) {
                     result += token.image+" ";
                  } else {

                     String stmp = module.decomposeToken(token.image);
                     if (stmp != null) {
                        result += stmp.trim()+" ";
                     } else if (token.image.startsWith("'") &&
                                module.getQidAlias() != null &&
                                module.getQidAlias().length > 0) {
                        result += token.image+" ";
                     } else {
                        result += token.image+" ";
                     }
                  }

             }
          } else {
             result += token.image +" ";
          }
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
          if (!module.containsToken(token.image)) {

             int num = Integer.parseInt(token.image);
             ModuleName nat = new ModuleName("NAT");
             ModuleName imt = new ModuleName("INT");

             if ((num >= 0 &&
                  module.containsSystemSort(new Sort("Nat", nat))) ||
                 (num < 0 &&
                  module.containsSystemSort(new Sort("Int", imt))) ||
                 module.containsSystemSort(FloatModule.floatSort)) {

                 result += token.image+" ";

             } else {

                 /*
                 String msg = "Unknown token: "+token.image+" at line "+
		              token.beginLine+", column "+
                              token.beginColumn+".";
                 throw new ParseException(msg);
                 */

                 if (last != null && token.beginLine == last.endLine &&
                     token.beginColumn == last.endColumn+1) {
                     result = result.substring(0, result.length()-1);
                     result += token.image+" ";
                 } else {
                     result += token.image+" ";
                 }

             }
          } else {
             result += token.image+" ";
          }
        break;
      case FLOATING_POINT_LITERAL:
        token = jj_consume_token(FLOATING_POINT_LITERAL);
          if (!module.containsToken(token.image)) {

             ModuleName floatMod = new ModuleName("FLOAT");

             if ( !module.containsSystemSort(new Sort("Float", floatMod)) ) {

                 String msg = "Unknown token: "+token.image+" at line "+
                              token.beginLine+", column "+
                              token.beginColumn+".";
                 {if (true) throw new ParseException(msg);}
             }
          }
          result += token.image+" ";
        break;
      case LESS:
        token = jj_consume_token(LESS);
          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += token.image+" ";
        break;
      case ARROW:
        token = jj_consume_token(ARROW);
          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += token.image+" ";
        break;
      case DTH:
        token = jj_consume_token(DTH);
          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += token.image+" ";
        break;
      case END:
        token = jj_consume_token(END);
          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += token.image+" ";
        break;
      case OP:
        token = jj_consume_token(OP);
          if (!module.containsToken(token.image)) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += token.image+" ";
        break;
      case IS:
        token = jj_consume_token(IS);
          if (!module.containsToken("is")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "is ";
        break;
      case VAR:
        token = jj_consume_token(VAR);
          if (!module.containsToken("var")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "var ";
        break;
      case VARS:
        token = jj_consume_token(VARS);
          if (!module.containsToken("vars")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "vars ";
        break;
      case WITH:
        token = jj_consume_token(WITH);
          if (!module.containsToken("with")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "with ";
        break;
      case WITHIN:
        token = jj_consume_token(WITHIN);
          if (!module.containsToken("within")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "within ";
        break;
      case APPLY:
        token = jj_consume_token(APPLY);
          if (!module.containsToken("apply")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "apply ";
        break;
      case PRINT:
        token = jj_consume_token(PRINT);
          if (!module.containsToken("print")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "print ";
        break;
      case INC:
        token = jj_consume_token(INC);
          if (!module.containsToken("inc")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "inc ";
        break;
      case INCLUDING:
        token = jj_consume_token(INCLUDING);
          if (!module.containsToken("including")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "including ";
        break;
      case REDUCTION:
        token = jj_consume_token(REDUCTION);
          if (!module.containsToken("reduction")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "reduction ";
        break;
      case REDUCE:
        token = jj_consume_token(REDUCE);
          if (!module.containsToken("reduce")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "reduce ";
        break;
      case SORTS:
        token = jj_consume_token(SORTS);
          if (!module.containsToken("sorts")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "sorts ";
        break;
      case SORT:
        token = jj_consume_token(SORT);
          if (!module.containsToken("sort")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "sort ";
        break;
      case MAKE:
        token = jj_consume_token(MAKE);
          if (!module.containsToken("make")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "make ";
        break;
      case EQ:
        token = jj_consume_token(EQ);
          if (!module.containsToken("eq")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "eq ";
        break;
      case IN:
        token = jj_consume_token(IN);
          if (!module.containsToken("in")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "in ";
        break;
      case QUIT:
        token = jj_consume_token(QUIT);
          if (!module.containsToken("q")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "q ";
        break;
      case LET:
        token = jj_consume_token(LET);
          if (!module.containsToken("let")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "let ";
        break;
      case STOP:
        token = jj_consume_token(STOP);
          if (!module.containsToken("eof")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "eof ";
        break;
      case SELECT:
        token = jj_consume_token(SELECT);
          if (!module.containsToken("select")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "select ";
        break;
      case SHOW:
        token = jj_consume_token(SHOW);
          if (!module.containsToken("show")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "show ";
        break;
      case SET:
        token = jj_consume_token(SET);
          if (!module.containsToken("set")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "set ";
        break;
      case TRACE:
        token = jj_consume_token(TRACE);
          if (!module.containsToken("trace")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "trace ";
        break;
      case ON:
        token = jj_consume_token(ON);
          if (!module.containsToken("on")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "on ";
        break;
      case OFF:
        token = jj_consume_token(OFF);
          if (!module.containsToken("off")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "off ";
        break;
      case FULL:
        token = jj_consume_token(FULL);
          if (!module.containsToken("full")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "full ";
        break;
      case FROM:
        token = jj_consume_token(FROM);
          if (!module.containsToken("from")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "from ";
        break;
      case OF:
        token = jj_consume_token(OF);
          if (!module.containsToken("of")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "of ";
        break;
      case TIME:
        token = jj_consume_token(TIME);
          if (!module.containsToken("time")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "time ";
        break;
      case RULES:
        token = jj_consume_token(RULES);
          if (!module.containsToken("rules")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "rules ";
        break;
      case SUM:
        token = jj_consume_token(SUM);
          if (!module.containsToken("||")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "|| ";
        break;
      case JBO:
        token = jj_consume_token(JBO);
          if (!module.containsToken("jbo")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "jbo ";
        break;
      case ASSOCIATIVE:
        token = jj_consume_token(ASSOCIATIVE);
          if (!module.containsToken("associative")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "associative ";
        break;
      case COMMUTATIVE:
        token = jj_consume_token(COMMUTATIVE);
          if (!module.containsToken("commutative")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "commutative ";
        break;
      case IDEMPOTENT:
        token = jj_consume_token(IDEMPOTENT);
          if (!module.containsToken("idempotent")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "idempotent ";
        break;
      case HT:
        token = jj_consume_token(HT);
          if (!module.containsToken("ht")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "ht ";
        break;
      case WEIV:
        token = jj_consume_token(WEIV);
          if (!module.containsToken("weiv")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "weiv ";
        break;
      case ENDVIEW:
        token = jj_consume_token(ENDVIEW);
          if (!module.containsToken("endview")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "endview ";
        break;
      case GATHERING:
        token = jj_consume_token(GATHERING);
          if (!module.containsToken("gathering")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "gathering ";
        break;
      case PRECEDENCE:
        token = jj_consume_token(PRECEDENCE);
          if (!module.containsToken("precedence")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "precedence ";
        break;
      case THEORY:
        token = jj_consume_token(THEORY);
          if (!module.containsToken("theory")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "theory ";
        break;
      case SH:
        token = jj_consume_token(SH);
          if (!module.containsToken("sh")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "sh ";
        break;
      case LONGQUIT:
        token = jj_consume_token(LONGQUIT);
          if (!module.containsToken("quit")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "quit ";
        break;
      case INPUT:
        token = jj_consume_token(INPUT);
          if (!module.containsToken("input")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "input ";
        break;
      case DEFINE:
        token = jj_consume_token(DEFINE);
          if (!module.containsToken("define")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "define ";
        break;
      case IDENTITY:
        token = jj_consume_token(IDENTITY);
          if (!module.containsToken("identity")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "identity ";
        break;
      case OBJECT:
        token = jj_consume_token(OBJECT);
          if (!module.containsToken("object")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "object ";
        break;
      case FOR:
        token = jj_consume_token(FOR);
          if (!module.containsToken("for")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "for ";
        break;
      case 145:
        token = jj_consume_token(145);
          result += ", ";
        break;
      case ADD:
        token = jj_consume_token(ADD);
         if (!module.containsToken("+")) {
             String msg = "Unknown token: "+token.image+" at line "+
                       token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "+ ";
        break;
      case STAR:
        token = jj_consume_token(STAR);
          if (!module.containsToken("*")) {
             String msg = "Unknown token: "+token.image+" at line "+
                      token.beginLine+", column "+token.beginColumn+".";
             {if (true) throw new ParseException(msg);}
          }
          result += "* ";
        break;
      case COLON:
        token = jj_consume_token(COLON);
          /*
          if (!module.containsToken(":")) {
             String msg = "Unknown token: "+token.image+" at line "+
                        token.beginLine+", column "+token.beginColumn+".";
             throw new ParseException(msg);
          }
          */
          result += ": ";
        break;
      case LB:
        token = jj_consume_token(LB);
           if (last != null &&
               last.beginLine == token.beginLine &&
               last.endColumn+1 == token.beginColumn) {

               // this token is connected to the last token
               // there are two choices:
               //   (1) seperated from the last
               //          if last is defined and (last+this)
               //             is undefined
               //   (2) connected with the last
               //          if (last+this) is defined or 
               //             (last+this) and this is undefined

               String string = result.trim();
               int index = string.lastIndexOf(" ");
               if (index != -1) {
                  string = string.substring(index).trim();
               }

               boolean all = true;
               for (int i=0; i<string.length(); i++) {
                  if (!string.substring(i, 1).equals("[")) {
                      all = false;
                      break;
                  }
               }

               if (all) {

                  if (module.containsToken(string) &&
                      !module.containsToken(string+token.image)) {
                      result += "[ ";
                  } else {
                      if (module.containsTokenForModuleName(string) &&
                          !module.containsToken(string+token.image)) {
                         result += "[ ";
                      } else {
                         result = result.trim();
                         result += "[ ";
                      }
                  }

               } else {
                  //result += "[ ";

                  if (module.containsToken(string) &&
                      !module.containsToken(string+token.image)) {
                      result += "[ ";
                  } else if (module.containsTokenForModuleName(string) &&
                          !module.containsToken(string+token.image)) {
                      result += "[ ";
                  } else if (last.image.equals(",") ||
                             last.image.startsWith("'")) {
                      result += "[ ";
                  } else {
                      result = result.trim();
                      result += "[ ";
                  }
               }

           } else {
               // this token is seperated from the last token
               result += "[ ";
           }
        break;
      case RB:
        token = jj_consume_token(RB);
           if (last != null &&
               last.beginLine == token.beginLine &&
               last.endColumn+1 == token.beginColumn) {

               // this token is connected to the last token
               // there are two choices:
               //   (1) seperated from the last
               //          if last is defined and (last+this)
               //             is undefined
               //   (2) connected with the last
               //          if (last+this) is defined or 
               //             (last+this) and this is undefined

               String string = result.trim();
               int index = string.lastIndexOf(" ");
               if (index != -1) {
                  string = string.substring(index).trim();
               }

               boolean all = true;
               for (int i=0; i<string.length(); i++) {
                  if (!string.substring(i, 1).equals("]")) {
                      all = false;
                      break;
                  }
               }

               if (all) {
                   if (module.containsToken(string) &&
                       !module.containsToken(string+token.image)) {
                       result += "] ";

                   } else {
                       result = result.trim();
                       result += "] ";
                   }

               } else {

                   // if connected is an existing token, then use it
                   // otherwise seperate them

                   string += "]";
                   if (module.containsToken(string)) {
                       result = result.trim();
                       result += "] ";
                   } else {
                       result += "] ";
                   }

                   //result += "] ";
               }

           } else {

               // this token is seperated from the last token
               result += "] ";

           }
        break;
      default:
        jj_la1[156] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          last = token;
      if (jj_2_43(200)) {
        ;
      } else {
        break label_55;
      }
    }
       {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void DefDecl(Module mod) throws ParseException {
  Token token;
  Module module;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DFN:
      jj_consume_token(DFN);
      break;
    case DEFINE:
      jj_consume_token(DEFINE);
      break;
    default:
      jj_la1[157] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    token = jj_consume_token(IDENTIFIER);
    jj_consume_token(IS);
    module = ModExpr(mod);
    jj_consume_token(DOT);
        try {

             Sort from = module.getPrincipalSort();
             Sort to = new Sort(token.image, mod.getModuleName());

             module = module.changeSort(module.getModuleName(), from, to);
             module = module.changeModuleName(module.modName,
                                              new ModuleName(token.image),
                                              new ModuleName(token.image));

             mod.importModule(module);

             if (from.isDefault() && from.getName().equals("Id")) {
                 mod.addQidAlias(to);
             }

        } catch (SignatureException e) {
             Token xt = token;
             String msg = e.getMessage();
             msg += ", at line "+xt.beginLine+".";
             {if (true) throw new ParseException(msg);}
        }
  }

  final public String OpNameNoComma() throws ParseException {
   String result = "";
   String tmp;
   Token token;
    label_56:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
          result += token.image +" ";
        break;
      case INTEGER_LITERAL:
        token = jj_consume_token(INTEGER_LITERAL);
          result += token.image+" ";
        break;
      case OBJ:
        token = jj_consume_token(OBJ);
          result += token.image+" ";
        break;
      case TH:
        token = jj_consume_token(TH);
          result += token.image+" ";
        break;
      case BTH:
        token = jj_consume_token(BTH);
          result += token.image+" ";
        break;
      case DTH:
        token = jj_consume_token(DTH);
          result += token.image+" ";
        break;
      case ENDO:
        token = jj_consume_token(ENDO);
          result += token.image+" ";
        break;
      case ENDTH:
        token = jj_consume_token(ENDTH);
          result += token.image+" ";
        break;
      case ENDB:
        token = jj_consume_token(ENDB);
          result += token.image+" ";
        break;
      case ENDD:
        token = jj_consume_token(ENDD);
          result += token.image+" ";
        break;
      case END:
        token = jj_consume_token(END);
          result += token.image+" ";
        break;
      case PR:
        token = jj_consume_token(PR);
          result += token.image+" ";
        break;
      case PROTECTING:
        token = jj_consume_token(PROTECTING);
          result += token.image+" ";
        break;
      case EX:
        token = jj_consume_token(EX);
          result += token.image+" ";
        break;
      case EXTENDING:
        token = jj_consume_token(EXTENDING);
          result += token.image+" ";
        break;
      case US:
        token = jj_consume_token(US);
          result += token.image+" ";
        break;
      case USING:
        token = jj_consume_token(USING);
          result += token.image+" ";
        break;
      case BSORT:
        token = jj_consume_token(BSORT);
          result += token.image+" ";
        break;
      case BSORTS:
        token = jj_consume_token(BSORTS);
          result += token.image+" ";
        break;
      case SUBSORT:
        token = jj_consume_token(SUBSORT);
          result += token.image+" ";
        break;
      case SUBSORTS:
        token = jj_consume_token(SUBSORTS);
          result += token.image+" ";
        break;
      case LESS:
        token = jj_consume_token(LESS);
          result += token.image+" ";
        break;
      case ARROW:
        token = jj_consume_token(ARROW);
          result += token.image+" ";
        break;
      case VAR:
        token = jj_consume_token(VAR);
          result += token.image+" ";
        break;
      case VARS:
        token = jj_consume_token(VARS);
          result += token.image+" ";
        break;
      case IS:
        jj_consume_token(IS);
          result += "is ";
        break;
      case LET:
        jj_consume_token(LET);
          result += "let ";
        break;
      case SUM:
        jj_consume_token(SUM);
          result += "|| ";
        break;
      case PARENS:
        jj_consume_token(PARENS);
          result += "parens ";
        break;
      case INCLUDE:
        jj_consume_token(INCLUDE);
          result += "include ";
        break;
      case REDUCTION:
        jj_consume_token(REDUCTION);
          result += "result ";
        break;
      case INC:
        jj_consume_token(INC);
          result += "inc ";
        break;
      case INCLUDING:
        jj_consume_token(INCLUDING);
          result += "including ";
        break;
      case REDUCE:
        jj_consume_token(REDUCE);
          result += "reduce ";
        break;
      case TIME:
        jj_consume_token(TIME);
          result += "time ";
        break;
      case JBO:
        jj_consume_token(JBO);
          result += "jbo ";
        break;
      case ASSOCIATIVE:
        jj_consume_token(ASSOCIATIVE);
          result += "associative ";
        break;
      case COMMUTATIVE:
        jj_consume_token(COMMUTATIVE);
          result += "commutative ";
        break;
      case IDEMPOTENT:
        jj_consume_token(IDEMPOTENT);
          result += "idempotent ";
        break;
      case HT:
        jj_consume_token(HT);
          result += "ht ";
        break;
      case WEIV:
        jj_consume_token(WEIV);
          result += "weiv ";
        break;
      case ENDVIEW:
        jj_consume_token(ENDVIEW);
          result += "endview ";
        break;
      case GATHERING:
        jj_consume_token(GATHERING);
          result += "gathering ";
        break;
      case PRECEDENCE:
        jj_consume_token(PRECEDENCE);
          result += "precedence ";
        break;
      case THEORY:
        jj_consume_token(THEORY);
          result += "theory ";
        break;
      case SH:
        jj_consume_token(SH);
          result += "sh ";
        break;
      case LONGQUIT:
        jj_consume_token(LONGQUIT);
          result += "quit ";
        break;
      case OBJECT:
        jj_consume_token(OBJECT);
          result += "quit ";
        break;
      case DEFINE:
        jj_consume_token(DEFINE);
          result += "define ";
        break;
      case IDENTITY:
        jj_consume_token(IDENTITY);
          result += "identity ";
        break;
      case INPUT:
        jj_consume_token(INPUT);
          result += "input ";
        break;
      case ADD:
        jj_consume_token(ADD);
          result += "+ ";
        break;
      case STAR:
        jj_consume_token(STAR);
          result += "* ";
        break;
      case QUIT:
        jj_consume_token(QUIT);
          result += "q ";
        break;
      case LB:
        jj_consume_token(LB);
        tmp = OpName();
        jj_consume_token(RB);
          if (tmp.trim().startsWith("[") && tmp.trim().endsWith("]")) {
             tmp = "["+tmp.trim()+"] ";
          } else {
             tmp = "[ "+tmp.trim()+" ] ";
          }

          result += tmp;
        break;
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_44(2)) {
        ;
      } else {
        break label_56;
      }
    }
     {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public View ViewDecl() throws ParseException {
    String viewName;
    Module source, target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
    boolean hasParameter = false;
    boolean force = false;
    ArrayList views = null ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      token = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[159] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         viewName = token.image;
         Module pmod = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LB:
      jj_consume_token(LB);
              String str = "parameter-module-in-view"+token.image;
              ModuleName modName = new ModuleName(str);
              pmod = new Module(Module.LOOSE, modName);
              Module mod;
              List list = new ArrayList();
      label_57:
      while (true) {
        token = jj_consume_token(IDENTIFIER);
                list.add(token.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[160] = jj_gen;
          break label_57;
        }
      }
      jj_consume_token(DOUBLECOLON);
      mod = ModExpr(pmod);
               try {
                   for (int i=0; i<list.size(); i++) {
                       String paraName = (String)list.get(i);
                       pmod.addParameter(paraName, mod, getEnv());
                       paraPool.put(paraName, mod);
                   }
               } catch (SignatureException e) {
                   String msg = e.getMessage()+" at line "+
                                token.beginLine+" column "+
                                token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               } catch (ModuleParameterException e) {
                   String msg = e.getMessage()+" at line "+
                                token.beginLine+" column "+
                                token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               }
      label_58:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 145:
          ;
          break;
        default:
          jj_la1[161] = jj_gen;
          break label_58;
        }
        jj_consume_token(145);
                   list = new ArrayList();
        label_59:
        while (true) {
          token = jj_consume_token(IDENTIFIER);
                   list.add(token.image);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[162] = jj_gen;
            break label_59;
          }
        }
        jj_consume_token(DOUBLECOLON);
        mod = ModExpr(pmod);
                 try {
                     for (int i=0; i<list.size(); i++) {
                         String paraName = (String)list.get(i);
                         pmod.addParameter(paraName, mod, getEnv());
                         paraPool.put(paraName, mod);
                     }
                 } catch (SignatureException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                     {if (true) throw new ParseException(msg);}
                 } catch (ModuleParameterException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                     {if (true) throw new ParseException(msg);}
                 }
      }
      jj_consume_token(RB);
             hasParameter = true;
      break;
    default:
      jj_la1[163] = jj_gen;
      ;
    }
    jj_consume_token(FROM);
    source = ModExpr(pmod);
    jj_consume_token(TO);
    target = ModExpr(pmod);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      jj_consume_token(WITH);
      jj_consume_token(LB);
                  int index = 0;
                  View[] vs = new View[source.paraNames.size()];
                  Module[] mds = new Module[vs.length];
                  String[] ns = new String[vs.length];
                  views = new ArrayList();

                  Module psrc = null;
                  try {
                      psrc = target.getParameterAt(index);
                      //ns[index] = source.getParameterNameAt(index);
                  } catch (Exception e) {
                      String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                  }

                  Module md;
      mds[index] = LocalViewDecl(pmod, psrc, new Vector());
                     vs[index] = (View)mds[index].getProperty("view");
                     views.add(vs[index].copy(""));

                     try {
                        vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
                                      target.getParameterNameAt(index),
                                      getEnv());

                        //mds[index] = vs[index].source;
                        mds[index] = vs[index].target;
                        mds[index].setProperty("view", vs[index]);

                     } catch (Exception e) {
                        String msg = e.getMessage()+" at line "+
                                     token.beginLine+" column "+
                                     token.beginColumn;
                        {if (true) throw new ParseException(msg);}
                     }

                     index++;
      label_60:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 145:
          ;
          break;
        default:
          jj_la1[164] = jj_gen;
          break label_60;
        }
        jj_consume_token(145);
                        try {
                           psrc = target.getParameterAt(index);
                           //ns[index] = source.getParameterNameAt(index);
                        } catch (ModuleParameterException e) {
                           String msg = e.getMessage()+" at line "+
                                       token.beginLine+" column "+
                                       token.beginColumn;
                           {if (true) throw new ParseException(msg);}
                        }
        mds[index] = LocalViewDecl(pmod, psrc, new Vector());
                          vs[index] = (View)mds[index].getProperty("view");
                          views.add(vs[index].copy(""));

                          try {
                             vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
                                      target.getParameterNameAt(index),
                                      getEnv());
                             //mds[index] = vs[index].source;
                             mds[index] = vs[index].target;
                             mds[index].setProperty("view", vs[index]);
                          } catch (Exception e) {
                             String msg = e.getMessage()+" at line "+
                                     token.beginLine+" column "+
                                     token.beginColumn;
                             {if (true) throw new ParseException(msg);}
                          }
                          index++;
      }
      jj_consume_token(RB);
                   try {
                      md = target.instanceBy(mds, ns, getEnv(), false);
                   } catch (Exception e) {
                      String msg = e.getMessage()+" at line "+
                                   token.beginLine+" column "+
                                   token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                   }

                   Module newTarget = md;
                   newTarget.modName = target.modName;
                   newTarget.paraNames.addAll(source.paraNames);
                   newTarget.paraModules.addAll(source.paraModules);
                   newTarget.levels = new int[1];
                   newTarget.levels[0] = source.paraNames.size();

                   target = newTarget;
      break;
    default:
      jj_la1[165] = jj_gen;
      ;
    }
    jj_consume_token(IS);
            view = new View(viewName, source, target);
            if (hasParameter) {
                view.record(pmod);
            }
    label_61:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SORT:
      case VAR:
      case VARS:
      case OP:
        ;
        break;
      default:
        jj_la1[166] = jj_gen;
        break label_61;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
      case VARS:
            Vector vnames = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARS:
          jj_consume_token(VARS);
          break;
        case VAR:
          jj_consume_token(VAR);
          break;
        default:
          jj_la1[167] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_62:
        while (true) {
          token = jj_consume_token(IDENTIFIER);
               vnames.addElement(token);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[168] = jj_gen;
            break label_62;
          }
        }
        jj_consume_token(COLON);
        sort = SortReference(source);
        jj_consume_token(DOT);
              for (int i=0; i<vnames.size(); i++) {
                 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
                 } catch (ViewException e) {
                    String msg = e.getMessage();
                    msg += " at line "+tmp.beginLine+
                              ", column "+tmp.beginColumn+".";
                    {if (true) throw new ParseException(msg);}
                 }
              }
        break;
      case SORT:
        jj_consume_token(SORT);
             token1 = getToken(0);
        sort1 = SortReference(source);
        jj_consume_token(TO);
             token2 = getToken(0);
        sort2 = SortReference(target);
        jj_consume_token(DOT);
            try {

              Sort tmp = view.getTarget(sort1);
              if (tmp != null && tmp.equals(sort2)) {
                  System.out.println("=================="+
                                     "========================");
                  System.out.println("Warning: duplicate mapping from "+
                                     sort1.getName()+" to "+sort2.getName()+
                                     " at line "+token1.beginLine);
              }

              view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
               String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
               {if (true) throw new ParseException(msg);}
            }
        break;
      case OP:
         String opname1, opname2;
        jj_consume_token(OP);
             token1 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname1 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname1 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          break;
        default:
          jj_la1[169] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(TO);
             token2 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname2 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname2 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          break;
        default:
          jj_la1[170] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(DOT);
             Operation[] ops1 = source.getOperationsWithName(opname1.trim());

             if (ops1.length > 1) {
                String msg = "Multiple operations with the name "+
                              opname1+" in the module "+source.getModuleName()+
                              " at line "+token1.beginLine+" column "+
                              token1.beginColumn+".";
                {if (true) throw new ParseException(msg);}
             }

             Operation op1, op2;

             if (ops1.length == 1) {

                Operation[] ops2 =target.getOperationsWithName(opname2.trim());

                if (ops2.length > 1) {

                    Vector pool = new Vector();
                    for (int i=0; i<ops2.length; i++) {
                         boolean found = false;
                         for (int j=0; j<pool.size(); j++) {
                              Operation op = (Operation)pool.elementAt(j);
                              if (op.less(target, ops2[i])) {
                                   pool.removeElementAt(j);
                                   pool.insertElementAt(ops2[i], j);
                                   found = true;
                              } else if (ops2[i].less(target, op)) {
                                   found = true;
                              }
                         }

                         if (!found) {
                             pool.addElement(ops2[i]);
                         }
                    }

                    if (pool.size() > 1) {

                        String msg = "Multiple operations with the name "+
                                     opname2+" in the module "+
                                     target.getModuleName()+
                                     " at line "+token2.beginLine+" column "+
                                     token2.beginColumn+".";
                        {if (true) throw new ParseException(msg);}
                    } else {
                        ops2 = new Operation[pool.size()];
                        pool.copyInto(ops2);
                    }
                }

                if (ops2.length == 0) {

                     // no operation is found, parse it as a term
                     try {
                          Term term = Term.parse(view.getEnrichedTarget(),
                                                 opname2);
                          if (ops1[0].isConstant()) {

                             Term left = new Term(ops1[0]);
                             view.addTransformation(left, term);

                          } else {
                              String msg = opname1.trim()+
                                           " is not a constant in the module "+
                                           source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                             {if (true) throw new ParseException(msg);}
                          }

                     } catch (TermException e) {

                          ops2 =
                            target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

                             try {
                                op1 = ops1[0];
                                op2 = ops2[0];
                                view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
                                String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
                                {if (true) throw new ParseException(msg);}
                             }

                          } else {

                              String msg = "Unresolvable tokens "+
                                           opname2.trim()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                              {if (true) throw new ParseException(msg);}
                          }
                     }

                } else {

                   op1 = ops1[0];
                   op2 = ops2[0];

                   Operation tmp = view.getTarget(op1);
                   if (tmp != null && tmp.equals(op2)) {
                      System.out.println("======================"+
                                         "====================");
                      System.out.println("Warning: duplicate mapping from "+
                                          op1.getCleanName()+" to "+
                                          op2.getCleanName()+
                                          " at line "+token2.beginLine+
                                          " column "+token2.beginColumn+".");
                   }

                   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
                      String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
                      {if (true) throw new ParseException(msg);}
                   }
                }

             } else {

                // no operation is found, try to parse term
                boolean okay = false;
                Term left = null;
                Term right = null;

                try {

                  left =
                     Term.parse(view.getEnrichedSource(),
                                opname1);

                  right =
                     Term.parse(view.getEnrichedTarget(),
                                opname2);

                  if (left != null && right != null) {
                     view.addTransformation(left, right);
                     okay = true;
                  }

                } catch (TermException e) {}

                if (!okay) {

                   Operation lop = null, rop = null;
                   if (left == null) {
                      Operation[] lops =
                          source.getOperationsWithCleanName(opname1.trim());
                      if (lops.length == 1) {
                         lop = lops[0];
                      }
                   }

                   if (right == null) {
                      Operation[] rops =
                          source.getOperationsWithCleanName(opname2.trim());
                      if (rops.length == 1) {
                         rop = rops[0];
                      }
                   }

                   // there are 3 cases:
                   try {
                       if (left != null && rop != null) {
                            view.addTransformation(left, new Term(rop));
                            okay = true;
                       } else if (lop != null && right != null) {
                            view.addTransformation(new Term(lop), right);
                            okay = true;
                       } else if (lop != null && rop != null) {
                            view.addOperationMap(lop, rop);
                            okay = true;
                       }
                   } catch (Exception ex) {}
                }


                if (!okay && left == null) {
                   String msg = "No operations with the name \u005c""+
                             opname1.trim()+"\u005c" in the module "+
                             source.getModuleName()+
                             " at line "+token1.beginLine+" column "+
                             token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}
                } else if (!okay && right == null) {
                   String msg = "No operations with the name \u005c""+
                             opname2.trim()+"\u005c" in the module "+
                             target.getModuleName()+
                             " at line "+token2.beginLine+" column "+
                             token2.beginColumn+".";
                   {if (true) throw new ParseException(msg);}
                } else if (!okay) {
                   String msg = "No parse "+
                                " at line "+token1.beginLine+" column "+
                                token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}

                }

             }
        break;
      default:
        jj_la1[171] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         try {

             if (views != null) {
                view.views = views;
                view.record();
             }
             view.validate();

         } catch (ViewException e) {

             Token xt = getToken(0);
             String msg = e.getMessage()+
                          " at line "+xt.beginLine+", column "+
                          xt.beginColumn+".";

             if (detail) {
                msg = "format:"+format(msg, 0)+"\u005cn"+
                      "the failed view is\u005cn"+e.getView();
             }

             {if (true) throw new ParseException(msg);}
         }

         {if (true) return view;}
    throw new Error("Missing return statement in function");
  }

  final public Module LocalViewDecl(Module mod, Module source, Vector views) throws ParseException {
    Module target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
    jj_consume_token(VIEW);
    jj_consume_token(TO);
    target = ModExpr(mod);
    jj_consume_token(IS);
             view = new View("", source, target);
    label_63:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SORT:
      case VAR:
      case VARS:
      case OP:
        ;
        break;
      default:
        jj_la1[172] = jj_gen;
        break label_63;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
      case VARS:
         Vector vnames = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARS:
          jj_consume_token(VARS);
          break;
        case VAR:
          jj_consume_token(VAR);
          break;
        default:
          jj_la1[173] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_64:
        while (true) {
          token = jj_consume_token(IDENTIFIER);
               vnames.addElement(token);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[174] = jj_gen;
            break label_64;
          }
        }
        jj_consume_token(COLON);
        sort = SortReference(source);
        jj_consume_token(DOT);
              for (int i=0; i<vnames.size(); i++) {
                 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
                 } catch (ViewException e) {
                    String msg = e.getMessage();
                    msg += " at line "+tmp.beginLine+
                              ", column "+tmp.beginColumn+".";
                    {if (true) throw new ParseException(msg);}
                 }
              }
        break;
      case SORT:
        jj_consume_token(SORT);
              token1 = getToken(0);
        sort1 = SortReference(source);
        jj_consume_token(TO);
              token2 = getToken(0);
        sort2 = SortReference(target);
        jj_consume_token(DOT);
            try {
               view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
               String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
               {if (true) throw new ParseException(msg);}
            }
        break;
      case OP:
         String opname1, opname2;
         String modStr1=null, modStr2=null;
        jj_consume_token(OP);
             token1 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname1 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname1 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            token = jj_consume_token(IDENTIFIER);
                   modStr1 = token.image;
                   if (modStr1.startsWith(".")) {
                       modStr1 = modStr1.substring(1);
                   } else {
                       String msg = "expect . ";
                       msg += " at line "+token.beginLine+" column "+
                              token.beginColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }
            break;
          default:
            jj_la1[175] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[176] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(TO);
             token2 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname2 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname2 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            token = jj_consume_token(IDENTIFIER);
                   modStr2 = token.image;
                   if (modStr2.startsWith(".")) {
                       modStr2 = modStr2.substring(1);
                   } else {
                       String msg = "expect . ";
                       msg += " at line "+token.beginLine+" column "+
                              token.beginColumn+".";
                       {if (true) throw new ParseException(msg);}
                   }
            break;
          default:
            jj_la1[177] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[178] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(DOT);
             Operation[] ops1 = source.getOperationsWithName(opname1.trim());

             if (modStr1 != null) {

                 ArrayList list = new ArrayList();
                 for (int i=0; i<ops1.length; i++) {
                     if (ops1[i].modName.op == ModuleName.ATOM &&
                         ops1[i].modName.atom.equals(modStr1)) {
                         list.add(ops1[i]);
                     }
                 }

                 ops1 = new Operation[list.size()];
                 for (int i=0; i<ops1.length; i++) {
                    ops1[i] = (Operation)list.get(i);
                 }
             }

             if (ops1.length > 1) {
                String msg = "Multiple operations with the name "+
                              opname1+" in the module "+source.getModuleName()+
                              " at line "+token1.beginLine+" column "+
                              token1.beginColumn+".";
                {if (true) throw new ParseException(msg);}
             }


             Operation op1, op2;

             if (ops1.length == 1) {

                Operation[] ops2=target.getOperationsWithName(opname2.trim());

                if (modStr2 != null) {

                    ArrayList list = new ArrayList();
                    for (int i=0; i<ops2.length; i++) {


                        if (ops2[i].modName.op == ModuleName.ATOM &&
                            ops2[i].modName.atom.equals(modStr2)) {
                           list.add(ops2[i]);
                        }

                    }

                    ops2 = new Operation[list.size()];
                    for (int i=0; i<ops2.length; i++) {
                       ops2[i] = (Operation)list.get(i);
                    }
                }

                if (ops2.length > 1) {

                    Vector pool = new Vector();
                    for (int i=0; i<ops2.length; i++) {
                        boolean found = false;
                        for (int j=0; j<pool.size(); j++) {
                            Operation op = (Operation)pool.elementAt(j);
                            if (op.less(target, ops2[i])) {
                                pool.removeElementAt(j);
                                pool.insertElementAt(ops2[i], j);
                                found = true;
                            } else if (ops2[i].less(target, op)) {
                                found = true;
                            }
                        }

                        if (!found) {
                            pool.addElement(ops2[i]);
                        }
                  }

                  if (pool.size() > 1) {

                     String msg = "Multiple operations with the name "+
                                  opname2+" in the module "+
                                  target.getModuleName()+
                                  " at line "+token2.beginLine+" column "+
                                  token2.beginColumn+".";
                     {if (true) throw new ParseException(msg);}
                  } else {
                     ops2 = new Operation[pool.size()];
                     pool.copyInto(ops2);
                  }
                }

                if (ops2.length == 0) {

                     // no operation is found, parse it as a term
                     try {
                          Term term = Term.parse(view.getEnrichedTarget(),
                                                 opname2);
                          if (ops1[0].isConstant()) {

                             Term left = new Term(ops1[0]);
                             view.addTransformation(left, term);

                          } else {
                              String msg = opname1.trim()+
                                           " is not a constant in the module "+
                                           source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                             {if (true) throw new ParseException(msg);}
                          }

                     } catch (TermException e) {

                          // try to use clean name
                          ops2 =
                            target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

                             try {
                                op1 = ops1[0];
                                op2 = ops2[0];
                                view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
                                String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
                                {if (true) throw new ParseException(msg);}
                             }

                          } else {

                            String msg = "Unresolvable tokens "+opname2.trim()+
                                        " at line "+token2.beginLine+
                                        ", column "+token2.beginColumn;
                            {if (true) throw new ParseException(msg);}
                          }
                     }

                } else {

                   op1 = ops1[0];
                   op2 = ops2[0];

                   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
                      String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
                      {if (true) throw new ParseException(msg);}
                   }
                }

             } else {

                // no operation is found, try to parse term
                boolean okay = false;
                Term left = null;
                Term right = null;

                try {

                  left =
                     Term.parse(view.getEnrichedSource(),
                                opname1);

                  right =
                     Term.parse(view.getEnrichedTarget(),
                                opname2);

                  if (left != null && right != null) {
                     view.addTransformation(left, right);
                     okay = true;
                  }

                } catch (TermException e) {}

                if (!okay) {

                   Operation lop = null, rop = null;
                   if (left == null) {
                      Operation[] lops =
                          source.getOperationsWithCleanName(opname1.trim());
                      if (lops.length == 1) {
                         lop = lops[0];
                      }
                   }

                   if (right == null) {
                      Operation[] rops =
                          source.getOperationsWithCleanName(opname2.trim());
                      if (rops.length == 1) {
                         rop = rops[0];
                      }
                   }

                   // there are 3 cases:
                   try {
                       if (left != null && rop != null) {
                            view.addTransformation(left, new Term(rop));
                            okay = true;
                       } else if (lop != null && right != null) {
                            view.addTransformation(new Term(lop), right);
                            okay = true;
                       } else if (lop != null && rop != null) {
                            view.addOperationMap(lop, rop);
                            okay = true;
                       }
                   } catch (Exception ex) {}
                }

                if (!okay && left == null) {

                   String msg = "No operations with the name \u005c""+
                             opname1.trim()+"\u005c" in the module "+
                             source.getModuleName()+
                             " at line "+token1.beginLine+" column "+
                             token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}

                } else if (!okay && right == null) {

                   String msg = "No operations with the name \u005c""+
                             opname2.trim()+"\u005c" in the module "+
                             target.getModuleName()+
                             " at line "+token2.beginLine+" column "+
                             token2.beginColumn+".";
                   {if (true) throw new ParseException(msg);}

                } else if (!okay) {
                   String msg = "No parse "+
                                " at line "+token1.beginLine+" column "+
                                token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}

                }

             }
        break;
      default:
        jj_la1[179] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case END:
      jj_consume_token(END);
      break;
    case ENDV:
      jj_consume_token(ENDV);
      break;
    case WEIV:
      jj_consume_token(WEIV);
      break;
    case ENDVIEW:
      jj_consume_token(ENDVIEW);
      break;
    default:
      jj_la1[180] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         try {
             view.validate();
             target.setProperty("view", view);
         } catch (ViewException e) {

             Token xt = getToken(0);
             String msg = e.getMessage()+
                          " at line "+xt.beginLine+", column "+
                          xt.beginColumn+".";

             if (detail) {
                msg = "format:"+format(msg, 0)+"\u005cn"+
                      "the failed view is\u005cn"+e.getView();
             }

             {if (true) throw new ParseException(msg);}
         }

         {if (true) return target;}
    throw new Error("Missing return statement in function");
  }

  final public Sort[] CobSortsDecl(Module module) throws ParseException {
    Sort[] sorts;
    Vector vec = new Vector();
    Sort sort;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SORT:
      jj_consume_token(SORT);
      break;
    case SORTS:
      jj_consume_token(SORTS);
      break;
    default:
      jj_la1[181] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_65:
    while (true) {
      sort = SortReference(module);
               vec.addElement(sort);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[182] = jj_gen;
        break label_65;
      }
    }
    jj_consume_token(DOT);
            sorts = new Sort[vec.size()];
            vec.copyInto(sorts);
            {if (true) return sorts;}
    throw new Error("Missing return statement in function");
  }

  final public Operation CobOpDecl(Module module) throws ParseException {
    Sort sort;
    Vector argv = new Vector();
    String opName;
    Token token, xt;
    xt = jj_consume_token(OP);
    opName = OpName();
    jj_consume_token(COLON);
    label_66:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[183] = jj_gen;
        break label_66;
      }
      sort = SortReference(module);
             argv.addElement(sort);
    }
    jj_consume_token(ARROW);
    sort = SortReference(module);
    jj_consume_token(DOT);
             Sort[] args = new Sort[argv.size()];
             argv.copyInto(args);

             try {
                {if (true) return new Operation(opName,
                                     args,
                                     sort,
                                     module.getModuleName());}
              } catch (SignatureException e) {
                {if (true) throw new ParseException(e.getMessage()+" at line "+
                                         xt.beginLine+", column "+
                                         xt.beginColumn);}
              }
    throw new Error("Missing return statement in function");
  }

  final public Token MetaToken() throws ParseException {
   Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJ:
      token = jj_consume_token(OBJ);
      break;
    case TH:
      token = jj_consume_token(TH);
      break;
    case BTH:
      token = jj_consume_token(BTH);
      break;
    case DTH:
      token = jj_consume_token(DTH);
      break;
    case ENDO:
      token = jj_consume_token(ENDO);
      break;
    case ENDTH:
      token = jj_consume_token(ENDTH);
      break;
    case ENDB:
      token = jj_consume_token(ENDB);
      break;
    case ENDD:
      token = jj_consume_token(ENDD);
      break;
    case END:
      token = jj_consume_token(END);
      break;
    case PR:
      token = jj_consume_token(PR);
      break;
    case PROTECTING:
      token = jj_consume_token(PROTECTING);
      break;
    case EX:
      token = jj_consume_token(EX);
      break;
    case EXTENDING:
      token = jj_consume_token(EXTENDING);
      break;
    case US:
      token = jj_consume_token(US);
      break;
    case USING:
      token = jj_consume_token(USING);
      break;
    case IS:
      token = jj_consume_token(IS);
      break;
    case SORT:
      token = jj_consume_token(SORT);
      break;
    case SORTS:
      token = jj_consume_token(SORTS);
      break;
    case BSORT:
      token = jj_consume_token(BSORT);
      break;
    case BSORTS:
      token = jj_consume_token(BSORTS);
      break;
    case SUBSORT:
      token = jj_consume_token(SUBSORT);
      break;
    case SUBSORTS:
      token = jj_consume_token(SUBSORTS);
      break;
    case VAR:
      token = jj_consume_token(VAR);
      break;
    case VARS:
      token = jj_consume_token(VARS);
      break;
    case OP:
      token = jj_consume_token(OP);
      break;
    case OPS:
      token = jj_consume_token(OPS);
      break;
    case OPAS:
      token = jj_consume_token(OPAS);
      break;
    case EQ:
      token = jj_consume_token(EQ);
      break;
    case CQ:
      token = jj_consume_token(CQ);
      break;
    case CEQ:
      token = jj_consume_token(CEQ);
      break;
    case ASSOC:
      token = jj_consume_token(ASSOC);
      break;
    case COMM:
      token = jj_consume_token(COMM);
      break;
    case IDEM:
      token = jj_consume_token(IDEM);
      break;
    case PREC:
      token = jj_consume_token(PREC);
      break;
    case IDR:
      token = jj_consume_token(IDR);
      break;
    case ID:
      token = jj_consume_token(ID);
      break;
    case NONCONG:
      token = jj_consume_token(NONCONG);
      break;
    case MEMO:
      token = jj_consume_token(MEMO);
      break;
    case LESS:
      token = jj_consume_token(LESS);
      break;
    case ARROW:
      token = jj_consume_token(ARROW);
      break;
    case DOT:
      token = jj_consume_token(DOT);
      break;
    case VARSOF:
      token = jj_consume_token(VARSOF);
      break;
    case COLON:
      token = jj_consume_token(COLON);
      break;
    case DOUBLECOLON:
      token = jj_consume_token(DOUBLECOLON);
      break;
    case ADD:
      token = jj_consume_token(ADD);
      break;
    case SUM:
      token = jj_consume_token(SUM);
      break;
    case TO:
      token = jj_consume_token(TO);
      break;
    case STAR:
      token = jj_consume_token(STAR);
      break;
    case LB:
      token = jj_consume_token(LB);
      break;
    case RB:
      token = jj_consume_token(RB);
      break;
    case DFN:
      token = jj_consume_token(DFN);
      break;
    case RED:
      token = jj_consume_token(RED);
      break;
    case BRED:
      token = jj_consume_token(BRED);
      break;
    case SOLVE:
      token = jj_consume_token(SOLVE);
      break;
    case OPEN:
      token = jj_consume_token(OPEN);
      break;
    case OPENR:
      token = jj_consume_token(OPENR);
      break;
    case CLOSE:
      token = jj_consume_token(CLOSE);
      break;
    case VIEW:
      token = jj_consume_token(VIEW);
      break;
    case ENDV:
      token = jj_consume_token(ENDV);
      break;
    case FROM:
      token = jj_consume_token(FROM);
      break;
    case LOAD:
      token = jj_consume_token(LOAD);
      break;
    case APPLY:
      token = jj_consume_token(APPLY);
      break;
    case QUIT:
      token = jj_consume_token(QUIT);
      break;
    case PWD:
      token = jj_consume_token(PWD);
      break;
    case CD:
      token = jj_consume_token(CD);
      break;
    case LS:
      token = jj_consume_token(LS);
      break;
    case IN:
      token = jj_consume_token(IN);
      break;
    case SHOW:
      token = jj_consume_token(SHOW);
      break;
    case MAKE:
      token = jj_consume_token(MAKE);
      break;
    case ENDM:
      token = jj_consume_token(ENDM);
      break;
    case LET:
      token = jj_consume_token(LET);
      break;
    case COMMENT:
      token = jj_consume_token(COMMENT);
      break;
    case COBASIS:
      token = jj_consume_token(COBASIS);
      break;
    case COB:
      token = jj_consume_token(COB);
      break;
    case COV:
      token = jj_consume_token(COV);
      break;
    case STOP:
      token = jj_consume_token(STOP);
      break;
    case SELECT:
      token = jj_consume_token(SELECT);
      break;
    case SET:
      token = jj_consume_token(SET);
      break;
    case TRACE:
      token = jj_consume_token(TRACE);
      break;
    case ON:
      token = jj_consume_token(ON);
      break;
    case OFF:
      token = jj_consume_token(OFF);
      break;
    case FULL:
      token = jj_consume_token(FULL);
      break;
    case OF:
      token = jj_consume_token(OF);
      break;
    case PARSE:
      token = jj_consume_token(PARSE);
      break;
    case START:
      token = jj_consume_token(START);
      break;
    case AT:
      token = jj_consume_token(AT);
      break;
    case WITH:
      token = jj_consume_token(WITH);
      break;
    case PRINT:
      token = jj_consume_token(PRINT);
      break;
    case PARENS:
      token = jj_consume_token(PARENS);
      break;
    case WITHIN:
      token = jj_consume_token(WITHIN);
      break;
    case INCLUDE:
      token = jj_consume_token(INCLUDE);
      break;
    case REDUCTION:
      token = jj_consume_token(REDUCTION);
      break;
    case INC:
      token = jj_consume_token(INC);
      break;
    case INCLUDING:
      token = jj_consume_token(INCLUDING);
      break;
    case REDUCE:
      token = jj_consume_token(REDUCE);
      break;
    case TIME:
      token = jj_consume_token(TIME);
      break;
    case RULES:
      token = jj_consume_token(RULES);
      break;
    case JBO:
      token = jj_consume_token(JBO);
      break;
    case ASSOCIATIVE:
      token = jj_consume_token(ASSOCIATIVE);
      break;
    case COMMUTATIVE:
      token = jj_consume_token(COMMUTATIVE);
      break;
    case HT:
      token = jj_consume_token(HT);
      break;
    case WEIV:
      token = jj_consume_token(WEIV);
      break;
    case ENDVIEW:
      token = jj_consume_token(ENDVIEW);
      break;
    case GATHERING:
      token = jj_consume_token(GATHERING);
      break;
    case PRECEDENCE:
      token = jj_consume_token(PRECEDENCE);
      break;
    case THEORY:
      token = jj_consume_token(THEORY);
      break;
    case SH:
      token = jj_consume_token(SH);
      break;
    case LONGQUIT:
      token = jj_consume_token(LONGQUIT);
      break;
    case IDEMPOTENT:
      token = jj_consume_token(IDEMPOTENT);
      break;
    case OBJECT:
      token = jj_consume_token(OBJECT);
      break;
    case IDENTITY:
      token = jj_consume_token(IDENTITY);
      break;
    case DEFINE:
      token = jj_consume_token(DEFINE);
      break;
    case INPUT:
      token = jj_consume_token(INPUT);
      break;
    case MORPH:
      token = jj_consume_token(MORPH);
      break;
    default:
      jj_la1[184] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final public void ContextDecl(CaseModule module) throws ParseException {
   String string;
    jj_consume_token(CONTEXT);
    string = Term(module);
           try {
              Term term = Term.parse(module, string);
              module.setContext(term);
           } catch (TermException e) {

              token = getToken(0);
              String msg;

              if (e.getCount() > 0) {
                  msg = "format:"+e.getMessage()+"\u005cnat line "+
                        token.beginLine+".\u005cn";
              } else {
                  msg = e.getMessage()+"at line "+
                        token.beginLine+".\u005cn";
              }

              {if (true) throw new ParseException(msg);}
           }
    jj_consume_token(DOT);
  }

  final public void CaseDecl(CaseModule module) throws ParseException {
   String string;
    jj_consume_token(CASE);
          ArrayList eqs = new ArrayList();
          Equation eq;
          Operation[] op;
          Module mod = (Module)module.clone();
          CaseModule cm = new CaseModule(mod.getModuleName(), mod);
          cm.vars = (Vector)module.vars.clone();
    label_67:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case CQ:
      case CEQ:
      case LB:
        eq = EquationDecl(cm);
            eqs.add(eq);
        break;
      case OP:
      case OPS:
      case OPAS:
        op = OperationDecl(cm);
             for (int i=0; i<op.length; i++) {
                eqs.add(op[i]);
             }
        break;
      default:
        jj_la1[185] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OP:
      case OPS:
      case OPAS:
      case EQ:
      case CQ:
      case CEQ:
      case LB:
        ;
        break;
      default:
        jj_la1[186] = jj_gen;
        break label_67;
      }
    }
           module.cases.add(eqs);
  }

  final public CaseModule CaseExp() throws ParseException {
   CaseModule cm;
   Token token, ftoken, btoken=null;
    jj_consume_token(USE);
          ArrayList cmlist = new ArrayList();
          ftoken = getToken(0);
    token = jj_consume_token(IDENTIFIER);
            CaseModule tmp = (CaseModule)casesPool.get(token.image);
            if (tmp == null) {
                 String msg = "no cases with the name "+
                              token.image+" at "+
                              "line "+token.beginLine+", column "+
                              token.beginColumn;
                 {if (true) throw new ParseException(msg);}
             }
             cmlist.add(tmp);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      label_68:
      while (true) {
        jj_consume_token(STAR);
        token = jj_consume_token(IDENTIFIER);
                      tmp = (CaseModule)casesPool.get(token.image);
                      if (tmp == null) {
                          String msg = "no cases with the name "+
                                       token.image+" at "+
                                       "line "+token.beginLine+", column "+
                                       token.beginColumn;
                          {if (true) throw new ParseException(msg);}
                      }
                      cmlist.add(tmp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          ;
          break;
        default:
          jj_la1[187] = jj_gen;
          break label_68;
        }
      }
      break;
    default:
      jj_la1[188] = jj_gen;
      ;
    }
               try {
                   if (cmlist.size() > 1) {
                       String name = "";
                       for (int i=0; i<cmlist.size(); i++) {
                          CaseModule c = (CaseModule)cmlist.get(i);
                          if (i == 0) {
                             name += c.name;
                          } else {
                             name += " * "+c.name;
                          }
                       }
                       ModuleName modName = new ModuleName(name);
                       cm = new CaseModule(modName, cmlist);
                   } else {
                       cm = (CaseModule)cmlist.get(0);
                   }
               } catch (CaseModuleException e) {
                   String msg =  e.getMessage()+" at line "+
                                 token.beginLine+", column "+
                                 token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
                   if (!token.image.equals("exclude")) {
                       String msg = "expect \u005c"exclude\u005c" at line "+
                                     token.beginLine+", column "+
                                     token.beginColumn;
                       {if (true) throw new ParseException(msg);}
                   }

                   btoken = token;
                   String sum = "exclude";
      label_69:
      while (true) {
                   String label = "";
        jj_consume_token(144);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
          token = jj_consume_token(INTEGER_LITERAL);
          break;
        case STAR:
          token = jj_consume_token(STAR);
          break;
        default:
          jj_la1[189] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                   label += token.image;
        label_70:
        while (true) {
          jj_consume_token(145);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER_LITERAL:
            token = jj_consume_token(INTEGER_LITERAL);
            break;
          case STAR:
            token = jj_consume_token(STAR);
            break;
          default:
            jj_la1[190] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                    label += ","+token.image;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 145:
            ;
            break;
          default:
            jj_la1[191] = jj_gen;
            break label_70;
          }
        }
        jj_consume_token(146);
                    // change case
                    try {
                         cm.remove(label);
                         sum += " ("+label+")";
                    } catch (Exception e) {
                         String msg = e.getMessage()+" at line "+
                                      btoken.beginLine+", column "+
                                      btoken.beginColumn;
                         {if (true) throw new ParseException(msg);}
                    }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 144:
          ;
          break;
        default:
          jj_la1[192] = jj_gen;
          break label_69;
        }
      }
                 cm.name = new ModuleName(cm.name.toString()+" "+sum);
      break;
    default:
      jj_la1[193] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
            try {
              if (mode == FILE_INPUT) {
                      writer.write("======================"+
                                  "====================\u005cn");
                      writer.write("use "+cm.name+"\u005cn");
                      writer.flush();
              }

           } catch (Exception e) {
              String msg = e.getMessage()+" at line "+
                           btoken.beginLine+", column "+
                           btoken.beginColumn;
              {if (true) throw new ParseException(msg);}
           }
           {if (true) return cm;}
    throw new Error("Missing return statement in function");
  }

  final public View MorphismDecl() throws ParseException {
    String viewName;
    Module source, target;
    Sort sort, sort1, sort2;
    Token token, token1, token2;
    View view;
    boolean hasParameter = false;
    boolean force = true;
    ArrayList views = null ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      token = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[194] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         viewName = token.image;
         Module pmod = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LB:
      jj_consume_token(LB);
              String str = "parameter-module-in-view"+token.image;
              ModuleName modName = new ModuleName(str);
              pmod = new Module(Module.LOOSE, modName);
              Module mod;
              List list = new ArrayList();
      label_71:
      while (true) {
        token = jj_consume_token(IDENTIFIER);
                list.add(token.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[195] = jj_gen;
          break label_71;
        }
      }
      jj_consume_token(DOUBLECOLON);
      mod = ModExpr(pmod);
               try {
                   for (int i=0; i<list.size(); i++) {
                       String paraName = (String)list.get(i);
                       pmod.addParameter(paraName, mod, getEnv());
                       paraPool.put(paraName, mod);
                   }
               } catch (SignatureException e) {
                   String msg = e.getMessage()+" at line "+
                                token.beginLine+" column "+
                                token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               } catch (ModuleParameterException e) {
                   String msg = e.getMessage()+" at line "+
                                token.beginLine+" column "+
                                token.beginColumn;
                   {if (true) throw new ParseException(msg);}
               }
      label_72:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 145:
          ;
          break;
        default:
          jj_la1[196] = jj_gen;
          break label_72;
        }
        jj_consume_token(145);
                   list = new ArrayList();
        label_73:
        while (true) {
          token = jj_consume_token(IDENTIFIER);
                   list.add(token.image);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[197] = jj_gen;
            break label_73;
          }
        }
        jj_consume_token(DOUBLECOLON);
        mod = ModExpr(pmod);
                 try {
                     for (int i=0; i<list.size(); i++) {
                         String paraName = (String)list.get(i);
                         pmod.addParameter(paraName, mod, getEnv());
                         paraPool.put(paraName, mod);
                     }
                 } catch (SignatureException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                     {if (true) throw new ParseException(msg);}
                 } catch (ModuleParameterException e) {
                     String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                     {if (true) throw new ParseException(msg);}
                 }
      }
      jj_consume_token(RB);
             hasParameter = true;
      break;
    default:
      jj_la1[198] = jj_gen;
      ;
    }
    jj_consume_token(FROM);
    source = ModExpr(pmod);
    jj_consume_token(TO);
    target = ModExpr(pmod);
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LB:
      if (jj_2_45(3)) {
        jj_consume_token(LB);
                  force = false;
                  int index = 0;
                  View[] vs = new View[source.paraNames.size()];
                  Module[] mds = new Module[vs.length];
                  String[] ns = new String[vs.length];
                  views = new ArrayList();

                  Module psrc = null;
                  Module ptgt = null;
                  try {
                      psrc = target.getParameterAt(index);
                      ptgt = source. getParameterAt(index);
                      //ns[index] = source.getParameterNameAt(index);
                  } catch (Exception e) {
                      String msg = e.getMessage()+" at line "+
                                  token.beginLine+" column "+
                                  token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                  }

                  Module md;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VIEW:
          mds[index] = LocalViewDecl(pmod, psrc, new Vector());
          break;
        case IDENTIFIER:
          token = jj_consume_token(IDENTIFIER);
                           View aView = (View)viewPool.get(token.image);
                           if (aView != null) {
                              mds[index] = (Module)aView.getTarget().clone();
                              mds[index].setProperty("view", aView);
                           } else {
                              String msg = "No view with the name "+
                                           token.image+" was found, at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }

                           if (! psrc.modName.equals(aView.source.modName)) {
                              String msg = "The view "+ token.image+
                                           " is defined from the module "+
                                           aView.source.modName+", not "+
                                           psrc.modName+", at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }

                           if (! ptgt.modName.equals(aView.target.modName)) {
                              String msg = "The view "+ token.image+
                                           " is defined to the module "+
                                           aView.target.modName+", not "+
                                           ptgt.modName+", at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }
          break;
        default:
          jj_la1[199] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                     vs[index] = (View)mds[index].getProperty("view");
                     views.add(vs[index].copy(""));

                     try {
                        vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
                                      target.getParameterNameAt(index),
                                      getEnv());

                        //mds[index] = vs[index].source;
                        mds[index] = vs[index].target;
                        mds[index].setProperty("view", vs[index]);

                     } catch (Exception e) {
                        String msg = e.getMessage()+" at line "+
                                     token.beginLine+" column "+
                                     token.beginColumn;
                        {if (true) throw new ParseException(msg);}
                     }

                     index++;
        label_74:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 145:
            ;
            break;
          default:
            jj_la1[200] = jj_gen;
            break label_74;
          }
          jj_consume_token(145);
                        try {
                           psrc = target.getParameterAt(index);
                           ptgt = source. getParameterAt(index);
                           //ns[index] = source.getParameterNameAt(index);
                        } catch (ModuleParameterException e) {
                           String msg = e.getMessage()+" at line "+
                                       token.beginLine+" column "+
                                       token.beginColumn;
                           {if (true) throw new ParseException(msg);}
                        }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VIEW:
            mds[index] = LocalViewDecl(pmod, psrc, new Vector());
            break;
          case IDENTIFIER:
            token = jj_consume_token(IDENTIFIER);
                           View aView = (View)viewPool.get(token.image);
                           if (aView != null) {
                              mds[index] = (Module)aView.getTarget().clone();
                              mds[index].setProperty("view", aView);
                           } else {
                              String msg = "No view with the name "+
                                           token.image+" was found, at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }

                           if (! psrc.modName.equals(aView.source.modName)) {
                              String msg = "The view "+ token.image+
                                           " is defined from the module "+
                                           aView.source.modName+", not "+
                                           psrc.modName+", at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }

                           if (! ptgt.modName.equals(aView.target.modName)) {
                              String msg = "The view "+ token.image+
                                           " is defined to the module "+
                                           aView.target.modName+", not "+
                                           ptgt.modName+", at line "+
                                           token.beginLine+" column "+
                                           token.beginColumn;
                              {if (true) throw new ParseException(msg);}
                           }
            break;
          default:
            jj_la1[201] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                          vs[index] = (View)mds[index].getProperty("view");
                          views.add(vs[index].copy(""));

                          try {
                             vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
                                      target.getParameterNameAt(index),
                                      getEnv());
                             //mds[index] = vs[index].source;
                             mds[index] = vs[index].target;
                             mds[index].setProperty("view", vs[index]);
                          } catch (Exception e) {
                             String msg = e.getMessage()+" at line "+
                                     token.beginLine+" column "+
                                     token.beginColumn;
                             {if (true) throw new ParseException(msg);}
                          }
                          index++;
        }
        jj_consume_token(RB);
                   try {
                      md = target.instanceBy(mds, ns, getEnv(), false);
                   } catch (Exception e) {
                      String msg = e.getMessage()+" at line "+
                                   token.beginLine+" column "+
                                   token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                   }

                   Module newTarget = md;
                   newTarget.modName = target.modName;
                   newTarget.paraNames.addAll(source.paraNames);
                   newTarget.paraModules.addAll(source.paraModules);
                   newTarget.levels = new int[1];
                   newTarget.levels[0] = source.paraNames.size();

                   target = newTarget;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LB:
          token = jj_consume_token(LB);
          jj_consume_token(RB);

          break;
        default:
          jj_la1[202] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[203] = jj_gen;
      ;
    }
            if (force) {

                   try {
                      View[] vs = new View[source.paraNames.size()];
                      Module[] mds = new Module[vs.length];
                      String[] ns = new String[vs.length];
                      views = new ArrayList();

                      for (int index=0; index<vs.length; index++) {

                          Module psrc = target.getParameterAt(index);
                          Module ptgt = source.getParameterAt(index);

                          vs[index] = new View("", psrc, ptgt);
                          vs[index].validate();
                          views.add(vs[index].copy(""));

                          vs[index] = vs[index].addNotation(
                                      source.getParameterNameAt(index),
                                      target.getParameterNameAt(index),
                                      getEnv());
                          mds[index] = vs[index].target;
                          mds[index].setProperty("view", vs[index]);
                       }

                       Module newTarget =
                           target.instanceBy(mds, ns, getEnv(), false);
                       newTarget.modName = target.modName;
                       newTarget.paraNames.addAll(source.paraNames);
                       newTarget.paraModules.addAll(source.paraModules);
                       newTarget.levels = new int[1];
                       newTarget.levels[0] = source.paraNames.size();

                       target = newTarget;

                   } catch (Exception e) {
                      String msg = e.getMessage()+" at line "+
                                   token.beginLine+" column "+
                                   token.beginColumn;
                      {if (true) throw new ParseException(msg);}
                   }


            }

            view = new View(viewName, source, target);
            if (hasParameter) {
                view.record(pmod);
            }
    label_75:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SORT:
      case VAR:
      case VARS:
      case OP:
        ;
        break;
      default:
        jj_la1[204] = jj_gen;
        break label_75;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
      case VARS:
            Vector vnames = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARS:
          jj_consume_token(VARS);
          break;
        case VAR:
          jj_consume_token(VAR);
          break;
        default:
          jj_la1[205] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_76:
        while (true) {
          token = jj_consume_token(IDENTIFIER);
               vnames.addElement(token);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[206] = jj_gen;
            break label_76;
          }
        }
        jj_consume_token(COLON);
        sort = SortReference(source);
        jj_consume_token(DOT);
              for (int i=0; i<vnames.size(); i++) {
                 Token tmp = (Token)vnames.elementAt(i);
                 Variable var = new Variable(tmp.image, sort);
                 try {
                    view.addVariable(var);
                 } catch (ViewException e) {
                    String msg = e.getMessage();
                    msg += " at line "+tmp.beginLine+
                              ", column "+tmp.beginColumn+".";
                    {if (true) throw new ParseException(msg);}
                 }
              }
        break;
      case SORT:
        jj_consume_token(SORT);
             token1 = getToken(0);
        sort1 = SortReference(source);
        jj_consume_token(TO);
             token2 = getToken(0);
        sort2 = SortReference(target);
        jj_consume_token(DOT);
            try {

              Sort tmp = view.getTarget(sort1);
              if (tmp != null && tmp.equals(sort2)) {
                  System.out.println("=================="+
                                     "========================");
                  System.out.println("Warning: duplicate mapping from "+
                                     sort1.getName()+" to "+sort2.getName()+
                                     " at line "+token1.beginLine);
              }

              view.addSortMap(sort1, sort2);
            } catch (ViewException e) {
               String msg = e.getMessage();
               msg += " at line "+token1.beginLine+".";
               {if (true) throw new ParseException(msg);}
            }
        break;
      case OP:
         String opname1, opname2;
        jj_consume_token(OP);
             token1 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname1 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname1 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          break;
        default:
          jj_la1[207] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(TO);
             token2 = getToken(0);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJ:
        case TH:
        case BTH:
        case DTH:
        case ENDO:
        case ENDTH:
        case ENDB:
        case ENDD:
        case END:
        case PR:
        case PROTECTING:
        case EX:
        case EXTENDING:
        case US:
        case USING:
        case INC:
        case INCLUDING:
        case IS:
        case SORT:
        case SORTS:
        case BSORT:
        case BSORTS:
        case SUBSORT:
        case SUBSORTS:
        case VAR:
        case VARS:
        case EQ:
        case LESS:
        case ARROW:
        case ADD:
        case SUM:
        case STAR:
        case LB:
        case RB:
        case FROM:
        case APPLY:
        case START:
        case AT:
        case WITHIN:
        case PRINT:
        case PARENS:
        case OF:
        case QUIT:
        case IN:
        case SHOW:
        case MAKE:
        case LET:
        case STOP:
        case SELECT:
        case SET:
        case TRACE:
        case ON:
        case OFF:
        case FULL:
        case INCLUDE:
        case REDUCTION:
        case REDUCE:
        case TIME:
        case JBO:
        case ASSOCIATIVE:
        case COMMUTATIVE:
        case HT:
        case WEIV:
        case ENDVIEW:
        case GATHERING:
        case PRECEDENCE:
        case THEORY:
        case SH:
        case LONGQUIT:
        case IDEMPOTENT:
        case OBJECT:
        case IDENTITY:
        case DEFINE:
        case INPUT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
        case 145:
          opname2 = OpName();
          break;
        case 144:
          jj_consume_token(144);
          opname2 = Term(view.getEnrichedTarget());
          jj_consume_token(146);
          break;
        default:
          jj_la1[208] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(DOT);
             Operation[] ops1 = source.getOperationsWithName(opname1.trim());

             if (ops1.length > 1) {
                String msg = "Multiple operations with the name "+
                              opname1+" in the module "+source.getModuleName()+
                              " at line "+token1.beginLine+" column "+
                              token1.beginColumn+".";
                {if (true) throw new ParseException(msg);}
             }

             Operation op1, op2;

             if (ops1.length == 1) {

                Operation[] ops2 =target.getOperationsWithName(opname2.trim());

                if (ops2.length > 1) {

                    Vector pool = new Vector();
                    for (int i=0; i<ops2.length; i++) {
                         boolean found = false;
                         for (int j=0; j<pool.size(); j++) {
                              Operation op = (Operation)pool.elementAt(j);
                              if (op.less(target, ops2[i])) {
                                   pool.removeElementAt(j);
                                   pool.insertElementAt(ops2[i], j);
                                   found = true;
                              } else if (ops2[i].less(target, op)) {
                                   found = true;
                              }
                         }

                         if (!found) {
                             pool.addElement(ops2[i]);
                         }
                    }

                    if (pool.size() > 1) {

                        String msg = "Multiple operations with the name "+
                                     opname2+" in the module "+
                                     target.getModuleName()+
                                     " at line "+token2.beginLine+" column "+
                                     token2.beginColumn+".";
                        {if (true) throw new ParseException(msg);}
                    } else {
                        ops2 = new Operation[pool.size()];
                        pool.copyInto(ops2);
                    }
                }

                if (ops2.length == 0) {

                     // no operation is found, parse it as a term
                     try {
                          Term term = Term.parse(view.getEnrichedTarget(),
                                                 opname2);
                          if (ops1[0].isConstant()) {

                             Term left = new Term(ops1[0]);
                             view.addTransformation(left, term);

                          } else {
                              String msg = opname1.trim()+
                                           " is not a constant in the module "+
                                           source.getModuleName()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                             {if (true) throw new ParseException(msg);}
                          }

                     } catch (TermException e) {

                          ops2 =
                            target.getOperationsWithCleanName(opname2.trim());
                          if (ops2.length == 1) {

                             try {
                                op1 = ops1[0];
                                op2 = ops2[0];
                                view.addOperationMap(op1, op2);
                             } catch (ViewException ex) {
                                String msg = ex.getMessage();
                                msg += " at line "+token1.beginLine+".";
                                {if (true) throw new ParseException(msg);}
                             }

                          } else {

                              String msg = "Unresolvable tokens "+
                                           opname2.trim()+
                                           " at line "+token2.beginLine+
                                           ", column "+token2.beginColumn;
                              {if (true) throw new ParseException(msg);}
                          }
                     }

                } else {

                   op1 = ops1[0];
                   op2 = ops2[0];

                   Operation tmp = view.getTarget(op1);
                   if (tmp != null && tmp.equals(op2)) {
                      System.out.println("======================"+
                                         "====================");
                      System.out.println("Warning: duplicate mapping from "+
                                          op1.getCleanName()+" to "+
                                          op2.getCleanName()+
                                          " at line "+token2.beginLine+
                                          " column "+token2.beginColumn+".");
                   }

                   try {
                      view.addOperationMap(op1, op2);
                   } catch (ViewException e) {
                      String msg = e.getMessage();
                      msg += " at line "+token1.beginLine+".";
                      {if (true) throw new ParseException(msg);}
                   }
                }

             } else {

                // no operation is found, try to parse term
                boolean okay = false;
                Term left = null;
                Term right = null;

                try {
                  StringReader sr = new StringReader(opname1);
                  BOBJ nbobj = new BOBJ(sr);
                  String strLeft = nbobj.Term(view.getEnrichedSource());

                  left =
                     Term.parse(view.getEnrichedSource(),
                                strLeft);

                  sr = new StringReader(opname2);
                  nbobj = new BOBJ(sr);
                  String strRight = nbobj.Term(view.getEnrichedTarget());

                  right =
                     Term.parse(view.getEnrichedTarget(),
                                strRight);

                  if (left != null && right != null) {
                     view.addTransformation(left, right);
                     okay = true;
                  }

                } catch (TermException e) {
                }

                if (!okay) {

                   Operation lop = null, rop = null;
                   if (left == null) {
                      Operation[] lops =
                          source.getOperationsWithCleanName(opname1.trim());
                      if (lops.length == 1) {
                         lop = lops[0];
                      }
                   }

                   if (right == null) {
                      Operation[] rops =
                          source.getOperationsWithCleanName(opname2.trim());
                      if (rops.length == 1) {
                         rop = rops[0];
                      }
                   }

                   // there are 3 cases:
                   try {
                       if (left != null && rop != null) {
                            view.addTransformation(left, new Term(rop));
                            okay = true;
                       } else if (lop != null && right != null) {
                            view.addTransformation(new Term(lop), right);
                            okay = true;
                       } else if (lop != null && rop != null) {
                            view.addOperationMap(lop, rop);
                            okay = true;
                       }
                   } catch (Exception ex) {}
                }


                if (!okay && left == null) {
                   String msg = "No operations with the name \u005c""+
                             opname1.trim()+"\u005c" in the module "+
                             source.getModuleName()+
                             " at line "+token1.beginLine+" column "+
                             token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}
                } else if (!okay && right == null) {
                   String msg = "No operations with the name \u005c""+
                             opname2.trim()+"\u005c" in the module "+
                             target.getModuleName()+
                             " at line "+token2.beginLine+" column "+
                             token2.beginColumn+".";
                   {if (true) throw new ParseException(msg);}
                } else if (!okay) {
                   String msg = "No parse "+
                                " at line "+token1.beginLine+" column "+
                                token1.beginColumn+".";
                   {if (true) throw new ParseException(msg);}

                }

             }
        break;
      default:
        jj_la1[209] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         try {

             if (views != null) {
                view.views = views;
                view.record();
             }
             view.validate();
             view.setAsMorphism();

         } catch (ViewException e) {

             Token xt = getToken(0);
             String msg = e.getMessage()+
                          " at line "+xt.beginLine+", column "+
                          xt.beginColumn+".";

             if (detail) {
                msg = "format:"+format(msg, 0)+"\u005cn"+
                      "the failed view is\u005cn"+e.getView();
             }

             {if (true) throw new ParseException(msg);}
         }

         {if (true) return view;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(DTH)) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_scan_token(WEIV)) return true;
    return false;
  }

  private boolean jj_3R_373() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_466()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(BTH)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(TH)) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(HT)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_scan_token(OBJ)) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_scan_token(OPEN)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(IDEMPOTENT)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_scan_token(COMMENT)) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) return true;
    }
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_scan_token(COMMUTATIVE)) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_scan_token(OPEN)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_scan_token(ASSOCIATIVE)) return true;
    return false;
  }

  private boolean jj_3R_350() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_372()) {
    jj_scanpos = xsp;
    if (jj_3R_373()) return true;
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3_37()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_84() {
    Token xsp;
    if (jj_3_38()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_38()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_scan_token(JBO)) return true;
    return false;
  }

  private boolean jj_3R_445() {
    if (jj_scan_token(START)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  private boolean jj_3R_444() {
    if (jj_scan_token(PRINT)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(LS)) return true;
    return false;
  }

  private boolean jj_3R_443() {
    if (jj_scan_token(AT)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(RULES)) return true;
    return false;
  }

  private boolean jj_3R_442() {
    if (jj_scan_token(WITHIN)) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(145)) return true;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_465() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_441() {
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3R_371() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_465()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(TIME)) return true;
    return false;
  }

  private boolean jj_3R_440() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(144)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_scan_token(MAKE)) return true;
    return false;
  }

  private boolean jj_3R_439() {
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_438() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_460() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(144)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_437() {
    if (jj_scan_token(FULL)) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_436() {
    if (jj_scan_token(OFF)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_435() {
    if (jj_scan_token(ON)) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(FULL)) return true;
    return false;
  }

  private boolean jj_3R_434() {
    if (jj_scan_token(TRACE)) return true;
    return false;
  }

  private boolean jj_3R_370() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_433() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(CD)) return true;
    return false;
  }

  private boolean jj_3R_349() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_370()) {
    jj_scanpos = xsp;
    if (jj_3R_371()) return true;
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(OFF)) return true;
    return false;
  }

  private boolean jj_3R_432() {
    if (jj_scan_token(SHOW)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(PWD)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(144)) return true;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_431() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(LB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_460()) {
    jj_scanpos = xsp;
    if (jj_3R_461()) {
    jj_scanpos = xsp;
    if (jj_3R_462()) {
    jj_scanpos = xsp;
    if (jj_3R_463()) return true;
    }
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_464()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RB)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_scan_token(ON)) return true;
    return false;
  }

  private boolean jj_3R_430() {
    if (jj_scan_token(STOP)) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(LONGQUIT)) return true;
    return false;
  }

  private boolean jj_3R_429() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(145)) return true;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(TRACE)) return true;
    return false;
  }

  private boolean jj_3R_428() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_508() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("cases");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("restore");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_331()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("mask");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_332()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("umask");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_333()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("do")  &&
                    getToken(2).image.equals("restore")  &&
                    getToken(3).image.equals("init");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_334()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).image.equals("call-that");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_335()) {
    jj_scanpos = xsp;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) {
    jj_scanpos = xsp;
    if (jj_3R_342()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_323() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    return false;
  }

  private boolean jj_3R_487() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_427() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_459() {
    if (jj_scan_token(145)) return true;
    if (jj_3R_458()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_507() {
    if (jj_3R_369()) return true;
    return false;
  }

  private boolean jj_3R_426() {
    if (jj_scan_token(ADD)) return true;
    return false;
  }

  private boolean jj_3R_486() {
    if (jj_scan_token(144)) return true;
    return false;
  }

  private boolean jj_3R_478() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_486()) {
    jj_scanpos = xsp;
    if (jj_3R_487()) return true;
    }
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_scan_token(COMMENT)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_506() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  private boolean jj_3R_425() {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(SHOW)) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_424() {
    if (jj_scan_token(INPUT)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) return true;
    }
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_505() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_423() {
    if (jj_scan_token(DEFINE)) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_354()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_353()) return true;
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(144)) return true;
    if (jj_3R_458()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_459()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_504() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_421() {
    if (jj_scan_token(LONGQUIT)) return true;
    return false;
  }

  private boolean jj_3R_345() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_367()) {
    jj_scanpos = xsp;
    if (jj_3R_368()) return true;
    }
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_3R_350()) return true;
    return false;
  }

  private boolean jj_3R_498() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_504()) {
    jj_scanpos = xsp;
    if (jj_3R_505()) {
    jj_scanpos = xsp;
    if (jj_3R_506()) {
    jj_scanpos = xsp;
    if (jj_3R_507()) {
    jj_scanpos = xsp;
    if (jj_3R_508()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(OF)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_3R_349()) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_scan_token(STOP)) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(LB)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(RB)) return true;
    return false;
  }

  private boolean jj_3R_420() {
    if (jj_scan_token(SH)) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_3R_369()) return true;
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_scan_token(MORPH)) return true;
    return false;
  }

  private boolean jj_3R_419() {
    if (jj_scan_token(THEORY)) return true;
    return false;
  }

  private boolean jj_3R_383() {
    if (jj_scan_token(OPS)) return true;
    Token xsp;
    if (jj_3R_478()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_478()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_418() {
    if (jj_scan_token(ENDVIEW)) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_scan_token(LET)) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_scan_token(WEIV)) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_scan_token(144)) return true;
    Token xsp;
    if (jj_3R_86()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_86()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(ADD)) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_scan_token(BRED)) return true;
    return false;
  }

  private boolean jj_3R_416() {
    if (jj_scan_token(HT)) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(INPUT)) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_415() {
    if (jj_scan_token(JBO)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    }
    return false;
  }

  private boolean jj_3R_483() {
    if (jj_scan_token(144)) return true;
    Token xsp;
    if (jj_3R_498()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_498()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_scan_token(IDENTITY)) return true;
    return false;
  }

  private boolean jj_3R_366() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) return true;
    }
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_scan_token(DEFINE)) return true;
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_scan_token(LET)) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_scan_token(LONGQUIT)) return true;
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_scan_token(VARS)) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_scan_token(VIEW)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_scan_token(SH)) return true;
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_scan_token(VAR)) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(THEORY)) return true;
    return false;
  }

  private boolean jj_3R_409() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_scan_token(PRECEDENCE)) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(MAKE)) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_scan_token(CEQ)) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_scan_token(GATHERING)) return true;
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_scan_token(SUBSORTS)) return true;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_scan_token(CQ)) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_scan_token(ENDVIEW)) return true;
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_scan_token(SUBSORT)) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(SORT)) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_scan_token(BSORTS)) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_scan_token(WEIV)) return true;
    return false;
  }

  private boolean jj_3R_384() {
    if (jj_scan_token(LB)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_404() {
    if (jj_scan_token(BSORT)) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_scan_token(HT)) return true;
    return false;
  }

  private boolean jj_3R_477() {
    if (jj_scan_token(144)) return true;
    return false;
  }

  private boolean jj_3R_357() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_384()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_3R_385()) {
    jj_scanpos = xsp;
    if (jj_3R_386()) return true;
    }
    }
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3R_403() {
    if (jj_scan_token(USING)) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(SORTS)) return true;
    return false;
  }

  private boolean jj_3R_476() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_scan_token(IDEMPOTENT)) return true;
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_scan_token(US)) return true;
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_scan_token(OPAS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_476()) {
    jj_scanpos = xsp;
    if (jj_3R_477()) return true;
    }
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(COMMUTATIVE)) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_scan_token(EXTENDING)) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(REDUCE)) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_scan_token(EX)) return true;
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_scan_token(ASSOCIATIVE)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_3R_366()) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_scan_token(PROTECTING)) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_scan_token(JBO)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_345()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_398() {
    if (jj_scan_token(PR)) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(REDUCTION)) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_scan_token(TIME)) return true;
    return false;
  }

  private boolean jj_3R_397() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(LB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_302()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RB)) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_scan_token(REDUCE)) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_scan_token(ENDD)) return true;
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_scan_token(ENDB)) return true;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_scan_token(INCLUDING)) return true;
    return false;
  }

  private boolean jj_3R_515() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(INCLUDING)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_scan_token(ENDTH)) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  private boolean jj_3R_513() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_178()) return true;
    if (jj_scan_token(146)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_515()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_512() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_scan_token(ENDO)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(IN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_77()) jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(REDUCTION)) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_scan_token(DTH)) return true;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(INCLUDE)) return true;
    return false;
  }

  private boolean jj_3R_391() {
    if (jj_scan_token(BTH)) return true;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_scan_token(TH)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_scan_token(PARENS)) return true;
    return false;
  }

  private boolean jj_3R_499() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(PRINT)) return true;
    return false;
  }

  private boolean jj_3R_514() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_389() {
    if (jj_scan_token(OBJ)) return true;
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  private boolean jj_3R_511() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_178()) return true;
    if (jj_scan_token(146)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_514()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_388() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_510() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) return true;
    }
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_scan_token(LET)) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_387() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_471() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_499()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(140)) jj_scanpos = xsp;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_scan_token(VARS)) return true;
    return false;
  }

  private boolean jj_3R_503() {
    if (jj_scan_token(OP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_510()) {
    jj_scanpos = xsp;
    if (jj_3R_511()) return true;
    }
    if (jj_scan_token(TO)) return true;
    xsp = jj_scanpos;
    if (jj_3R_512()) {
    jj_scanpos = xsp;
    if (jj_3R_513()) return true;
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_scan_token(START)) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(WITHIN)) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_scan_token(VAR)) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_scan_token(SUM)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_scan_token(SUBSORTS)) return true;
    return false;
  }

  private boolean jj_3R_502() {
    if (jj_scan_token(SORT)) return true;
    if (jj_3R_471()) return true;
    if (jj_scan_token(TO)) return true;
    if (jj_3R_471()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_361() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_387()) {
    jj_scanpos = xsp;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) {
    jj_scanpos = xsp;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) {
    jj_scanpos = xsp;
    if (jj_3R_394()) {
    jj_scanpos = xsp;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) {
    jj_scanpos = xsp;
    if (jj_3R_397()) {
    jj_scanpos = xsp;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) {
    jj_scanpos = xsp;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) {
    jj_scanpos = xsp;
    if (jj_3R_405()) {
    jj_scanpos = xsp;
    if (jj_3R_406()) {
    jj_scanpos = xsp;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_3R_408()) {
    jj_scanpos = xsp;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) {
    jj_scanpos = xsp;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) {
    jj_scanpos = xsp;
    if (jj_3R_419()) {
    jj_scanpos = xsp;
    if (jj_3R_420()) {
    jj_scanpos = xsp;
    if (jj_3R_421()) {
    jj_scanpos = xsp;
    if (jj_3R_422()) {
    jj_scanpos = xsp;
    if (jj_3R_423()) {
    jj_scanpos = xsp;
    if (jj_3R_424()) {
    jj_scanpos = xsp;
    if (jj_3R_425()) {
    jj_scanpos = xsp;
    if (jj_3R_426()) {
    jj_scanpos = xsp;
    if (jj_3R_427()) {
    jj_scanpos = xsp;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) {
    jj_scanpos = xsp;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) {
    jj_scanpos = xsp;
    if (jj_3R_433()) {
    jj_scanpos = xsp;
    if (jj_3R_434()) {
    jj_scanpos = xsp;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) {
    jj_scanpos = xsp;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) {
    jj_scanpos = xsp;
    if (jj_3R_439()) {
    jj_scanpos = xsp;
    if (jj_3R_440()) {
    jj_scanpos = xsp;
    if (jj_3R_441()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) {
    jj_scanpos = xsp;
    if (jj_3R_443()) {
    jj_scanpos = xsp;
    if (jj_3R_444()) {
    jj_scanpos = xsp;
    if (jj_3R_445()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_scan_token(SUBSORT)) return true;
    return false;
  }

  private boolean jj_3_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_scan_token(CASE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_475() {
    if (jj_scan_token(144)) return true;
    return false;
  }

  private boolean jj_3R_177() {
    Token xsp;
    if (jj_3R_361()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_361()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(VARS)) return true;
    return false;
  }

  private boolean jj_3R_474() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_scan_token(BSORTS)) return true;
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_3R_83()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_27()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_scan_token(BSORT)) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_scan_token(OP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_474()) {
    jj_scanpos = xsp;
    if (jj_3R_475()) return true;
    }
    return false;
  }

  private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_381()) {
    jj_scanpos = xsp;
    if (jj_3R_382()) {
    jj_scanpos = xsp;
    if (jj_3R_383()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_scan_token(USING)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(VAR)) return true;
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(144)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_scan_token(US)) return true;
    return false;
  }

  private boolean jj_3R_491() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_500()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_509() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_490() {
    if (jj_3R_500()) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(EXTENDING)) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_3R_365()) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_scan_token(EX)) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_501() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    if (jj_3R_509()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_509()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_471()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_497() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_501()) {
    jj_scanpos = xsp;
    if (jj_3R_502()) {
    jj_scanpos = xsp;
    if (jj_3R_503()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_482() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(144)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(PROTECTING)) return true;
    return false;
  }

  private boolean jj_3R_464() {
    if (jj_scan_token(145)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_482()) {
    jj_scanpos = xsp;
    if (jj_3R_483()) {
    jj_scanpos = xsp;
    if (jj_3R_484()) {
    jj_scanpos = xsp;
    if (jj_3R_485()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(PR)) return true;
    return false;
  }

  private boolean jj_3R_489() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_500()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(OP)) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_scan_token(VIEW)) return true;
    if (jj_scan_token(TO)) return true;
    if (jj_3R_78()) return true;
    if (jj_scan_token(IS)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_497()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_488() {
    if (jj_3R_500()) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(RB)) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_scan_token(ENDD)) return true;
    return false;
  }

  private boolean jj_3R_480() {
    if (jj_scan_token(OP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_488()) {
    jj_scanpos = xsp;
    if (jj_3R_489()) return true;
    }
    if (jj_scan_token(TO)) return true;
    xsp = jj_scanpos;
    if (jj_3R_490()) {
    jj_scanpos = xsp;
    if (jj_3R_491()) return true;
    }
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_scan_token(ENDB)) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_scan_token(BTH)) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_scan_token(ENDTH)) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_scan_token(ENDO)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_scan_token(DTH)) return true;
    return false;
  }

  private boolean jj_3R_463() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(DTH)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_scan_token(BTH)) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(LB)) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(TH)) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(OBJ)) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_473() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_scan_token(ADD)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_318() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) return true;
    }
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_scan_token(START)) return true;
    return false;
  }

  private boolean jj_3_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) {
    jj_scanpos = xsp;
    if (jj_3R_270()) {
    jj_scanpos = xsp;
    if (jj_3R_271()) {
    jj_scanpos = xsp;
    if (jj_3R_272()) {
    jj_scanpos = xsp;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) {
    jj_scanpos = xsp;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) {
    jj_scanpos = xsp;
    if (jj_3R_284()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) {
    jj_scanpos = xsp;
    if (jj_3R_286()) {
    jj_scanpos = xsp;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) {
    jj_scanpos = xsp;
    if (jj_3R_289()) {
    jj_scanpos = xsp;
    if (jj_3R_290()) {
    jj_scanpos = xsp;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) {
    jj_scanpos = xsp;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_472() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_379() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_472()) {
    jj_scanpos = xsp;
    if (jj_3R_473()) return true;
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_500() {
    Token xsp;
    if (jj_3_44()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_44()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_479() {
    if (jj_scan_token(SORT)) return true;
    if (jj_3R_471()) return true;
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_scan_token(PRINT)) return true;
    return false;
  }

  private boolean jj_3R_458() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_479()) {
    jj_scanpos = xsp;
    if (jj_3R_480()) return true;
    }
    return false;
  }

  private boolean jj_3R_354() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) return true;
    }
    if (jj_3R_379()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_379()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_scan_token(AT)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_scan_token(WITHIN)) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_303()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_26()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_scan_token(MB)) return true;
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_scan_token(DTH)) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_358() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(FULL)) return true;
    return false;
  }

  private boolean jj_3R_462() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(OFF)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_scan_token(ON)) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(TRACE)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_316() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) return true;
    }
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(SHOW)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(STOP)) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_315() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(USE)) return true;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_380() {
    if (jj_3R_366()) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(LET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) return true;
    }
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_scan_token(VARSOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_380()) jj_scanpos = xsp;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_314() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(ADD)) return true;
    return false;
  }

  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_scan_token(PSORT)) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) {
    jj_scanpos = xsp;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) {
    jj_scanpos = xsp;
    if (jj_3R_244()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(INPUT)) return true;
    return false;
  }

  private boolean jj_3R_362() {
    Token xsp;
    if (jj_3_43()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_43()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_313() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_scan_token(IDENTITY)) return true;
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(DEFINE)) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(RB)) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(LONGQUIT)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(SH)) return true;
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(140)) jj_scanpos = xsp;
    if (jj_scan_token(RULES)) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_3R_471()) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(THEORY)) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(PARSE)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(PRECEDENCE)) return true;
    return false;
  }

  private boolean jj_3R_353() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    if (jj_3R_378()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_378()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_312() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(GATHERING)) return true;
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_scan_token(TIME)) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(ENDVIEW)) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(144)) return true;
    Token xsp;
    if (jj_3_41()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_41()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(WEIV)) return true;
    return false;
  }

  private boolean jj_3R_470() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(HT)) return true;
    return false;
  }

  private boolean jj_3R_485() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = mode == FILE_INPUT &&
                         getToken(1).image.equals(".") &&
                         getToken(2).image.equals("(");
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_182()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(IDEMPOTENT)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    Token xsp;
    if (jj_3_42()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_42()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    if (jj_scan_token(VIEW)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(COMMUTATIVE)) return true;
    return false;
  }

  private boolean jj_3R_377() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_470()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_scan_token(CLOSE)) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(ASSOCIATIVE)) return true;
    return false;
  }

  private boolean jj_3R_310() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) return true;
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(JBO)) return true;
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_scan_token(TIME)) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_scan_token(LB)) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_scan_token(REDUCE)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(INCLUDING)) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_scan_token(OPENR)) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_496() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_469() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) return true;
    }
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  private boolean jj_3R_376() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) return true;
    }
    if (jj_3R_469()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_469()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_352() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) return true;
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(REDUCTION)) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_495() {
    if (jj_3R_369()) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(INCLUDE)) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(PARENS)) return true;
    return false;
  }

  private boolean jj_3R_494() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_scan_token(OPEN)) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_scan_token(ADD)) return true;
    return false;
  }

  private boolean jj_3R_468() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(145)) return true;
    return false;
  }

  private boolean jj_3R_493() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(LET)) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  private boolean jj_3R_492() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_481() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_492()) {
    jj_scanpos = xsp;
    if (jj_3R_493()) {
    jj_scanpos = xsp;
    if (jj_3R_494()) {
    jj_scanpos = xsp;
    if (jj_3R_495()) {
    jj_scanpos = xsp;
    if (jj_3R_496()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_scan_token(MAKE)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(SORTS)) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_scan_token(144)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(146)) return true;
    return false;
  }

  private boolean jj_3R_467() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(SORT)) return true;
    return false;
  }

  private boolean jj_3R_375() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_467()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_468()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_scan_token(IDENTITY)) return true;
    return false;
  }

  private boolean jj_3R_484() {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(VARS)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_3R_346()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_scan_token(VAR)) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_scan_token(DEFINE)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_scan_token(144)) return true;
    Token xsp;
    if (jj_3R_85()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_85()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_scan_token(SELECT)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_457() {
    if (jj_3R_359()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_scan_token(INPUT)) return true;
    return false;
  }

  private boolean jj_3R_456() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_461() {
    if (jj_scan_token(144)) return true;
    Token xsp;
    if (jj_3R_481()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_481()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(146)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_455() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(SUBSORTS)) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(IS)) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_scan_token(SUBSORT)) return true;
    return false;
  }

  private boolean jj_3R_454() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_369() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(LONGQUIT)) return true;
    return false;
  }

  private boolean jj_3R_453() {
    if (jj_3R_356()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(BSORTS)) return true;
    return false;
  }

  private boolean jj_3R_452() {
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_scan_token(USE)) return true;
    return false;
  }

  private boolean jj_3R_451() {
    if (jj_3R_354()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_scan_token(BSORT)) return true;
    return false;
  }

  private boolean jj_3R_450() {
    if (jj_3R_353()) return true;
    return false;
  }

  private boolean jj_3R_374() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_449() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(SH)) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(USING)) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_177()) return true;
    return false;
  }

  private boolean jj_3R_448() {
    if (jj_3R_351()) return true;
    return false;
  }

  private boolean jj_3R_447() {
    if (jj_3R_350()) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_scan_token(US)) return true;
    return false;
  }

  private boolean jj_3R_446() {
    if (jj_3R_349()) return true;
    return false;
  }

  private boolean jj_3R_365() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_446()) {
    jj_scanpos = xsp;
    if (jj_3R_447()) {
    jj_scanpos = xsp;
    if (jj_3R_448()) {
    jj_scanpos = xsp;
    if (jj_3R_449()) {
    jj_scanpos = xsp;
    if (jj_3R_450()) {
    jj_scanpos = xsp;
    if (jj_3R_451()) {
    jj_scanpos = xsp;
    if (jj_3R_452()) {
    jj_scanpos = xsp;
    if (jj_3R_453()) {
    jj_scanpos = xsp;
    if (jj_3R_454()) {
    jj_scanpos = xsp;
    if (jj_3R_455()) {
    jj_scanpos = xsp;
    if (jj_3R_456()) {
    jj_scanpos = xsp;
    if (jj_3R_457()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_351() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) return true;
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_374()) {
    jj_scanpos = xsp;
    if (jj_3R_375()) return true;
    }
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_scan_token(EXTENDING)) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(THEORY)) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(EX)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_scan_token(OPENR)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_scan_token(PROTECTING)) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(PRECEDENCE)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_scan_token(PR)) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_scan_token(OPENR)) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(GATHERING)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(ENDD)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(STOP)) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    }
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(ENDB)) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(ENDVIEW)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(ENDTH)) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(ENDO)) return true;
    return false;
  }

  private boolean jj_3R_466() {
    if (jj_3R_78()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public BOBJTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[210];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfbfff000,0x0,0xfbfff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x110000,0x2000,0x120000,0x140000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x100000,0x0,0x0,0x80000000,0x80000000,0x100000,0xfbfff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf000,0x0,0x0,0xbbe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbbe00000,0x1000,0x110000,0x180000,0x2000,0x120000,0x140000,0x100000,0xf000,0xf000,0xbbe00000,0x0,0x0,0x0,0x0,0x0,0xfbfff000,0xfbfff000,0x0,0x0,0xfbfff000,0xfbfff000,0x0,0x0,0x7bfff000,0x7bfff000,0x80000000,0x0,0x0,0xbbe00000,0x600000,0x0,0x1800000,0x0,0x3a000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfbfff000,0x0,0x0,0x0,0xfbfff000,0x0,0x0,0x0,0x0,0x0,0xfbfff000,0xfbfff000,0x0,0x0,0x0,0x0,0xfbfff000,0x4bfff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0108000,0xf0108000,0x0,0x7bfff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0xfbfff000,0xfbfff000,0x80000000,0x80000000,0x0,0x0,0x0,0xfbfff000,0x0,0xfbfff000,0x80000000,0x100000,0x80000000,0x0,0x0,0xfbfff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0xfbfff000,0xfbfff000,0x80000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xfffffff7,0x0,0xfffffff7,0x0,0x0,0x1000000,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0xc0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x101,0x101,0x0,0xfffffff7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2003ff7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2003ff7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2003ff7,0x0,0x0,0x0,0x0,0x0,0xfffffff7,0xfffffff7,0x0,0x0,0xfffffff7,0xfffffff7,0x0,0x80000000,0xb0c000f6,0xb0c000f6,0x100,0x0,0x0,0x2003ff7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x6,0x0,0x7,0x30,0x0,0x0,0x400000,0x0,0xc0,0x0,0x0,0xb0c008f7,0x0,0x3fc000,0x0,0xb0c008f7,0x0,0x0,0x0,0x3fc000,0x0,0xb0c008f7,0xb0c008f7,0x0,0x3fc000,0x0,0x700,0xb0c008f7,0xb0c008f6,0x0,0x4000,0x8000,0x10000,0xc0000,0x0,0x20000,0x0,0x0,0x0,0x3fc000,0x0,0x0,0x3800,0x1000000,0xb4c009c1,0xb4c009c1,0x0,0xb0c000f6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0xc0,0x0,0xb0c008f7,0xb0c008f7,0x1c0,0x1c0,0xc0,0x0,0x0,0xb0c008f7,0x0,0xb0c008f7,0x1c0,0x0,0x1,0x0,0x0,0xfffffff7,0x3f00,0x3f00,0x80000000,0x80000000,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0xc0,0x0,0xb0c008f7,0xb0c008f7,0x1c0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xffffffff,0x2000000,0xffffffff,0x4000000,0x4000000,0x0,0x4000000,0x0,0x0,0x4000000,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x80000000,0x800,0x0,0x0,0x10000000,0xffffffff,0x8,0x0,0x4000000,0x4000000,0x80000000,0x0,0x0,0x0,0x80000000,0x100000,0x0,0x0,0x0,0x84040010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x40008,0x28000,0x100000,0x3e00000,0x0,0x88000200,0x100,0x2000001d,0x40006000,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x20000005,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x200,0x200,0x60000005,0x1,0x0,0x0,0x0,0x0,0xffffffff,0xffffffff,0x200,0x0,0xffffffff,0xffffffff,0x200,0x1,0x20280001,0x20280001,0x0,0x0,0x0,0x60000005,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x200000,0x2e3ee803,0x0,0x0,0x1,0x2e3ee803,0x0,0x2100000,0x2100000,0x0,0x1,0x2e3ee803,0x2e3ee803,0x0,0x0,0x1,0x0,0x2e3ee803,0x2636e800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x2e372803,0x2e372803,0x4,0x20280001,0x0,0x0,0x0,0x0,0x1,0x0,0x10000,0x0,0x0,0x0,0x2e3ee803,0x2e3ee803,0x0,0x0,0x0,0x0,0x0,0x2e3ee803,0x0,0x2e3ee803,0x0,0x400,0x0,0x0,0x0,0xffffffff,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x200,0x0,0x200,0x1,0x1,0x0,0x0,0x0,0x2e3ee803,0x2e3ee803,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x7fffffff,0x40000000,0x7fffffff,0x1000000,0x1000000,0x0,0x1000000,0x0,0x0,0x1000000,0x1000000,0x1000000,0x8000000,0x8000,0x800000,0x40000,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x180000,0x1,0x0,0x0,0x0,0x0,0x7fffffff,0x1000,0x0,0x1000000,0x1000000,0x1,0x0,0xc0,0xc0,0x1,0x0,0xc0,0xc0,0xc0,0x421,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800,0x0,0x0,0x42000000,0x8800000,0x1,0x200,0x20001000,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x20000000,0x8000000,0x8000,0x0,0x800000,0x40000,0x0,0x0,0x8800000,0x8800000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x7fffffff,0x7fffffff,0x0,0x0,0x7fffffff,0x7fffffff,0x0,0x0,0x7fffbc00,0x7fffbc00,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbdfc,0x0,0x14430000,0x0,0x7fffbdfc,0x0,0x0,0x0,0x14430000,0x0,0x7fffbdfc,0x7fffbdfc,0x0,0x14430000,0x0,0x0,0x7fffbdfc,0x6b9c81fc,0x0,0x10000,0x20000,0x4000000,0x10000000,0x0,0x400000,0x0,0x0,0x0,0x14430000,0x0,0x0,0x0,0x0,0x7ffff9fc,0x7ffff9fc,0x20000000,0x7fffbc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbdfc,0x7fffbdfc,0x0,0x0,0x0,0x0,0x0,0x7fffbdfc,0x0,0x7fffbdfc,0x0,0x180000,0x0,0x0,0x0,0x7fffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffbdfc,0x7fffbdfc,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x1014,0x0,0x1014,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x20000,0x10000,0x1000,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x1014,0x0,0x20000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x1100,0x1010,0x1010,0x11010,0x20000,0x1000,0x11010,0x0,0x1100,0x0,0x0,0x0,0x0,0x4,0x0,0x8,0x0,0x1000,0x1010,0x10,0x21000,0x10000,0x1000,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x8,0x0,0x20000,0x1010,0x11010,0x20000,0x13014,0x13014,0x11010,0x20000,0x13014,0x13014,0x11010,0x0,0x11010,0x11010,0x0,0x1010,0x1010,0x8,0x0,0x11010,0x0,0x11010,0x0,0x11010,0x1000,0x0,0x0,0x1010,0x1010,0x0,0x1000,0x0,0x0,0x1010,0x1010,0x0,0x1010,0x0,0x1000,0x1000,0x31010,0x1010,0x1000,0x0,0x31010,0x1010,0x73000,0x73000,0x1000,0x0,0x31010,0x31010,0x1010,0x1000,0x0,0x0,0x21010,0x21010,0x10000,0x0,0x0,0x0,0x0,0x10000,0x0,0x1010,0x1010,0x1010,0x1000,0x1010,0x0,0x0,0x0,0x31112,0x21112,0x0,0x1010,0x1010,0x1000,0x20000,0x1000,0x0,0x20000,0x0,0x0,0x0,0x1000,0x31010,0x31010,0x0,0x0,0x0,0x1000,0x1000,0x31010,0x1000,0x31010,0x0,0x0,0x0,0x1010,0x1010,0x4,0x0,0x0,0x0,0x0,0x10,0x10,0x20000,0x10000,0x1000,0x1010,0x1000,0x20000,0x1000,0x0,0x1000,0x20000,0x1000,0x0,0x0,0x0,0x0,0x1000,0x31010,0x31010,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[45];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public BOBJ(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public BOBJ(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BOBJTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public BOBJ(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new BOBJTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public BOBJ(BOBJTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(BOBJTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 210; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[147];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 210; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 147; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 45; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
